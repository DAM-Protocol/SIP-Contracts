{
  "address": "0x1e191FAB6Ac58Adb658d9a70b9ACaa1ee21B2890",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "liquidityMinted",
          "type": "uint256"
        }
      ],
      "name": "TokenDeposited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract ISuperToken",
          "name": "superToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "TokenInitialised",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract ISuperToken",
          "name": "superToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "UpfrontFeeDeposited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract ISuperToken",
          "name": "superToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "UpfrontFeeReturned",
      "type": "event"
    }
  ],
  "transactionHash": "0x5581b045b0e5e575b21353466f747f5ab6e39d42858f701c358dc475d5ea880e",
  "receipt": {
    "to": null,
    "from": "0x917A19E71a2811504C4f64aB33c132063B5772a5",
    "contractAddress": "0x1e191FAB6Ac58Adb658d9a70b9ACaa1ee21B2890",
    "transactionIndex": 18,
    "gasUsed": "3030977",
    "logsBloom": "0x00000000000000000000000000000000400000000080000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000004000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000080000000000000000000200000000000000000000000400000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100040000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0xd7e90a36b385f598df562ce469ccdf3b017a012fbcf4f5f9f305fe1cee22e48e",
    "transactionHash": "0x5581b045b0e5e575b21353466f747f5ab6e39d42858f701c358dc475d5ea880e",
    "logs": [
      {
        "transactionIndex": 18,
        "blockNumber": 26774334,
        "transactionHash": "0x5581b045b0e5e575b21353466f747f5ab6e39d42858f701c358dc475d5ea880e",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000917a19e71a2811504c4f64ab33c132063b5772a5",
          "0x000000000000000000000000be188d6641e8b680743a4815dfa0f6208038960f"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000194420ff592a3000000000000000000000000000000000000000000000000047b66a8e0f079fb2000000000000000000000000000000000000000000001b049d967a733fb7ee8d000000000000000000000000000000000000000000000000479d266d0fae7582000000000000000000000000000000000000000000001b049dafbe943f1118bd",
        "logIndex": 62,
        "blockHash": "0xd7e90a36b385f598df562ce469ccdf3b017a012fbcf4f5f9f305fe1cee22e48e"
      }
    ],
    "blockNumber": 26774334,
    "cumulativeGasUsed": "6290953",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "07d64290edc1928aa6d477f4f2b0f813",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityMinted\",\"type\":\"uint256\"}],\"name\":\"TokenDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenInitialised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UpfrontFeeDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UpfrontFeeReturned\",\"type\":\"event\"}],\"devdoc\":{\"author\":\"rashtrakoff <rashtrakoff@pm.me>.\",\"custom:experimental\":\"This is an experimental contract/library. Use at your own risk.\",\"details\":\"Contains functions for interacting with dHEDGE protocol pools.\",\"kind\":\"dev\",\"methods\":{\"afterAgreementCreated(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes,bytes,bytes)\":{\"params\":{\"_agreementClass\":\"Tells whether it's CFA or IDA contract call.\",\"_cbdata\":\"Callback data passed on from `beforeAgreementCreated` hook.\",\"_ctx\":\"Superfluid context object.\",\"_dHedgePool\":\"Struct containing details regarding the pool and various tokens in it.\",\"_superToken\":\"The supertoken whose stream needs to be created.\"}},\"afterAgreementTerminated(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes,bytes,bytes)\":{\"params\":{\"_agreementClass\":\"Tells whether it's CFA or IDA contract call.\",\"_cbdata\":\"Callback data passed on from `beforeAgreementTerminated` hook.\",\"_ctx\":\"Superfluid context object.\",\"_dHedgePool\":\"Struct containing details regarding the pool and various tokens in it.\",\"_superToken\":\"Underlying token of the supertoken.\"}},\"afterAgreementUpdated(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes,bytes,bytes)\":{\"params\":{\"_agreementClass\":\"Tells whether it's CFA or IDA contract call.\",\"_cbdata\":\"Callback data passed on from `beforeAgreementUpdated` hook.\",\"_ctx\":\"Superfluid context object.\",\"_dHedgePool\":\"Struct containing details regarding the pool and various tokens in it.\",\"_superToken\":\"Underlying token of the supertoken.\"}},\"beforeAgreement(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes)\":{\"params\":{\"_agreementClass\":\"Tells whether it's CFA or IDA contract call.\",\"_superToken\":\"Underlying token of the supertoken.\"},\"returns\":{\"_cbdata\":\"Callback data that needs to be passed on to after agreement hooks.\"}},\"deposit(dHedgeStorage.dHedgePool storage,address)\":{\"params\":{\"_dHedgePool\":\"Struct containing details regarding the pool and various tokens in it.\",\"_depositToken\":\"Address of the underlying token (deposit token and not the supertoken).\"}},\"distribute(dHedgeStorage.dHedgePool storage,address)\":{\"params\":{\"_dHedgePool\":\"Struct containing details regarding the pool and various tokens in it.\",\"_depositToken\":\"Address of the underlying token (deposit token and not the supertoken).\"}},\"initStreamToken(dHedgeStorage.dHedgePool storage,ISuperToken)\":{\"params\":{\"_dHedgePool\":\"Struct containing details regarding the pool and various tokens in it.\",\"_superToken\":\"The supertoken which needs to be initialised.\"}},\"isDepositAsset(dHedgeStorage.dHedgePool storage,address)\":{\"params\":{\"_dHedgePool\":\"Struct containing details regarding the pool and various tokens in it.\",\"_token\":\"Address of the underlying token to be deposited.\"},\"returns\":{\"_0\":\"Boolean representing the status of the token for deposition.\"}},\"requireUpkeep(dHedgeStorage.dHedgePool storage)\":{\"details\":\"Function which checks if deposit function can be called or not.\",\"params\":{\"_dHedgePool\":\"Struct containing details regarding the pool and various tokens in it.\"},\"returns\":{\"_depositToken\":\"Address of an underlying token.\"}}},\"title\":\"dHEDGE core helper library.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"afterAgreementCreated(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes,bytes,bytes)\":{\"notice\":\"This function serves as the `afterAgreementCreated` hook for Superfluid CFA. Responsible for actions to be taken after creation of a stream (transfer buffer, update shares, etc.).\"},\"afterAgreementTerminated(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes,bytes,bytes)\":{\"notice\":\"This function serves as the `afterAgreementTerminated` hook for Superfluid CFA. Responsible for actions to be taken after termination of the stream (transfer buffer, update shares, etc.).\"},\"afterAgreementUpdated(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes,bytes,bytes)\":{\"notice\":\"This function serves as the `afterAgreementUpdated` hook for Superfluid CFA. Responsible for actions to be taken after updation of stream rate (transfer buffer, update shares, etc.).\"},\"beforeAgreement(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes)\":{\"notice\":\"Helper function that's called before streams are updated or terminated.\"},\"deposit(dHedgeStorage.dHedgePool storage,address)\":{\"notice\":\"Function to deposit tokens into a dHedge pool.\"},\"distribute(dHedgeStorage.dHedgePool storage,address)\":{\"notice\":\"Function to distribute DHPTx.\"},\"initStreamToken(dHedgeStorage.dHedgePool storage,ISuperToken)\":{\"notice\":\"Initialise a market for a new token. This means, create 3 indices (2 permanent and 1 temporary) along with unlimited approval- for the underlying token to the dHEDGE pool.\"},\"isDepositAsset(dHedgeStorage.dHedgePool storage,address)\":{\"notice\":\"Wrapper function to check if an asset is accepted as deposit asset in a dHedge pool.\"},\"requireUpkeep(dHedgeStorage.dHedgePool storage)\":{\"notice\":\"This function is useful for on-chain keepers. Deposit function should only be called if `_reqUpkeep` is true- let whatever be the address of the `_depositToken`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/dHedge-Factory-Version/Libraries/dHedgeHelper.sol\":\"dHedgeHelper\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbbc8ac883ac3c0078ce5ad3e288fbb3ffcc8a30c3a98c0fda0114d64fc44fca2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC777/IERC777.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n}\\n\",\"keccak256\":\"0xe4e0b7e3f0265ffaa565d26acd2d45f2633f19127ed625e5a05a9f201a87a667\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n\\n/**\\n * @title Constant Flow Agreement interface\\n * @author Superfluid\\n */\\nabstract contract IConstantFlowAgreementV1 is ISuperAgreement {\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\");\\n    }\\n\\n    /**\\n     * @notice Get the maximum flow rate allowed with the deposit\\n     * @dev The deposit is clipped and rounded down\\n     * @param deposit Deposit amount used for creating the flow\\n     * @return flowRate The maximum flow rate\\n     */\\n    function getMaximumFlowRateFromDeposit(\\n        ISuperfluidToken token,\\n        uint256 deposit)\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Get the deposit required for creating the flow\\n     * @dev Calculates the deposit based on the liquidationPeriod and flowRate\\n     * @param flowRate Flow rate to be tested\\n     * @return deposit The deposit amount based on flowRate and liquidationPeriod\\n     * NOTE:\\n     * - if calculated deposit (flowRate * liquidationPeriod) is less\\n     *   than the minimum deposit, we use the minimum deposit otherwise\\n     *   we use the calculated deposit\\n     */\\n    function getDepositRequiredForFlowRate(\\n        ISuperfluidToken token,\\n        int96 flowRate)\\n        external view virtual\\n        returns (uint256 deposit);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on host.getNow()\\n     * @param account The account we are interested in\\n     * @return isCurrentlyPatricianPeriod Whether it is currently the patrician period dictated by governance\\n     * @return timestamp The value of host.getNow()\\n     */\\n    function isPatricianPeriodNow(\\n        ISuperfluidToken token,\\n        address account)\\n        public view virtual\\n        returns (bool isCurrentlyPatricianPeriod, uint256 timestamp);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on timestamp\\n     * @param account The account we are interested in\\n     * @param timestamp The timestamp we are interested in observing the result of isPatricianPeriod\\n     * @return bool Whether it is currently the patrician period dictated by governance\\n     */\\n    function isPatricianPeriod(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 timestamp\\n    )\\n        public view virtual\\n        returns (bool);\\n\\n    /**\\n     * @dev msgSender from `ctx` updates permissions for the `flowOperator` with `flowRateAllowance`\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissions A bitmask representation of the granted permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowOperatorPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance,\\n        bytes calldata ctx\\n    ) \\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` grants `flowOperator` all permissions with flowRateAllowance as type(int96).max\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function authorizeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n     /**\\n     * @notice msgSender from `ctx` revokes `flowOperator` create/update/delete permissions\\n     * @dev `permissions` and `flowRateAllowance` will both be set to 0\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function revokeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Get the permissions of a flow operator between `sender` and `flowOperator` for `token`\\n     * @param token Super token address\\n     * @param sender The permission granter address\\n     * @param flowOperator The permission grantee address\\n     * @return flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorData(\\n       ISuperfluidToken token,\\n       address sender,\\n       address flowOperator\\n    )\\n        public view virtual\\n        returns (\\n            bytes32 flowOperatorId,\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Get flow operator using flowOperatorId\\n     * @param token Super token address\\n     * @param flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorDataByID(\\n       ISuperfluidToken token,\\n       bytes32 flowOperatorId\\n    )\\n        external view virtual\\n        returns (\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Create a flow betwen ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * # App callbacks\\n     *\\n     * - AgreementCreated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * NOTE:\\n     * - A deposit is taken as safety margin for the solvency agents\\n     * - A extra gas fee may be taken to pay for solvency agent liquidations\\n     */\\n    function createFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Create a flow between sender and receiver\\n    * @dev A flow created by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function createFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Update the flow rate between ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * # App callbacks\\n     *\\n     * - AgreementUpdated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * NOTE:\\n     * - Only the flow sender may update the flow rate\\n     * - Even if the flow rate is zero, the flow is not deleted\\n     * from the system\\n     * - Deposit amount will be adjusted accordingly\\n     * - No new gas fee is charged\\n     */\\n    function updateFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Update a flow between sender and receiver\\n    * @dev A flow updated by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function updateFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev Get the flow data between `sender` and `receiver` of `token`\\n     * @param token Super token address\\n     * @param sender Flow receiver\\n     * @param receiver Flow sender\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     * @return owedDeposit The amount of owed deposit of the flow\\n     */\\n    function getFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @notice Get flow data using agreementId\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The deposit amount of the flow\\n     * @return owedDeposit The owed deposit amount of the flow\\n     */\\n    function getFlowByID(\\n       ISuperfluidToken token,\\n       bytes32 agreementId\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @dev Get the aggregated flow info of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return timestamp Timestamp of when a flow was last updated for account\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getAccountFlowInfo(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @dev Get the net flow rate of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return flowRate Net flow rate\\n     */\\n    function getNetFlow(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     *\\n     * # App callbacks\\n     *\\n     * - AgreementTerminated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * NOTE:\\n     * - Both flow sender and receiver may delete the flow\\n     * - If Sender account is insolvent or in critical state, a solvency agent may\\n     *   also terminate the agreement\\n     * - Gas fee may be returned to the sender\\n     */\\n    function deleteFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev A flow deleted by an approved flow operator (see above for details on callbacks)\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     */\\n    function deleteFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n     \\n    /**\\n     * @dev Flow operator updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param flowOperator Flow operator address\\n     * @param permissions Octo bitmask representation of permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    event FlowOperatorUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    );\\n\\n    /**\\n     * @dev Flow updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param receiver Flow recipient address\\n     * @param flowRate Flow rate in amount per second for this flow\\n     * @param totalSenderFlowRate Total flow rate in amount per second for the sender\\n     * @param totalReceiverFlowRate Total flow rate in amount per second for the receiver\\n     * @param userData The user provided data\\n     *\\n     */\\n    event FlowUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed receiver,\\n        int96 flowRate,\\n        int256 totalSenderFlowRate,\\n        int256 totalReceiverFlowRate,\\n        bytes userData\\n    );\\n\\n    /**\\n     * @dev Flow updated extension event\\n     * @param flowOperator Flow operator address - the Context.msgSender\\n     * @param deposit The deposit amount for the stream\\n     */\\n    event FlowUpdatedExtension(\\n        address indexed flowOperator,\\n        uint256 deposit\\n    );\\n}\\n\",\"keccak256\":\"0xb96bb6cb0fe88ddf5b890b6826f7f7585cf6e94223c76d8e2fb269779afe4445\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n\\n/**\\n * @title Instant Distribution Agreement interface\\n * @author Superfluid\\n *\\n * Notes:\\n *   - A publisher can create as many as indices as possibly identifiable with `indexId`.\\n *     - `indexId` is deliberately limited to 32 bits, to avoid the chance for sha-3 collision.\\n *       Despite knowing sha-3 collision is only theoretical.\\n *   - A publisher can create a subscription to an index for any subscriber.\\n *   - A subscription consists of:\\n *     - The index it subscribes to.\\n *     - Number of units subscribed.\\n *   - An index consists of:\\n *     - Current value as `uint128 indexValue`.\\n *     - Total units of the approved subscriptions as `uint128 totalUnitsApproved`.\\n *     - Total units of the non approved subscription as `uint128 totalUnitsPending`.\\n *   - A publisher can update an index with a new value that doesn't decrease.\\n *   - A publisher can update a subscription with any number of units.\\n *   - A publisher or a subscriber can delete a subscription and reset its units to zero.\\n *   - A subscriber must approve the index in order to receive distributions from the publisher\\n *     each time the index is updated.\\n *     - The amount distributed is $$\\\\Delta{index} * units$$\\n *   - Distributions to a non approved subscription stays in the publisher's deposit until:\\n *     - the subscriber approves the subscription (side effect),\\n *     - the publisher updates the subscription (side effect),\\n *     - the subscriber deletes the subscription even if it is never approved (side effect),\\n *     - or the subscriber can explicitly claim them.\\n */\\nabstract contract IInstantDistributionAgreementV1 is ISuperAgreement {\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\");\\n    }\\n\\n    /**************************************************************************\\n     * Index operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Create a new index for the publisher\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * # App callbacks\\n     *\\n     * None\\n     */\\n    function createIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n    * @dev Index created event\\n    * @param token Super token address\\n    * @param publisher Index creator and publisher\\n    * @param indexId The specified indexId of the newly created index\\n    * @param userData The user provided data\\n    */\\n    event IndexCreated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Query the data of a index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @return exist Does the index exist\\n     * @return indexValue Value of the current index\\n     * @return totalUnitsApproved Total units approved for the index\\n     * @return totalUnitsPending Total units pending approval for the index\\n     */\\n    function getIndex(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                uint128 indexValue,\\n                uint128 totalUnitsApproved,\\n                uint128 totalUnitsPending);\\n\\n    /**\\n     * @dev Calculate actual distribution amount\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @return actualAmount The amount to be distributed after ensuring no rounding errors\\n     * @return newIndexValue The index value given the desired amount of tokens to be distributed\\n     */\\n    function calculateDistribution(\\n       ISuperfluidToken token,\\n       address publisher,\\n       uint32 indexId,\\n       uint256 amount)\\n           external view\\n           virtual\\n           returns(\\n               uint256 actualAmount,\\n               uint128 newIndexValue);\\n\\n    /**\\n     * @dev Update index value of an index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param indexValue Value of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * # App callbacks\\n     *\\n     * None\\n     */\\n    function updateIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index updated event\\n      * @param token Super token address\\n      * @param publisher Index updater and publisher\\n      * @param indexId The specified indexId of the updated index\\n      * @param oldIndexValue The previous index value\\n      * @param newIndexValue The updated index value\\n      * @param totalUnitsPending The total units pending when the indexValue was updated\\n      * @param totalUnitsApproved The total units approved when the indexValue was updated\\n      * @param userData The user provided data\\n      */\\n    event IndexUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        uint128 oldIndexValue,\\n        uint128 newIndexValue,\\n        uint128 totalUnitsPending,\\n        uint128 totalUnitsApproved,\\n        bytes userData);\\n\\n    /**\\n     * @dev Distribute tokens through the index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * NOTE:\\n     * - This is a convenient version of updateIndex. It adds to the index\\n     *   a delta that equals to `amount / totalUnits`\\n     * - The actual amount distributed could be obtained via\\n     *   `calculateDistribution`. This is due to precision error with index\\n     *   value and units data range\\n     *\\n     * # App callbacks\\n     *\\n     * None\\n     */\\n    function distribute(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n\\n    /**************************************************************************\\n     * Subscription operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Approve the subscription of an index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * # App callbacks\\n     *\\n     * - if subscription exist\\n     *   - AgreementCreated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     */\\n    function approveSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index subscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The approved subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexSubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n\\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionApproved(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n    * @notice Revoke the subscription of an index\\n    * @dev \\\"Unapproves\\\" the subscription and moves approved units to pending\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * # App callbacks\\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function revokeSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n         external\\n         virtual\\n         returns(bytes memory newCtx);\\n    /**\\n      * @dev Index unsubscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The unsubscribed subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexUnsubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionRevoked(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Update the nuber of units of a subscription\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @param units Number of units of the subscription\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * # App callbacks\\n     *\\n     * - if subscription exist\\n     *   - AgreementCreated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function updateSubscription(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n      * @dev Index units updated event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event IndexUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription units updated event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param indexId The specified indexId\\n      * @param publisher Index publisher\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint128 units,\\n        bytes userData);\\n\\n    /**\\n     * @dev Get data of a subscription\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @return exist Does the subscription exist?\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @notice Get data of a subscription by agreement ID\\n     * @dev indexId (agreementId) is the keccak256 hash of encodePacked(\\\"publisher\\\", publisher, indexId)\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return publisher The publisher of the index\\n     * @return indexId Id of the index\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscriptionByID(\\n        ISuperfluidToken token,\\n        bytes32 agreementId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address publisher,\\n                uint32 indexId,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @dev List subscriptions of an user\\n     * @param token Super token address\\n     * @param subscriber The subscriber's address\\n     * @return publishers Publishers of the subcriptions\\n     * @return indexIds Indexes of the subscriptions\\n     * @return unitsList Units of the subscriptions\\n     */\\n    function listSubscriptions(\\n        ISuperfluidToken token,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address[] memory publishers,\\n                uint32[] memory indexIds,\\n                uint128[] memory unitsList);\\n\\n    /**\\n     * @dev Delete the subscription of an user\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber's address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * # App callbacks\\n     *\\n     * - if the subscriber called it\\n     *   - AgreementTerminated callback to the publsiher:\\n     *      - agreementId is for the subscription\\n     * - if the publisher called it\\n     *   - AgreementTerminated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function deleteSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n    * @dev Claim pending distributions\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param subscriber The subscriber's address\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * The subscription should not be approved yet\\n    *\\n    * # App callbacks\\n    *\\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function claim(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n        external\\n        virtual\\n        returns(bytes memory newCtx);\\n    \\n    /**\\n      * @dev Index distribution claimed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param amount The pending amount claimed\\n      */\\n    event IndexDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint256 amount);\\n    \\n    /**\\n      * @dev Subscription distribution claimed event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param amount The pending amount claimed\\n      */\\n    event SubscriptionDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint256 amount);\\n\\n}\\n\",\"keccak256\":\"0x47948789bc2265e6228f70ddd9eb194be4e35b1c5ce598f5b5a01fcb48def27b\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/Definitions.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\n/**\\n * @title Super app definitions library\\n * @author Superfluid\\n */\\nlibrary SuperAppDefinitions {\\n\\n    /**************************************************************************\\n    / App manifest config word\\n    /**************************************************************************/\\n\\n    /*\\n     * App level is a way to allow the app to whitelist what other app it can\\n     * interact with (aka. composite app feature).\\n     *\\n     * For more details, refer to the technical paper of superfluid protocol.\\n     */\\n    uint256 constant internal APP_LEVEL_MASK = 0xFF;\\n\\n    // The app is at the final level, hence it doesn't want to interact with any other app\\n    uint256 constant internal APP_LEVEL_FINAL = 1 << 0;\\n\\n    // The app is at the second level, it may interact with other final level apps if whitelisted\\n    uint256 constant internal APP_LEVEL_SECOND = 1 << 1;\\n\\n    function getAppLevel(uint256 configWord) internal pure returns (uint8) {\\n        return uint8(configWord & APP_LEVEL_MASK);\\n    }\\n\\n    uint256 constant internal APP_JAIL_BIT = 1 << 15;\\n    function isAppJailed(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & SuperAppDefinitions.APP_JAIL_BIT) > 0;\\n    }\\n\\n    /**************************************************************************\\n    / Callback implementation bit masks\\n    /**************************************************************************/\\n    uint256 constant internal AGREEMENT_CALLBACK_NOOP_BITMASKS = 0xFF << 32;\\n    uint256 constant internal BEFORE_AGREEMENT_CREATED_NOOP = 1 << (32 + 0);\\n    uint256 constant internal AFTER_AGREEMENT_CREATED_NOOP = 1 << (32 + 1);\\n    uint256 constant internal BEFORE_AGREEMENT_UPDATED_NOOP = 1 << (32 + 2);\\n    uint256 constant internal AFTER_AGREEMENT_UPDATED_NOOP = 1 << (32 + 3);\\n    uint256 constant internal BEFORE_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 4);\\n    uint256 constant internal AFTER_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 5);\\n\\n    /**************************************************************************\\n    / App Jail Reasons\\n    /**************************************************************************/\\n\\n    uint256 constant internal APP_RULE_REGISTRATION_ONLY_IN_CONSTRUCTOR = 1;\\n    uint256 constant internal APP_RULE_NO_REGISTRATION_FOR_EOA = 2;\\n    uint256 constant internal APP_RULE_NO_REVERT_ON_TERMINATION_CALLBACK = 10;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_SENDER_ACCOUNT = 11;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_RECEIVER_ACCOUNT = 12;\\n    uint256 constant internal APP_RULE_CTX_IS_READONLY = 20;\\n    uint256 constant internal APP_RULE_CTX_IS_NOT_CLEAN = 21;\\n    uint256 constant internal APP_RULE_CTX_IS_MALFORMATED = 22;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_NOT_WHITELISTED = 30;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_JAILED = 31;\\n    uint256 constant internal APP_RULE_MAX_APP_LEVEL_REACHED = 40;\\n\\n    // Validate configWord cleaness for future compatibility, or else may introduce undefined future behavior\\n    function isConfigWordClean(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & ~(APP_LEVEL_MASK | APP_JAIL_BIT | AGREEMENT_CALLBACK_NOOP_BITMASKS)) == uint256(0);\\n    }\\n}\\n\\n/**\\n * @title Context definitions library\\n * @author Superfluid\\n */\\nlibrary ContextDefinitions {\\n\\n    /**************************************************************************\\n    / Call info\\n    /**************************************************************************/\\n\\n    // app level\\n    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;\\n\\n    // call type\\n    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;\\n    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;\\n\\n    function decodeCallInfo(uint256 callInfo)\\n        internal pure\\n        returns (uint8 appLevel, uint8 callType)\\n    {\\n        appLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);\\n        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n    function encodeCallInfo(uint8 appLevel, uint8 callType)\\n        internal pure\\n        returns (uint256 callInfo)\\n    {\\n        return uint256(appLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n}\\n\\n/**\\n * @title Flow Operator definitions library\\n  * @author Superfluid\\n */\\n library FlowOperatorDefinitions {\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_CREATE = uint8(1) << 0;\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_UPDATE = uint8(1) << 1;\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_DELETE = uint8(1) << 2;\\n    uint8 constant internal AUTHORIZE_FULL_CONTROL =\\n        AUTHORIZE_FLOW_OPERATOR_CREATE | AUTHORIZE_FLOW_OPERATOR_UPDATE | AUTHORIZE_FLOW_OPERATOR_DELETE;\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_CREATE = ~(uint8(1) << 0);\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_UPDATE = ~(uint8(1) << 1);\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_DELETE = ~(uint8(1) << 2);\\n\\n    function isPermissionsClean(uint8 permissions) internal pure returns (bool) {\\n        return (\\n            permissions & ~(AUTHORIZE_FLOW_OPERATOR_CREATE\\n                | AUTHORIZE_FLOW_OPERATOR_UPDATE\\n                | AUTHORIZE_FLOW_OPERATOR_DELETE)\\n            ) == uint8(0);\\n    }\\n }\\n\\n/**\\n * @title Batch operation library\\n * @author Superfluid\\n */\\nlibrary BatchOperation {\\n    /**\\n     * @dev ERC20.approve batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationApprove(\\n     *     abi.decode(data, (address spender, uint256 amount))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_APPROVE = 1;\\n    /**\\n     * @dev ERC20.transferFrom batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationTransferFrom(\\n     *     abi.decode(data, (address sender, address recipient, uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_TRANSFER_FROM = 2;\\n    /**\\n     * @dev SuperToken.upgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationUpgrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_UPGRADE = 1 + 100;\\n    /**\\n     * @dev SuperToken.downgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDowngrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_DOWNGRADE = 2 + 100;\\n    /**\\n     * @dev Superfluid.callAgreement batch operation type\\n     *\\n     * Call spec:\\n     * callAgreement(\\n     *     ISuperAgreement(target)),\\n     *     abi.decode(data, (bytes calldata, bytes userdata)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_AGREEMENT = 1 + 200;\\n    /**\\n     * @dev Superfluid.callAppAction batch operation type\\n     *\\n     * Call spec:\\n     * callAppAction(\\n     *     ISuperApp(target)),\\n     *     data\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_APP_ACTION = 2 + 200;\\n}\\n\\n/**\\n * @title Superfluid governance configs library\\n * @author Superfluid\\n */\\nlibrary SuperfluidGovernanceConfigs {\\n\\n    bytes32 constant internal SUPERFLUID_REWARD_ADDRESS_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.rewardAddress\\\");\\n    bytes32 constant internal CFAV1_PPP_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1.PPPConfiguration\\\");\\n    bytes32 constant internal SUPERTOKEN_MINIMUM_DEPOSIT_KEY = \\n        keccak256(\\\"org.superfluid-finance.superfluid.superTokenMinimumDeposit\\\");\\n\\n    function getTrustedForwarderConfigKey(address forwarder) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.trustedForwarder\\\",\\n            forwarder));\\n    }\\n\\n    function getAppRegistrationConfigKey(address deployer, string memory registrationKey) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.registrationKey\\\",\\n            deployer,\\n            registrationKey));\\n    }\\n\\n    function getAppFactoryConfigKey(address factory) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.factory\\\",\\n            factory));\\n    }\\n\\n    function decodePPPConfig(uint256 pppConfig) internal pure returns (uint256 liquidationPeriod, uint256 patricianPeriod) {\\n        liquidationPeriod = (pppConfig >> 32) & type(uint32).max;\\n        patricianPeriod = pppConfig & type(uint32).max;\\n    }\\n}\\n\",\"keccak256\":\"0x199095781e4221b6015d859558da09977f79199f38d342ab4899c2cecdf8cec1\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperAgreement.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Super agreement interface\\n * @author Superfluid\\n */\\ninterface ISuperAgreement {\\n\\n    /**\\n     * @dev Get the type of the agreement class\\n     */\\n    function agreementType() external view returns (bytes32);\\n\\n    /**\\n     * @dev Calculate the real-time balance for the account of this agreement class\\n     * @param account Account the state belongs to\\n     * @param time Time used for the calculation\\n     * @return dynamicBalance Dynamic balance portion of real-time balance of this agreement\\n     * @return deposit Account deposit amount of this agreement\\n     * @return owedDeposit Account owed deposit amount of this agreement\\n     */\\n    function realtimeBalanceOf(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 time\\n    )\\n        external\\n        view\\n        returns (\\n            int256 dynamicBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n}\\n\",\"keccak256\":\"0xc3a6a907245116bcecc70fe4b207454012e8ce4fa190228fb8bbe39e0b1bc5cf\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\n/**\\n * @title SuperApp interface\\n * @author Superfluid\\n * @dev Be aware of the app being jailed, when the word permitted is used.\\n *\\n */\\ninterface ISuperApp {\\n\\n    /**\\n     * @dev Callback before a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * NOTE:\\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n     * @dev Callback after a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param cbdata The data returned from the before-hook callback.\\n     * @param ctx The context data.\\n     * @return newCtx The current context of the transaction.\\n     *\\n     * NOTE:\\n     * - State changes is permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function afterAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Callback before a new agreement is updated.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * NOTE:\\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n\\n    /**\\n    * @dev Callback after a new agreement is updated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * NOTE:\\n    * - State changes is permitted.\\n    * - Only revert with a \\\"reason\\\" is permitted.\\n    */\\n    function afterAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n    * @dev Callback before a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param ctx The context data.\\n    * @return cbdata A free format in memory data the app can use to pass\\n    *          arbitary information to the after-hook callback.\\n    *\\n    * NOTE:\\n    * - It will be invoked with `staticcall`, no state changes are permitted.\\n    * - Revert is not permitted.\\n    */\\n    function beforeAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n    * @dev Callback after a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * NOTE:\\n    * - State changes is permitted.\\n    * - Revert is not permitted.\\n    */\\n    function afterAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n}\\n\",\"keccak256\":\"0x57f4203168992c940eb6b8c7cc75f854cb36a1f9323b3f39ddc5e4fbe819c043\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Super token (Superfluid Token + ERC20 + ERC777) interface\\n * @author Superfluid\\n */\\ninterface ISuperToken is ISuperfluidToken, TokenInfo, IERC20, IERC777 {\\n\\n    /**\\n     * @dev Initialize the contract\\n     */\\n    function initialize(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        string calldata n,\\n        string calldata s\\n    ) external;\\n\\n    /**************************************************************************\\n    * TokenInfo & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: SuperToken always uses 18 decimals.\\n     *\\n     * Note: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view override(TokenInfo) returns (uint8);\\n\\n    /**************************************************************************\\n    * ERC20 & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address account) external view override(IERC777, IERC20) returns(uint256 balance);\\n\\n    /**************************************************************************\\n    * ERC20\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     *         allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     *         zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external override(IERC20) view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     *         allowance mechanism. `amount` is then deducted from the caller's\\n     *         allowance.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**************************************************************************\\n    * ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     *         means all token operations (creation, movement and destruction) must have\\n     *         amounts that are a multiple of this number.\\n     *\\n     * For super token contracts, this value is 1 always\\n     */\\n    function granularity() external view override(IERC777) returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @dev If send or receive hooks are registered for the caller and `recipient`,\\n     *      the corresponding functions will be called with `data` and empty\\n     *      `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external override(IERC777) view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external override(IERC777) view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**************************************************************************\\n     * SuperToken custom token functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Mint new tokens for the account\\n     *\\n     * Modifiers:\\n     *  - onlySelf\\n     */\\n    function selfMint(\\n        address account,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n   /**\\n    * @dev Burn existing tokens for the account\\n    *\\n    * Modifiers:\\n    *  - onlySelf\\n    */\\n   function selfBurn(\\n       address account,\\n       uint256 amount,\\n       bytes memory userData\\n   ) external;\\n\\n   /**\\n    * @dev Transfer `amount` tokens from the `sender` to `recipient`.\\n    * If `spender` isn't the same as `sender`, checks if `spender` has allowance to\\n    * spend tokens of `sender`.\\n    *\\n    * Modifiers:\\n    *  - onlySelf\\n    */\\n   function selfTransferFrom(\\n        address sender,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n   ) external;\\n\\n   /**\\n    * @dev Give `spender`, `amount` allowance to spend the tokens of\\n    * `account`.\\n    *\\n    * Modifiers:\\n    *  - onlySelf\\n    */\\n   function selfApproveFor(\\n        address account,\\n        address spender,\\n        uint256 amount\\n   ) external;\\n\\n    /**************************************************************************\\n     * SuperToken extra functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Transfer all available balance from `msg.sender` to `recipient`\\n     */\\n    function transferAll(address recipient) external;\\n\\n    /**************************************************************************\\n     * ERC20 wrapping\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Return the underlying token contract\\n     * @return tokenAddr Underlying token address\\n     */\\n    function getUnderlyingToken() external view returns(address tokenAddr);\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken.\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     *\\n     * NOTE: It will use \\u00b4transferFrom\\u00b4 to get tokens. Before calling this\\n     * function you should \\u00b4approve\\u00b4 this contract\\n     */\\n    function upgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken and transfer immediately\\n     * @param to The account to received upgraded tokens\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     * @param data User data for the TokensRecipient callback\\n     *\\n     * NOTE: It will use \\u00b4transferFrom\\u00b4 to get tokens. Before calling this\\n     * function you should \\u00b4approve\\u00b4 this contract\\n     */\\n    function upgradeTo(address to, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Token upgrade event\\n     * @param account Account where tokens are upgraded to\\n     * @param amount Amount of tokens upgraded (in 18 decimals)\\n     */\\n    event TokenUpgraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20.\\n     * @dev It will call transfer to send tokens\\n     * @param amount Number of tokens to be downgraded\\n     */\\n    function downgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Token downgrade event\\n     * @param account Account whose tokens are upgraded\\n     * @param amount Amount of tokens downgraded\\n     */\\n    event TokenDowngraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**************************************************************************\\n    * Batch Operations\\n    *************************************************************************/\\n\\n    /**\\n    * @dev Perform ERC20 approve by host contract.\\n    * @param account The account owner to be approved.\\n    * @param spender The spender of account owner's funds.\\n    * @param amount Number of tokens to be approved.\\n    *\\n    * Modifiers:\\n    *  - onlyHost\\n    */\\n    function operationApprove(\\n        address account,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC20 transfer from by host contract.\\n    * @param account The account to spend sender's funds.\\n    * @param spender  The account where the funds is sent from.\\n    * @param recipient The recipient of thefunds.\\n    * @param amount Number of tokens to be transferred.\\n    *\\n    * Modifiers:\\n    *  - onlyHost\\n    */\\n    function operationTransferFrom(\\n        address account,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Upgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be upgraded (in 18 decimals)\\n    *\\n    * Modifiers:\\n    *  - onlyHost\\n    */\\n    function operationUpgrade(address account, uint256 amount) external;\\n\\n    /**\\n    * @dev Downgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be downgraded (in 18 decimals)\\n    *\\n    * Modifiers:\\n    *  - onlyHost\\n    */\\n    function operationDowngrade(address account, uint256 amount) external;\\n\\n\\n    /**************************************************************************\\n    * Function modifiers for access control and parameter validations\\n    *\\n    * While they cannot be explicitly stated in function definitions, they are\\n    * listed in function definition comments instead for clarity.\\n    *\\n    * NOTE: solidity-coverage not supporting it\\n    *************************************************************************/\\n\\n    /// @dev The msg.sender must be the contract itself\\n    //modifier onlySelf() virtual\\n\\n}\\n\",\"keccak256\":\"0x3cb0b7216007b942f7611d7b3d983c0df9408fdd4fd6b799c33fc9033e0abf8b\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperTokenFactory.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\nimport {\\n    IERC20,\\n    ERC20WithTokenInfo\\n} from \\\"../tokens/ERC20WithTokenInfo.sol\\\";\\n\\n/**\\n * @title Super token factory interface\\n * @author Superfluid\\n */\\ninterface ISuperTokenFactory {\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /// @dev Initialize the contract\\n    function initialize() external;\\n\\n    /**\\n     * @dev Get the current super token logic used by the factory\\n     */\\n    function getSuperTokenLogic() external view returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Upgradability modes\\n     */\\n    enum Upgradability {\\n        /// Non upgradable super token, `host.updateSuperTokenLogic` will revert\\n        NON_UPGRADABLE,\\n        /// Upgradable through `host.updateSuperTokenLogic` operation\\n        SEMI_UPGRADABLE,\\n        /// Always using the latest super token logic\\n        FULL_UPGRADABE\\n    }\\n\\n    /**\\n     * @dev Create new super token wrapper for the underlying ERC20 token\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param underlyingDecimals Underlying token decimals\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     */\\n    function createERC20Wrapper(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Create new super token wrapper for the underlying ERC20 token with extra token info\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     *\\n     * NOTE:\\n     * - It assumes token provide the .decimals() function\\n     */\\n    function createERC20Wrapper(\\n        ERC20WithTokenInfo underlyingToken,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    function initializeCustomSuperToken(\\n        address customSuperTokenProxy\\n    )\\n        external;\\n\\n    /**\\n      * @dev Super token logic created event\\n      * @param tokenLogic Token logic address\\n      */\\n    event SuperTokenLogicCreated(ISuperToken indexed tokenLogic);\\n\\n    /**\\n      * @dev Super token created event\\n      * @param token Newly created super token address\\n      */\\n    event SuperTokenCreated(ISuperToken indexed token);\\n\\n    /**\\n      * @dev Custom super token created event\\n      * @param token Newly created custom super token address\\n      */\\n    event CustomSuperTokenCreated(ISuperToken indexed token);\\n\\n}\\n\",\"keccak256\":\"0x68a466c978557e47bd7385b1d7d78f1c8fb07462a870efc5a791008e33a4f535\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperfluidGovernance } from \\\"./ISuperfluidGovernance.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperTokenFactory } from \\\"./ISuperTokenFactory.sol\\\";\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { ISuperApp } from \\\"./ISuperApp.sol\\\";\\nimport {\\n    BatchOperation,\\n    ContextDefinitions,\\n    FlowOperatorDefinitions,\\n    SuperAppDefinitions,\\n    SuperfluidGovernanceConfigs\\n} from \\\"./Definitions.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\n\\n/**\\n * @title Host interface\\n * @author Superfluid\\n * NOTE:\\n * This is the central contract of the system where super agreement, super app\\n * and super token features are connected.\\n *\\n * The Superfluid host contract is also the entry point for the protocol users,\\n * where batch call and meta transaction are provided for UX improvements.\\n *\\n */\\ninterface ISuperfluid {\\n\\n    /**************************************************************************\\n     * Time\\n     *\\n     * > The Oracle: You have the sight now, Neo. You are looking at the world without time.\\n     * > Neo: Then why can't I see what happens to her?\\n     * > The Oracle: We can never see past the choices we don't understand.\\n     * >       - The Oracle and Neo conversing about the future of Trinity and the effects of Neo's choices\\n     *************************************************************************/\\n\\n    function getNow() external view returns (uint256);\\n\\n    /**************************************************************************\\n     * Governance\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get the current governance address of the Superfluid host\\n     */\\n    function getGovernance() external view returns(ISuperfluidGovernance governance);\\n\\n    /**\\n     * @dev Replace the current governance with a new one\\n     */\\n    function replaceGovernance(ISuperfluidGovernance newGov) external;\\n    /**\\n     * @dev Governance replaced event\\n     * @param oldGov Address of the old governance contract\\n     * @param newGov Address of the new governance contract\\n     */\\n    event GovernanceReplaced(ISuperfluidGovernance oldGov, ISuperfluidGovernance newGov);\\n\\n    /**************************************************************************\\n     * Agreement Whitelisting\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Register a new agreement class to the system\\n     * @param agreementClassLogic Initial agreement class code\\n     *\\n     * Modifiers:\\n     *  - onlyGovernance\\n     */\\n    function registerAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class registered event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type registered\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassRegistered(bytes32 agreementType, address code);\\n\\n    /**\\n    * @dev Update code of an agreement class\\n    * @param agreementClassLogic New code for the agreement class\\n    *\\n    * Modifiers:\\n    *  - onlyGovernance\\n    */\\n    function updateAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class updated event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type updated\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassUpdated(bytes32 agreementType, address code);\\n\\n    /**\\n    * @notice Check if the agreement type is whitelisted\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function isAgreementTypeListed(bytes32 agreementType) external view returns(bool yes);\\n\\n    /**\\n    * @dev Check if the agreement class is whitelisted\\n    */\\n    function isAgreementClassListed(ISuperAgreement agreementClass) external view returns(bool yes);\\n\\n    /**\\n    * @notice Get agreement class\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function getAgreementClass(bytes32 agreementType) external view returns(ISuperAgreement agreementClass);\\n\\n    /**\\n    * @dev Map list of the agreement classes using a bitmap\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function mapAgreementClasses(uint256 bitmap)\\n        external view\\n        returns (ISuperAgreement[] memory agreementClasses);\\n\\n    /**\\n    * @notice Create a new bitmask by adding a agreement class to it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function addToAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**\\n    * @notice Create a new bitmask by removing a agreement class from it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function removeFromAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**************************************************************************\\n    * Super Token Factory\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get the super token factory\\n     * @return factory The factory\\n     */\\n    function getSuperTokenFactory() external view returns (ISuperTokenFactory factory);\\n\\n    /**\\n     * @dev Get the super token factory logic (applicable to upgradable deployment)\\n     * @return logic The factory logic\\n     */\\n    function getSuperTokenFactoryLogic() external view returns (address logic);\\n\\n    /**\\n     * @dev Update super token factory\\n     * @param newFactory New factory logic\\n     */\\n    function updateSuperTokenFactory(ISuperTokenFactory newFactory) external;\\n    /**\\n     * @dev SuperToken factory updated event\\n     * @param newFactory Address of the new factory\\n     */\\n    event SuperTokenFactoryUpdated(ISuperTokenFactory newFactory);\\n\\n    /**\\n     * @notice Update the super token logic to the latest\\n     * @dev Refer to ISuperTokenFactory.Upgradability for expected behaviours\\n     */\\n    function updateSuperTokenLogic(ISuperToken token) external;\\n    /**\\n     * @dev SuperToken logic updated event\\n     * @param code Address of the new SuperToken logic\\n     */\\n    event SuperTokenLogicUpdated(ISuperToken indexed token, address code);\\n\\n    /**************************************************************************\\n     * App Registry\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Message sender declares it as a super app\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     * `SuperAppDefinitions`\\n     */\\n    function registerApp(uint256 configWord) external;\\n    /**\\n     * @dev App registered event\\n     * @param app Address of jailed app\\n     */\\n    event AppRegistered(ISuperApp indexed app);\\n\\n    /**\\n     * @dev Message sender declares it as a super app, using a registration key\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     * `SuperAppDefinitions`\\n     * @param registrationKey The registration key issued by the governance\\n     */\\n    function registerAppWithKey(uint256 configWord, string calldata registrationKey) external;\\n\\n    /**\\n     * @dev Message sender declares app as a super app\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     * `SuperAppDefinitions`\\n     * NOTE: only factory contracts authorized by governance can register super apps\\n     */\\n    function registerAppByFactory(ISuperApp app, uint256 configWord) external;\\n\\n    /**\\n     * @dev Query if the app is registered\\n     * @param app Super app address\\n     */\\n    function isApp(ISuperApp app) external view returns(bool);\\n\\n    /**\\n     * @dev Query app level\\n     * @param app Super app address\\n     */\\n    function getAppLevel(ISuperApp app) external view returns(uint8 appLevel);\\n\\n    /**\\n     * @dev Get the manifest of the super app\\n     * @param app Super app address\\n     */\\n    function getAppManifest(\\n        ISuperApp app\\n    )\\n        external view\\n        returns (\\n            bool isSuperApp,\\n            bool isJailed,\\n            uint256 noopMask\\n        );\\n\\n    /**\\n     * @dev Query if the app has been jailed\\n     * @param app Super app address\\n     */\\n    function isAppJailed(ISuperApp app) external view returns (bool isJail);\\n\\n    /**\\n     * @dev Whitelist the target app for app composition for the source app (msg.sender)\\n     * @param targetApp The target super app address\\n     */\\n    function allowCompositeApp(ISuperApp targetApp) external;\\n\\n    /**\\n     * @dev Query if source app is allowed to call the target app as downstream app\\n     * @param app Super app address\\n     * @param targetApp The target super app address\\n     */\\n    function isCompositeAppAllowed(\\n        ISuperApp app,\\n        ISuperApp targetApp\\n    )\\n        external view\\n        returns (bool isAppAllowed);\\n\\n    /**************************************************************************\\n     * Agreement Framework\\n     *\\n     * Agreements use these function to trigger super app callbacks, updates\\n     * app allowance and charge gas fees.\\n     *\\n     * These functions can only be called by registered agreements.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev (For agreements) StaticCall the app before callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return cbdata            Data returned from the callback.\\n     */\\n    function callAppBeforeCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory cbdata);\\n\\n    /**\\n     * @dev (For agreements) Call the app after callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return newCtx\\n     */\\n    function callAppAfterCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Create a new callback stack\\n     * @param  ctx                     The current ctx, it will be validated.\\n     * @param  app                     The super app.\\n     * @param  appAllowanceGranted     App allowance granted so far.\\n     * @param  appAllowanceUsed        App allowance used so far.\\n     * @return newCtx\\n     */\\n    function appCallbackPush(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 appAllowanceGranted,\\n        int256 appAllowanceUsed,\\n        ISuperfluidToken appAllowanceToken\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Pop from the current app callback stack\\n     * @param  ctx                     The ctx that was pushed before the callback stack.\\n     * @param  appAllowanceUsedDelta   App allowance used by the app.\\n     * @return newCtx\\n     *\\n     * [SECURITY] NOTE:\\n     * - Here we cannot do assertValidCtx(ctx), since we do not really save the stack in memory.\\n     * - Hence there is still implicit trust that the agreement handles the callback push/pop pair correctly.\\n     */\\n    function appCallbackPop(\\n        bytes calldata ctx,\\n        int256 appAllowanceUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Use app allowance.\\n     * @param  ctx                      The current ctx, it will be validated.\\n     * @param  appAllowanceWantedMore   See app allowance for more details.\\n     * @param  appAllowanceUsedDelta    See app allowance for more details.\\n     * @return newCtx\\n     */\\n    function ctxUseAllowance(\\n        bytes calldata ctx,\\n        uint256 appAllowanceWantedMore,\\n        int256 appAllowanceUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Jail the app.\\n     * @param  app                     The super app.\\n     * @param  reason                  Jail reason code.\\n     * @return newCtx\\n     */\\n    function jailApp(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 reason\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Jail event for the app\\n     * @param app Address of jailed app\\n     * @param reason Reason the app is jailed (see Definitions.sol for the full list)\\n     */\\n    event Jail(ISuperApp indexed app, uint256 reason);\\n\\n    /**************************************************************************\\n     * Contextless Call Proxies\\n     *\\n     * NOTE: For EOAs or non-app contracts, they are the entry points for interacting\\n     * with agreements or apps.\\n     *\\n     * NOTE: The contextual call data should be generated using\\n     * abi.encodeWithSelector. The context parameter should be set to \\\"0x\\\",\\n     * an empty bytes array as a placeholder to be replaced by the host\\n     * contract.\\n     *************************************************************************/\\n\\n     /**\\n      * @dev Call agreement function\\n      * @param agreementClass The agreement address you are calling\\n      * @param callData The contextual call data with placeholder ctx\\n      * @param userData Extra user data being sent to the super app callbacks\\n      */\\n     function callAgreement(\\n         ISuperAgreement agreementClass,\\n         bytes calldata callData,\\n         bytes calldata userData\\n     )\\n        external\\n        //cleanCtx\\n        //isAgreement(agreementClass)\\n        returns(bytes memory returnedData);\\n\\n    /**\\n     * @notice Call app action\\n     * @dev Main use case is calling app action in a batch call via the host\\n     * @param callData The contextual call data\\n     *\\n     * NOTE: See \\\"Contextless Call Proxies\\\" above for more about contextual call data.\\n     */\\n    function callAppAction(\\n        ISuperApp app,\\n        bytes calldata callData\\n    )\\n        external\\n        //cleanCtx\\n        //isAppActive(app)\\n        //isValidAppAction(callData)\\n        returns(bytes memory returnedData);\\n\\n    /**************************************************************************\\n     * Contextual Call Proxies and Context Utilities\\n     *\\n     * For apps, they must use context they receive to interact with\\n     * agreements or apps.\\n     *\\n     * The context changes must be saved and returned by the apps in their\\n     * callbacks always, any modification to the context will be detected and\\n     * the violating app will be jailed.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Context Struct\\n     *\\n     * NOTE on backward compatibility:\\n     * - Non-dynamic fields are padded to 32bytes and packed\\n     * - Dynamic fields are referenced through a 32bytes offset to their \\\"parents\\\" field (or root)\\n     * - The order of the fields hence should not be rearranged in order to be backward compatible:\\n     *    - non-dynamic fields will be parsed at the same memory location,\\n     *    - and dynamic fields will simply have a greater offset than it was.\\n     */\\n    struct Context {\\n        //\\n        // Call context\\n        //\\n        // callback level\\n        uint8 appLevel;\\n        // type of call\\n        uint8 callType;\\n        // the system timestamp\\n        uint256 timestamp;\\n        // The intended message sender for the call\\n        address msgSender;\\n\\n        //\\n        // Callback context\\n        //\\n        // For callbacks it is used to know which agreement function selector is called\\n        bytes4 agreementSelector;\\n        // User provided data for app callbacks\\n        bytes userData;\\n\\n        //\\n        // App context\\n        //\\n        // app allowance granted\\n        uint256 appAllowanceGranted;\\n        // app allowance wanted by the app callback\\n        uint256 appAllowanceWanted;\\n        // app allowance used, allowing negative values over a callback session\\n        int256 appAllowanceUsed;\\n        // app address\\n        address appAddress;\\n        // app allowance in super token\\n        ISuperfluidToken appAllowanceToken;\\n    }\\n\\n    function callAgreementWithContext(\\n        ISuperAgreement agreementClass,\\n        bytes calldata callData,\\n        bytes calldata userData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // onlyAgreement(agreementClass)\\n        returns (bytes memory newCtx, bytes memory returnedData);\\n\\n    function callAppActionWithContext(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // isAppActive(app)\\n        returns (bytes memory newCtx);\\n\\n    function decodeCtx(bytes calldata ctx)\\n        external pure\\n        returns (Context memory context);\\n\\n    function isCtxValid(bytes calldata ctx) external view returns (bool);\\n\\n    /**************************************************************************\\n    * Batch call\\n    **************************************************************************/\\n    /**\\n     * @dev Batch operation data\\n     */\\n    struct Operation {\\n        // Operation type. Defined in BatchOperation (Definitions.sol)\\n        uint32 operationType;\\n        // Operation target\\n        address target;\\n        // Data specific to the operation\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Batch call function\\n     * @param operations Array of batch operations\\n     */\\n    function batchCall(Operation[] memory operations) external;\\n\\n    /**\\n     * @dev Batch call function for trusted forwarders (EIP-2771)\\n     * @param operations Array of batch operations\\n     */\\n    function forwardBatchCall(Operation[] memory operations) external;\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * TODO: turning these off because solidity-coverage doesn't like it\\n     *************************************************************************/\\n\\n     /* /// @dev The current superfluid context is clean.\\n     modifier cleanCtx() virtual;\\n\\n     /// @dev Require the ctx being valid.\\n     modifier requireValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev Assert the ctx being valid.\\n     modifier assertValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev The agreement is a listed agreement.\\n     modifier isAgreement(ISuperAgreement agreementClass) virtual;\\n\\n     // onlyGovernance\\n\\n     /// @dev The msg.sender must be a listed agreement.\\n     modifier onlyAgreement() virtual;\\n\\n     /// @dev The app is registered and not jailed.\\n     modifier isAppActive(ISuperApp app) virtual; */\\n}\\n\",\"keccak256\":\"0xc1007d1082050b532947d27973bf996da2b0df9bdf6ed4d4fcaaa3ff2354262c\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidGovernance.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperfluidToken  } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\n\\n\\n/**\\n * @title Superfluid governance interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidGovernance {\\n\\n    /**\\n     * @dev Replace the current governance with a new governance\\n     */\\n    function replaceGovernance(\\n        ISuperfluid host,\\n        address newGov) external;\\n\\n    /**\\n     * @dev Register a new agreement class\\n     */\\n    function registerAgreementClass(\\n        ISuperfluid host,\\n        address agreementClass) external;\\n\\n    /**\\n     * @dev Update logics of the contracts\\n     *\\n     * NOTE:\\n     * - Because they might have inter-dependencies, it is good to have one single function to update them all\\n     */\\n    function updateContracts(\\n        ISuperfluid host,\\n        address hostNewLogic,\\n        address[] calldata agreementClassNewLogics,\\n        address superTokenFactoryNewLogic\\n    ) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the latest that is managed by the super token factory\\n     */\\n    function batchUpdateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken[] calldata tokens) external;\\n    \\n    /**\\n     * @dev Set configuration as address value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        address value\\n    ) external;\\n    \\n    /**\\n     * @dev Set configuration as uint256 value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        uint256 value\\n    ) external;\\n\\n    /**\\n     * @dev Clear configuration\\n     */\\n    function clearConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key\\n    ) external;\\n\\n    /**\\n     * @dev Get configuration as address value\\n     */\\n    function getConfigAsAddress(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (address value);\\n\\n    /**\\n     * @dev Get configuration as uint256 value\\n     */\\n    function getConfigAsUint256(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (uint256 value);\\n\\n}\\n\",\"keccak256\":\"0x2166f766b7f61f9bb1376b0948efa0d0c0046b93dc301e51ce495203b145189b\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\n\\n\\n/**\\n * @title Superfluid token interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidToken {\\n\\n    /**************************************************************************\\n     * Basic information\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /**\\n     * @dev Encoded liquidation type data mainly used for handling stack to deep errors\\n     *\\n     * Note:\\n     * - version: 1\\n     * - liquidationType key:\\n     *    - 0 = reward account receives reward (PIC period)\\n     *    - 1 = liquidator account receives reward (Pleb period)\\n     *    - 2 = liquidator account receives reward (Pirate period/bailout)\\n     */\\n    struct LiquidationTypeData {\\n        uint256 version;\\n        uint8 liquidationType;\\n    }\\n\\n    /**************************************************************************\\n     * Real-time balance functions\\n     *************************************************************************/\\n\\n    /**\\n    * @dev Calculate the real balance of a user, taking in consideration all agreements of the account\\n    * @param account for the query\\n    * @param timestamp Time of balance\\n    * @return availableBalance Real-time balance\\n    * @return deposit Account deposit\\n    * @return owedDeposit Account owed Deposit\\n    */\\n    function realtimeBalanceOf(\\n       address account,\\n       uint256 timestamp\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @notice Calculate the realtime balance given the current host.getNow() value\\n     * @dev realtimeBalanceOf with timestamp equals to block timestamp\\n     * @param account for the query\\n     * @return availableBalance Real-time balance\\n     * @return deposit Account deposit\\n     * @return owedDeposit Account owed Deposit\\n     */\\n    function realtimeBalanceOfNow(\\n       address account\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit,\\n            uint256 timestamp);\\n\\n    /**\\n    * @notice Check if account is critical\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @param timestamp The time we'd like to check if the account is critical (should use future)\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCritical(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n    * @notice Check if account is critical now (current host.getNow())\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCriticalNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n     * @notice Check if account is solvent\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @param timestamp The time we'd like to check if the account is solvent (should use future)\\n     * @return isSolvent\\n     */\\n    function isAccountSolvent(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n     * @notice Check if account is solvent now\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @return isSolvent\\n     */\\n    function isAccountSolventNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n    * @notice Get a list of agreements that is active for the account\\n    * @dev An active agreement is one that has state for the account\\n    * @param account Account to query\\n    * @return activeAgreements List of accounts that have non-zero states for the account\\n    */\\n    function getAccountActiveAgreements(address account)\\n       external view\\n       returns(ISuperAgreement[] memory activeAgreements);\\n\\n\\n   /**************************************************************************\\n    * Super Agreement hosting functions\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function createAgreement(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement created event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementCreated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Get data of the agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @return data Data of the agreement\\n     */\\n    function getAgreementData(\\n        address agreementClass,\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external view\\n        returns(bytes32[] memory data);\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function updateAgreementData(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementUpdated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Close the agreement\\n     * @param id Agreement ID\\n     */\\n    function terminateAgreement(\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external;\\n    /**\\n     * @dev Agreement terminated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     */\\n    event AgreementTerminated(\\n        address indexed agreementClass,\\n        bytes32 id\\n    );\\n\\n    /**\\n     * @dev Update agreement state slot\\n     * @param account Account to be updated\\n     *\\n     * NOTE\\n     * - To clear the storage out, provide zero-ed array of intended length\\n     */\\n    function updateAgreementStateSlot(\\n        address account,\\n        uint256 slotId,\\n        bytes32[] calldata slotData\\n    )\\n        external;\\n    /**\\n     * @dev Agreement account state updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account updated\\n     * @param slotId slot id of the agreement state\\n     */\\n    event AgreementStateUpdated(\\n        address indexed agreementClass,\\n        address indexed account,\\n        uint256 slotId\\n    );\\n\\n    /**\\n     * @dev Get data of the slot of the state of an agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account to query\\n     * @param slotId slot id of the state\\n     * @param dataLength length of the state data\\n     */\\n    function getAgreementStateSlot(\\n        address agreementClass,\\n        address account,\\n        uint256 slotId,\\n        uint dataLength\\n    )\\n        external view\\n        returns (bytes32[] memory slotData);\\n\\n    /**\\n     * @notice Settle balance from an account by the agreement\\n     * @dev The agreement needs to make sure that the balance delta is balanced afterwards\\n     * @param account Account to query.\\n     * @param delta Amount of balance delta to be settled\\n     *\\n     * Modifiers:\\n     *  - onlyAgreement\\n     */\\n    function settleBalance(\\n        address account,\\n        int256 delta\\n    )\\n        external;\\n\\n    /**\\n     * @dev Make liquidation payouts (v2)\\n     * @param id Agreement ID\\n     * @param liquidationTypeData Data regarding the version of the liquidation schema and the type\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param useDefaultRewardAccount Whether or not the default reward account receives the rewardAmount\\n     * @param targetAccount Account of the stream sender\\n     * @param rewardAmount The amount the reward recepient account will receive\\n     * @param targetAccountBalanceDelta The amount the sender account balance should change by\\n     *\\n     * - If a bailout is required (bailoutAmount > 0)\\n     *   - the actual reward (single deposit) goes to the executor,\\n     *   - while the reward account becomes the bailout account\\n     *   - total bailout include: bailout amount + reward amount\\n     *   - the targetAccount will be bailed out\\n     * - If a bailout is not required\\n     *   - the targetAccount will pay the rewardAmount\\n     *   - the liquidator (reward account in PIC period) will receive the rewardAmount\\n     *\\n     * Modifiers:\\n     *  - onlyAgreement\\n     */\\n    function makeLiquidationPayoutsV2\\n    (\\n        bytes32 id,\\n        bytes memory liquidationTypeData,\\n        address liquidatorAccount,\\n        bool useDefaultRewardAccount,\\n        address targetAccount,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta\\n    ) external;\\n    /**\\n     * @dev Agreement liquidation event v2 (including agent account)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param targetAccount Account of the stream sender\\n     * @param rewardAccount Account that collects the reward or bails out insolvent accounts\\n     * @param rewardAmount The amount the reward recipient account balance should change by\\n     * @param targetAccountBalanceDelta The amount the sender account balance should change by\\n     * @param liquidationTypeData The encoded liquidation type data including the version (how to decode)\\n     *\\n     * NOTE:\\n     * Reward account rule:\\n     * - if the agreement is liquidated during the PIC period\\n     *   - the rewardAccount will get the rewardAmount (remaining deposit), regardless of the liquidatorAccount\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the agreement is liquidated after the PIC period AND the targetAccount is solvent\\n     *   - the liquidatorAccount will get the rewardAmount (remaining deposit)\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the targetAccount is insolvent\\n     *   - the liquidatorAccount will get the rewardAmount (single deposit)\\n     *   - the rewardAccount will pay for both the rewardAmount and bailoutAmount\\n     *   - the targetAccount will receive the bailoutAmount\\n     */\\n    event AgreementLiquidatedV2(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed liquidatorAccount,\\n        address indexed targetAccount,\\n        address rewardAccount,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta,\\n        bytes liquidationTypeData\\n    );\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * NOTE: solidity-coverage not supporting it\\n     *************************************************************************/\\n\\n     /// @dev The msg.sender must be host contract\\n     //modifier onlyHost() virtual;\\n\\n    /// @dev The msg.sender must be a listed agreement.\\n    //modifier onlyAgreement() virtual;\\n\\n    /**************************************************************************\\n     * DEPRECATED\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param rewardAccount Account that collect the reward\\n     * @param rewardAmount Amount of liquidation reward\\n     *\\n     * NOTE:\\n     *\\n     * [DEPRECATED] Use AgreementLiquidatedV2 instead\\n     */\\n    event AgreementLiquidated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed rewardAccount,\\n        uint256 rewardAmount\\n    );\\n\\n    /**\\n     * @dev System bailout occurred (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param bailoutAccount Account that bailout the penalty account\\n     * @param bailoutAmount Amount of account bailout\\n     *\\n     * NOTE:\\n     *\\n     * [DEPRECATED] Use AgreementLiquidatedV2 instead\\n     */\\n    event Bailout(\\n        address indexed bailoutAccount,\\n        uint256 bailoutAmount\\n    );\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedV2)\\n     * @param liquidatorAccount Account of the agent that performed the liquidation.\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param bondAccount Account that collect the reward or bailout accounts\\n     * @param rewardAmount Amount of liquidation reward\\n     * @param bailoutAmount Amount of liquidation bailouot\\n     *\\n     * NOTE:\\n     * Reward account rule:\\n     * - if bailout is equal to 0, then\\n     *   - the bondAccount will get the rewardAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount.\\n     * - if bailout is larger than 0, then\\n     *   - the liquidatorAccount will get the rewardAmouont,\\n     *   - the bondAccount will pay for both the rewardAmount and bailoutAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount while get the bailoutAmount.\\n     */\\n    event AgreementLiquidatedBy(\\n        address liquidatorAccount,\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed bondAccount,\\n        uint256 rewardAmount,\\n        uint256 bailoutAmount\\n    );\\n}\\n\",\"keccak256\":\"0x9189eaba9e856cc4932ea29eeaf4e89a09448dde13860591691ec122856fdc75\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ERC20WithTokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenInfo } from \\\"./TokenInfo.sol\\\";\\n\\n/**\\n * @title ERC20 token with token info interface\\n * @author Superfluid\\n * @dev Using abstract contract instead of interfaces because old solidity\\n *      does not support interface inheriting other interfaces\\n * solhint-disable-next-line no-empty-blocks\\n *\\n */\\n// solhint-disable-next-line no-empty-blocks\\nabstract contract ERC20WithTokenInfo is IERC20, TokenInfo {}\\n\",\"keccak256\":\"0x66708dae3fcd06e6fc0a46f2959fc2d1e6b9361f28598337339d26af8eb8c0f9\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/TokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\n/**\\n * @title ERC20 token info interface\\n * @author Superfluid\\n * @dev ERC20 standard interface does not specify these functions, but\\n *      often the token implementations have them.\\n */\\ninterface TokenInfo {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x70e573644a0ff271c0ccef526809e9d9ab4950ec58755ca84e833cde3b8f3df0\",\"license\":\"AGPLv3\"},\"contracts/Common/IERC20Mod.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * Modified IERC20 interface.\\n * @dev This interface is used to access decimals of an ERC20 token.\\n */\\ninterface IERC20Mod is IERC20 {\\n    function decimals() external view returns (uint8);\\n}\",\"keccak256\":\"0x25f6b0d8f24af8e0dfb2c7f83a54a594f4351b7155492d61ac0d174bf97bfcab\",\"license\":\"Unlicensed\"},\"contracts/Common/SFHelper.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.10;\\n\\nimport { ISuperfluid, ISuperToken, ISuperAgreement, ISuperApp } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport { IConstantFlowAgreementV1 } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\\\";\\nimport { IInstantDistributionAgreementV1 } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @title Superfluid helper library.\\n * @author rashtrakoff <rashtrakoff@pm.me>.\\n * @dev Contains functions which help in interacting with Superfluid contracts.\\n * @custom:experimental This is an experimental contract/library. Use at your own risk.\\n */\\n// solhint-disable not-rely-on-time\\nlibrary SFHelper {\\n    event NewSupertokenAdded(address _superToken, uint32 _index);\\n    event NewTemporaryIndexCreated(address _superToken, uint32 _index);\\n\\n    // Mainnet contract addresses.\\n    // ISuperfluid public constant HOST =\\n    //     ISuperfluid(0x3E14dC1b13c488a8d5D310918780c983bD5982E7);\\n    // IConstantFlowAgreementV1 public constant CFA_V1 =\\n    //     IConstantFlowAgreementV1(0x6EeE6060f715257b970700bc2656De21dEdF074C);\\n    // IInstantDistributionAgreementV1 public constant IDA_V1 =\\n    //     IInstantDistributionAgreementV1(\\n    //         0xB0aABBA4B2783A72C52956CDEF62d438ecA2d7a1\\n    //     );\\n\\n    // Mumbai testnet addresses.\\n    ISuperfluid public constant HOST =\\n        ISuperfluid(0xEB796bdb90fFA0f28255275e16936D25d3418603);\\n    IConstantFlowAgreementV1 public constant CFA_V1 =\\n        IConstantFlowAgreementV1(0x49e565Ed1bdc17F3d220f72DF0857C26FA83F873);\\n    IInstantDistributionAgreementV1 public constant IDA_V1 =\\n        IInstantDistributionAgreementV1(\\n            0x804348D4960a61f2d5F9ce9103027A3E849E09b8\\n        );\\n\\n    // Addresses for local testing.\\n    /// @dev Note: The addresses change for each test file. Don't run all the tests using `hh test`.\\n    /// Run each test file individually after getting the address from the `SFSetup.js`.\\n    // ISuperfluid public constant HOST =\\n    //     ISuperfluid(0x0165878A594ca255338adfa4d48449f69242Eb8F);\\n    // IConstantFlowAgreementV1 public constant CFA_V1 =\\n    //     IConstantFlowAgreementV1(0x610178dA211FEF7D417bC0e6FeD39F05609AD788);\\n    // IInstantDistributionAgreementV1 public constant IDA_V1 =\\n    //     IInstantDistributionAgreementV1(\\n    //         0x0DCd1Bf9A1b36cE34237eEaFef220932846BCD82\\n    //     );\\n\\n    /// Function to distribute a supertoken amount according to an index.\\n    /// @param _superToken The supertoken to be distributed.\\n    /// @param _index Index containing share details.\\n    /// @param _amount Amount of `_supertoken` to be distributed.\\n    function distribute(\\n        ISuperToken _superToken,\\n        uint32 _index,\\n        uint256 _amount\\n    ) external returns (bytes memory _newCtx) {\\n        // console.log(\\n        //     \\\"Amount to distribute: %s, Index: %s, DHPTx: %s\\\",\\n        //     _amount,\\n        //     _index,\\n        //     _superToken.balanceOf(address(this))\\n        // );\\n        (uint256 _actualAmount, ) = IDA_V1.calculateDistribution(\\n            _superToken,\\n            address(this),\\n            _index,\\n            _amount\\n        );\\n\\n        require(_amount >= _actualAmount, \\\"SFHelper: !enough tokens\\\");\\n\\n        _newCtx = HOST.callAgreement(\\n            IDA_V1,\\n            abi.encodeWithSelector(\\n                IDA_V1.distribute.selector,\\n                _superToken,\\n                _index,\\n                _actualAmount,\\n                new bytes(0)\\n            ),\\n            new bytes(0)\\n        );\\n\\n        // console.log(\\\"Actual amount distributed: %s\\\", _actualAmount);\\n    }\\n\\n    /// Function to create a distribution index.\\n    /// @param _superToken The supertoken to be distributed.\\n    /// @param _index New index value containing share details.\\n    function createIndex(ISuperToken _superToken, uint32 _index)\\n        external\\n        returns (bytes memory _newCtx)\\n    {\\n        _newCtx = HOST.callAgreement(\\n            IDA_V1,\\n            abi.encodeWithSelector(\\n                IDA_V1.createIndex.selector,\\n                _superToken,\\n                _index,\\n                new bytes(0) // placeholder ctx\\n            ),\\n            new bytes(0) // userData\\n        );\\n\\n        emit NewSupertokenAdded(address(_superToken), _index);\\n    }\\n\\n    /// Function to create a distribution index.\\n    /// @param _superToken The supertoken to be distributed.\\n    /// @param _index New index value containing share details.\\n    function createIndexInCallback(\\n        ISuperToken _superToken,\\n        uint32 _index,\\n        bytes calldata _ctx\\n    ) external returns (bytes memory _newCtx) {\\n        (_newCtx, ) = HOST.callAgreementWithContext(\\n            IDA_V1,\\n            abi.encodeWithSelector(\\n                IDA_V1.createIndex.selector,\\n                _superToken,\\n                _index,\\n                new bytes(0) // placeholder ctx\\n            ),\\n            new bytes(0), // userData\\n            _ctx\\n        );\\n\\n        emit NewTemporaryIndexCreated(address(_superToken), _index);\\n    }\\n\\n    /// @dev Function to update shares of a user.\\n    /// @param _superStreamToken The supertoken that the user is streaming.\\n    /// @param _superDistToken The supertoken that's distributed in index with value `_index`.\\n    /// @param _index Index containing share details.\\n    /// @param _ctx Superfluid context object.\\n    function updateSharesInCallback(\\n        ISuperToken _superStreamToken,\\n        ISuperToken _superDistToken,\\n        uint32 _index,\\n        address _user,\\n        bytes calldata _ctx\\n    ) external returns (bytes memory _newCtx) {\\n        // address _msgSender = HOST.decodeCtx(_ctx).msgSender;\\n        (, int96 _flowRate) = getFlow(_superStreamToken, _user);\\n        uint256 _userFlowRate = uint256(uint96(_flowRate));\\n\\n        (_newCtx, ) = HOST.callAgreementWithContext(\\n            IDA_V1,\\n            abi.encodeWithSelector(\\n                IDA_V1.updateSubscription.selector,\\n                _superDistToken,\\n                _index,\\n                _user,\\n                uint128(_userFlowRate / 1e9),\\n                new bytes(0)\\n            ),\\n            new bytes(0),\\n            _ctx\\n        );\\n    }\\n\\n    /// To be used when assigning shares in a temporary index.\\n    /// @param _superDistToken Distribution supertoken.\\n    /// @param _index Index ID in which shares need to be updated.\\n    /// @param _units Number of units to be assigned.\\n    /// @param _ctx Superfluid context object.\\n    function updateSharesInCallback(\\n        ISuperToken _superDistToken,\\n        uint32 _index,\\n        uint128 _units,\\n        address _user,\\n        bytes calldata _ctx\\n    ) external returns (bytes memory _newCtx) {\\n        // address _msgSender = HOST.decodeCtx(_ctx).msgSender;\\n\\n        (_newCtx, ) = HOST.callAgreementWithContext(\\n            IDA_V1,\\n            abi.encodeWithSelector(\\n                IDA_V1.updateSubscription.selector,\\n                _superDistToken,\\n                _index,\\n                _user,\\n                _units,\\n                new bytes(0)\\n            ),\\n            new bytes(0),\\n            _ctx\\n        );\\n    }\\n\\n    function deleteSubscriptionInCallback(\\n        ISuperToken _superToken,\\n        uint32 _index,\\n        address _user,\\n        bytes calldata _ctx\\n    ) external returns (bytes memory _newCtx) {\\n        // address _msgSender = HOST.decodeCtx(_ctx).msgSender;\\n\\n        (_newCtx, ) = HOST.callAgreementWithContext(\\n            IDA_V1,\\n            abi.encodeWithSelector(\\n                IDA_V1.deleteSubscription.selector,\\n                _superToken,\\n                address(this),\\n                _index,\\n                _user,\\n                new bytes(0)\\n            ),\\n            new bytes(0),\\n            _ctx\\n        );\\n    }\\n\\n    /// Function to close a stream.\\n    /// @dev This function should be called provided the app is jailed or user is running low on supertokens.\\n    /// @param _superToken The supertoken that the user is streaming\\n    /// @param _user Address of the user\\n    function emergencyCloseStream(ISuperToken _superToken, address _user)\\n        external\\n    {\\n        bool _close;\\n\\n        // Check whether the app is jailed and if so, proceed with stream termination\\n        if (HOST.isAppJailed(ISuperApp(address(this)))) _close = true;\\n        else {\\n            int96 _flowRate = CFA_V1.getNetFlow(_superToken, _user);\\n\\n            if (_flowRate < 0) {\\n                uint256 _balance = _superToken.balanceOf(_user);\\n                uint256 _positiveFlowRate = uint256(uint96(-1 * _flowRate));\\n\\n                // console.log(\\\"Balance: %s, +flowRate: %s\\\", _balance, _positiveFlowRate);\\n\\n                // if user has less liquidity ( <= 12 hours worth) close the stream\\n                if (_balance <= _positiveFlowRate * 12 hours) _close = true;\\n            }\\n        }\\n\\n        if (_close) {\\n            HOST.callAgreement(\\n                CFA_V1,\\n                abi.encodeWithSelector(\\n                    CFA_V1.deleteFlow.selector,\\n                    _superToken,\\n                    _user,\\n                    address(this),\\n                    new bytes(0) // placeholder\\n                ),\\n                \\\"0x\\\"\\n            );\\n        } else revert(\\\"SFHelper: No emergency close\\\");\\n    }\\n\\n    /// Function to get an index's details.\\n    /// @param _superToken Supertoken of the corresponding index.\\n    /// @param _indexId ID of the index whose details we require.\\n    function getIndex(ISuperToken _superToken, uint32 _indexId)\\n        external\\n        view\\n        returns (\\n            bool _exist,\\n            uint128 _indexValue,\\n            uint128 _totalUnitsApproved,\\n            uint128 _totalUnitsPending\\n        )\\n    {\\n        return IDA_V1.getIndex(_superToken, address(this), _indexId);\\n    }\\n\\n    /// Function to get details of a user's subscription (IDA subscription).\\n    /// @param _superToken Supertoken of the corresponding index.\\n    /// @param _index ID of the index in which the user's subscription is present.\\n    /// @param _user Address of the user whose subscription details we need.\\n    function getSubscription(\\n        ISuperToken _superToken,\\n        uint32 _index,\\n        address _user\\n    )\\n        external\\n        view\\n        returns (\\n            bool _exist,\\n            bool _approved,\\n            uint128 _units,\\n            uint256 _pendingDistribution\\n        )\\n    {\\n        return\\n            IDA_V1.getSubscription(_superToken, address(this), _index, _user);\\n    }\\n\\n    /// Function to get the flow rate of a user.\\n    /// @param _superToken Address of the supertoken.\\n    /// @param _sender Address of the user.\\n    /// @return _timestamp Timestamp corresponding to previous stream rate update time.\\n    /// @return _flowRate Flow rate of a user.\\n    function getFlow(ISuperToken _superToken, address _sender)\\n        public\\n        view\\n        returns (uint256 _timestamp, int96 _flowRate)\\n    {\\n        // console.log(\\\"Reached getFlow\\\");\\n        // console.log(\\\"Supertoken: %s, Sender: %s, This: %s\\\", address(_superToken), _sender, address(this));\\n\\n        (_timestamp, _flowRate, , ) = CFA_V1.getFlow(\\n            _superToken,\\n            _sender,\\n            address(this)\\n        );\\n    }\\n\\n    /// Checks if the caller is the SF host contract.\\n    function _onlyHost() internal view {\\n        require(\\n            msg.sender == address(HOST),\\n            \\\"SFHelper: Supports only one host\\\"\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x5a8006efd095c26ad030e287a0ea13030bafb05feb40182dd0ffe7cdf3d696e8\",\"license\":\"Unlicensed\"},\"contracts/dHedge-Factory-Version/Interfaces/IdHedge.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.10;\\n\\ninterface IPoolLogic {\\n    /// @notice Deposit funds into the pool\\n    /// @param _asset Address of the token\\n    /// @param _amount Amount of tokens to deposit\\n    /// @return liquidityMinted Amount of liquidity minted\\n    function deposit(address _asset, uint256 _amount)\\n        external\\n        returns (uint256 liquidityMinted);\\n\\n    /// @notice Withdraw assets based on the fund token amount\\n    /// @param _fundTokenAmount the fund token amount\\n    // function withdraw(uint256 _fundTokenAmount) external;\\n\\n    /// @notice Pool manager logic address for a pool\\n    function poolManagerLogic() external view returns (address);\\n\\n    /// @notice Get exit remaining time of the pool\\n    /// @return remaining The remaining exit time of the pool\\n    function getExitRemainingCooldown(address sender)\\n        external\\n        view\\n        returns (uint256 remaining);\\n}\\n\\ninterface IPoolManagerLogic {\\n    // struct Asset {\\n    //     address asset;\\n    //     bool isDeposit;\\n    // }\\n\\n    /// @notice Get all the supported assets\\n    /// @return Return array of supported assets\\n    // function getSupportedAssets() external view returns (Asset[] memory);\\n\\n    /// @notice Get all the deposit assets\\n    /// @return Return array of deposit assets' addresses\\n    function getDepositAssets() external view returns (address[] memory);\\n\\n    /// @notice Return true if it's supported asset, false otherwise\\n    /// @param asset address of the asset\\n    // function isSupportedAsset(address asset) external view returns (bool);\\n\\n    /// @notice Return true if it's deposit asset, false otherwise\\n    /// @param asset address of the asset\\n    function isDepositAsset(address asset) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xadf8e90ebd932af20acae1aaab8fbc85b532e7252c1382f433e92141e7c0b003\",\"license\":\"Unlicensed\"},\"contracts/dHedge-Factory-Version/Interfaces/IdHedgeCoreFactory.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.10;\\n\\ninterface IdHedgeCoreFactory {\\n    event CoreCreated(address newCore, address pool, address poolSuperToken);\\n    event ImplementationChanged(address newImplementation, string message);\\n    event FeeRateChanged(uint32 newFeeRate);\\n    event DAOAddressChanged(address newDAOAddr);\\n\\n    function dao() external view returns (address);\\n\\n    function defaultFeeRate() external view returns (uint32);\\n}\\n\",\"keccak256\":\"0x080fe169877c32ea027d9864882824a5cc403aa662c9b6b53a9804b3445346e8\",\"license\":\"Unlicensed\"},\"contracts/dHedge-Factory-Version/Libraries/dHedgeHelper.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.10;\\nimport { IPoolLogic, IPoolManagerLogic } from \\\"../Interfaces/IdHedge.sol\\\";\\nimport { IdHedgeCoreFactory } from \\\"../Interfaces/IdHedgeCoreFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./dHedgeStorage.sol\\\";\\nimport \\\"./dHedgeMath.sol\\\";\\nimport \\\"../../Common/SFHelper.sol\\\";\\nimport { IERC20Mod } from \\\"../../Common/IERC20Mod.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @title dHEDGE core helper library.\\n * @author rashtrakoff <rashtrakoff@pm.me>.\\n * @dev Contains functions for interacting with dHEDGE protocol pools.\\n * @custom:experimental This is an experimental contract/library. Use at your own risk.\\n */\\n\\n// solhint-disable reason-string\\n// solhint-disable not-rely-on-time\\n// solhint-disable contract-name-camelcase\\nlibrary dHedgeHelper {\\n    using SafeERC20 for IERC20;\\n    using SFHelper for ISuperToken;\\n    using dHedgeMath for *;\\n\\n    event TokenInitialised(ISuperToken superToken, address token);\\n    event TokenDeposited(\\n        address token,\\n        uint256 amount,\\n        uint256 liquidityMinted\\n    );\\n    event UpfrontFeeReturned(\\n        ISuperToken superToken,\\n        address sender,\\n        uint256 amount\\n    );\\n    event UpfrontFeeDeposited(\\n        ISuperToken superToken,\\n        address sender,\\n        uint256 amount\\n    );\\n\\n    /// Initialise a market for a new token.\\n    /// This means, create 3 indices (2 permanent and 1 temporary) along with unlimited approval-\\n    /// for the underlying token to the dHEDGE pool.\\n    /// @param _dHedgePool Struct containing details regarding the pool and various tokens in it.\\n    /// @param _superToken The supertoken which needs to be initialised.\\n    function initStreamToken(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        ISuperToken _superToken\\n    ) external {\\n        address _underlyingToken = _superToken.getUnderlyingToken();\\n        dHedgeStorage.TokenData storage tokenData = _dHedgePool.tokenData[\\n            _underlyingToken\\n        ];\\n\\n        // The underlying token should be accepted by the dHEDGE pool. However,\\n        // initialising a token which isn't supported by dHEDGE pool at the time of execution-\\n        // of this function won't create any issues. We can remove this check for gas optimisations.\\n        require(\\n            IPoolManagerLogic(\\n                IPoolLogic(_dHedgePool.poolLogic).poolManagerLogic()\\n            ).isDepositAsset(_underlyingToken),\\n            \\\"dHedgeHelper: Not deposit asset\\\"\\n        );\\n\\n        // If the underlying token is already initialised, it will already have a corresponding-\\n        // supertoken. Hence, no need for re-initialisation. If the supertoken turns out to be malicious,\\n        // then we can't do anything about it after the fact. If possible, check if the supertoken being-\\n        // initialised was created by the supertoken factory contract. This isn't a major issue though.\\n        // For the time-being, we can make this function conform to `onlyOwner` condition.\\n        require(\\n            address(tokenData.superToken) == address(0),\\n            \\\"dHedgeHelper: Token already present\\\"\\n        );\\n\\n        // Create 2 permanent indices in accordance with `3-index` approach.\\n        uint32 _latestDistIndex = _dHedgePool.latestDistIndex;\\n        tokenData.permDistIndex1.indexId = _latestDistIndex;\\n        tokenData.permDistIndex2.indexId = _latestDistIndex + 1;\\n        tokenData.tempDistIndex = _latestDistIndex + 2;\\n\\n        // We will start the stream of the supertoken using the first index and hence, index 2 is locked.\\n        tokenData.lockedIndexId = _latestDistIndex + 1;\\n        _dHedgePool.latestDistIndex += 3;\\n\\n        tokenData.superToken = _superToken;\\n\\n        bytes memory _newCtx = _dHedgePool.DHPTx.createIndex(_latestDistIndex);\\n        _newCtx = _dHedgePool.DHPTx.createIndex(_latestDistIndex + 1);\\n        _newCtx = _dHedgePool.DHPTx.createIndex(_latestDistIndex + 2);\\n\\n        // Unlimited allowance for the dHEDGE pool so that deposits can take place efficiently.\\n        IERC20(_underlyingToken).safeIncreaseAllowance(\\n            _dHedgePool.poolLogic,\\n            type(uint256).max\\n        );\\n\\n        emit TokenInitialised(_superToken, _underlyingToken);\\n    }\\n\\n    /// Function to deposit tokens into a dHedge pool.\\n    /// @param _dHedgePool Struct containing details regarding the pool and various tokens in it.\\n    /// @param _depositToken Address of the underlying token (deposit token and not the supertoken).\\n    function deposit(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        address _depositToken\\n    ) external {\\n        dHedgeStorage.TokenData storage tokenData = _dHedgePool.tokenData[\\n            _depositToken\\n        ];\\n        IPoolLogic _poolLogic = IPoolLogic(_dHedgePool.poolLogic);\\n        ISuperToken _superToken = tokenData.superToken;\\n        ISuperToken _DHPTx = _dHedgePool.DHPTx;\\n\\n        // If all conditions for a deposit is satisfied then proceed with the deposit.\\n        require(\\n            _checkUpkeep(tokenData, _depositToken, _dHedgePool.lastDepositAt) &&\\n                isDepositAsset(_dHedgePool, _depositToken),\\n            \\\"dHedgeHelper: Deposit not required\\\"\\n        );\\n\\n        uint32 _lockedIndexId = tokenData.lockedIndexId;\\n        uint32 _permDistIndex1 = tokenData.permDistIndex1.indexId;\\n        uint32 _permDistIndex2 = tokenData.permDistIndex2.indexId;\\n        // uint256 _superTokenBalance = _superToken.balanceOf(address(this));\\n\\n        // Upgrade the unlocked DHPT such that DHPT is transferred to SF vesting contract.\\n        // This is because we have to proceed with next cycle of deposits without locking previous cycles' DHPT.\\n        _upgradeDHPTx(_poolLogic, _DHPTx);\\n\\n        // If `distAmount` is greater than 0 it means previous cycle's DHPT hasn't been distributed.\\n        // A distribution needs to occur before next deposit of the same underlying token.\\n        if (tokenData.distAmount != 0) {\\n            // Perform DHPTx distribution along with few other things (detailed later below).\\n            _distribute(\\n                _dHedgePool,\\n                tokenData,\\n                _DHPTx,\\n                _lockedIndexId,\\n                tokenData.tempDistIndex\\n            );\\n        }\\n\\n        // If first index is locked but second index is active then proceed with second index.\\n        if (\\n            _lockedIndexId == _permDistIndex1 &&\\n            tokenData.permDistIndex2.isActive\\n        )\\n            _lockedIndexId = _permDistIndex2;\\n\\n            // If index 2 is locked but index 1 is active then proceed with index 1.\\n        else if (\\n            _lockedIndexId == _permDistIndex2 &&\\n            tokenData.permDistIndex1.isActive\\n        ) _lockedIndexId = _permDistIndex1;\\n\\n        // Else:\\n        // - If index 1 is locked and index 2 is inactive then proceed with index 1.\\n        // - If index 2 is locked and index 1 is inactive then proceed with index 2.\\n\\n        // Calculate the amount of tokens to deposit for an index.\\n        uint256 _downgradeAmount = _getSuperTokenDepositBalance(\\n            _DHPTx,\\n            _lockedIndexId,\\n            _permDistIndex1,\\n            _permDistIndex2,\\n            _superToken.balanceOf(address(this))\\n        );\\n\\n        // If there is anything to deposit, only then should the deposit proceed.\\n        // Index shouldn't be unlocked or locked otherwise.\\n        if (_downgradeAmount > 0) {\\n            // Downgrade amount of supertoken required for deposit.\\n            _superToken.downgrade(_downgradeAmount);\\n\\n            // Actual deposit logic. Had to break it from the main function due to stack too deep errors.\\n            _deposit(\\n                tokenData,\\n                _depositToken,\\n                IdHedgeCoreFactory(_dHedgePool.factory),\\n                _poolLogic\\n            );\\n\\n            // If `_lockedIndexId` is correct, don't modify it (minor gas savings).\\n            if (tokenData.lockedIndexId != _lockedIndexId)\\n                tokenData.lockedIndexId = _lockedIndexId;\\n\\n            // Update the timestamp marking when a deposit corresponding to an index took place.\\n            // This is important as uninvested amount calculations are done using this timestamp among-\\n            // other reasons.\\n            (_lockedIndexId == _permDistIndex1)\\n                ? tokenData.permDistIndex1.lastDepositAt = uint64(\\n                    block.timestamp\\n                )\\n                : tokenData.permDistIndex2.lastDepositAt = uint64(\\n                block.timestamp\\n            );\\n\\n            // Finally, update timestamp indicating when a deposit (of any token) was made into the dHEDGE pool.\\n            _dHedgePool.lastDepositAt = uint64(block.timestamp);\\n        }\\n\\n        // console.log(\\\"Deposit for index %s complete\\\", _lockedIndexId);\\n    }\\n\\n    /// Function to distribute DHPTx.\\n    /// @param _dHedgePool Struct containing details regarding the pool and various tokens in it.\\n    /// @param _depositToken Address of the underlying token (deposit token and not the supertoken).\\n    function distribute(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        address _depositToken\\n    ) public {\\n        dHedgeStorage.TokenData storage tokenData = _dHedgePool.tokenData[\\n            _depositToken\\n        ];\\n        ISuperToken _DHPTx = _dHedgePool.DHPTx;\\n\\n        // Upgrade the DHPT in the contract.\\n        _upgradeDHPTx(IPoolLogic(_dHedgePool.poolLogic), _DHPTx);\\n\\n        // console.log(\\n        //     \\\"DistAmount: %s, DHPTx balance: %s\\\",\\n        //     tokenData.distAmount,\\n        //     _DHPTx.balanceOf(address(this))\\n        // );\\n\\n        // Should only attempt to distribute DHPTx if there are any to be distributed.\\n        require(\\n            tokenData.distAmount != 0 && _DHPTx.balanceOf(address(this)) != 0,\\n            \\\"dHedgeHelper: No amount to distribute\\\"\\n        );\\n\\n        // Actual distribution logic (detailed further down).\\n        _distribute(\\n            _dHedgePool,\\n            tokenData,\\n            _DHPTx,\\n            tokenData.lockedIndexId,\\n            tokenData.tempDistIndex\\n        );\\n    }\\n\\n    /// This function serves as the `afterAgreementCreated` hook for Superfluid CFA.\\n    /// Responsible for actions to be taken after creation of a stream (transfer buffer, update shares, etc.).\\n    /// @param _dHedgePool Struct containing details regarding the pool and various tokens in it.\\n    /// @param _superToken The supertoken whose stream needs to be created.\\n    /// @param _agreementClass Tells whether it's CFA or IDA contract call.\\n    /// @param _ctx Superfluid context object.\\n    /// @param _cbdata Callback data passed on from `beforeAgreementCreated` hook.\\n    function afterAgreementCreated(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        ISuperToken _superToken,\\n        address _agreementClass,\\n        bytes memory _agreementData,\\n        bytes memory _ctx,\\n        bytes memory _cbdata\\n    ) external returns (bytes memory _newCtx) {\\n        _newCtx = _ctx;\\n\\n        // Execution should take place only for CFA contract. Ignore for IDA.\\n        if (\\n            ISuperAgreement(_agreementClass).agreementType() ==\\n            keccak256(\\n                \\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"\\n            )\\n        ) {\\n            (address _sender, ) = abi.decode(\\n                _agreementData,\\n                (address, address)\\n            );\\n            address _underlyingToken = _superToken.getUnderlyingToken();\\n            dHedgeStorage.TokenData storage tokenData = _dHedgePool.tokenData[\\n                _underlyingToken\\n            ];\\n            ISuperToken _DHPTx = _dHedgePool.DHPTx;\\n\\n            // Select the active index ID.\\n            dHedgeStorage.PermIndexData storage index = (tokenData\\n                .lockedIndexId == tokenData.permDistIndex1.indexId)\\n                ? tokenData.permDistIndex2\\n                : tokenData.permDistIndex1;\\n            uint256 _userUninvested = abi.decode(_cbdata, (uint256));\\n\\n            // Initialise the `_currActiveIndex` if not already done (detailed further down).\\n            // An index is made inactive in case there are no subscribers. It may happen that a new subscriber-\\n            // is to be issued units in an inactive index. In such a case, intialisation is required.\\n            if (!index.isActive) {\\n                index.isActive = true;\\n                index.lastDepositAt = uint64(block.timestamp);\\n            }\\n\\n            uint32 _currActiveIndexId = index.indexId;\\n\\n            // Mark the assigned index of the user. Will be useful when updating/terminating the stream.\\n            tokenData.assignedIndex[_sender] = _currActiveIndexId;\\n\\n            // Transfer the buffer amount (upfront deposit). Requirement is explained below.\\n            if (index.lastDepositAt != 0) {\\n                _transferBuffer(\\n                    _superToken,\\n                    _sender,\\n                    index.lastDepositAt,\\n                    _userUninvested\\n                );\\n            }\\n\\n            // Assign new units in the active index.\\n            _newCtx = _superToken.updateSharesInCallback(\\n                _DHPTx,\\n                _currActiveIndexId,\\n                _sender,\\n                _newCtx\\n            );\\n        }\\n    }\\n\\n    /// This function serves as the `afterAgreementUpdated` hook for Superfluid CFA.\\n    /// Responsible for actions to be taken after updation of stream rate (transfer buffer, update shares, etc.).\\n    /// @param _dHedgePool Struct containing details regarding the pool and various tokens in it.\\n    /// @param _superToken Underlying token of the supertoken.\\n    /// @param _agreementClass Tells whether it's CFA or IDA contract call.\\n    /// @param _ctx Superfluid context object.\\n    /// @param _cbdata Callback data passed on from `beforeAgreementUpdated` hook.\\n    function afterAgreementUpdated(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        ISuperToken _superToken,\\n        address _agreementClass,\\n        bytes memory _agreementData,\\n        bytes memory _ctx,\\n        bytes memory _cbdata\\n    ) external returns (bytes memory _newCtx) {\\n        _newCtx = _ctx;\\n\\n        if (\\n            ISuperAgreement(_agreementClass).agreementType() ==\\n            keccak256(\\n                \\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"\\n            )\\n        ) {\\n            (address _sender, ) = abi.decode(\\n                _agreementData,\\n                (address, address)\\n            );\\n            address _underlyingToken = _superToken.getUnderlyingToken();\\n            dHedgeStorage.TokenData storage tokenData = _dHedgePool.tokenData[\\n                _underlyingToken\\n            ];\\n            ISuperToken _DHPTx = _dHedgePool.DHPTx;\\n\\n            uint32 _lockedIndexId = tokenData.lockedIndexId;\\n            uint256 _userUninvested = abi.decode(_cbdata, (uint256));\\n\\n            dHedgeStorage.PermIndexData storage currActiveIndex;\\n\\n            if (tokenData.distAmount != 0) {\\n                // If distribution hasn't happened for the previous cycle then, select the unlocked index.\\n                currActiveIndex = (_lockedIndexId ==\\n                    tokenData.permDistIndex1.indexId)\\n                    ? tokenData.permDistIndex2\\n                    : tokenData.permDistIndex1;\\n\\n                // Initialise the `_currActiveIndex` if not already done (detailed further down).\\n                // An index is made inactive in case there are no subscribers. It may happen that a new subscriber-\\n                // is to be issued units in an inactive index. In such a case, intialisation is required.\\n                if (!currActiveIndex.isActive) {\\n                    currActiveIndex.isActive = true;\\n                    currActiveIndex.lastDepositAt = uint64(block.timestamp);\\n                }\\n\\n                // If assigned index is currently locked then we will have to initiate index migration (detailed below).\\n                if (tokenData.assignedIndex[_sender] == _lockedIndexId) {\\n                    _newCtx = _migrateIndex(\\n                        tokenData,\\n                        _DHPTx,\\n                        _sender,\\n                        _newCtx\\n                    );\\n\\n                    // Modify user's assigned index as the current active index if not the same.\\n                    tokenData.assignedIndex[_sender] = currActiveIndex.indexId;\\n                }\\n            } else {\\n                // Else, select the assigned index of the user as the active index.\\n                // This is because the DHPT locked in the latest cycle has already been deposited and in such a-\\n                // case, index migration isn't necessary.\\n                currActiveIndex = (tokenData.assignedIndex[_sender] ==\\n                    tokenData.permDistIndex1.indexId)\\n                    ? tokenData.permDistIndex1\\n                    : tokenData.permDistIndex2;\\n            }\\n\\n            // Transfer the buffer amount (upfront deposit). Requirement is explained below.\\n            if (currActiveIndex.lastDepositAt != 0) {\\n                _transferBuffer(\\n                    _superToken,\\n                    _sender,\\n                    currActiveIndex.lastDepositAt,\\n                    _userUninvested\\n                );\\n            }\\n\\n            // Assigning new units in the active index.\\n            _newCtx = _superToken.updateSharesInCallback(\\n                _DHPTx,\\n                currActiveIndex.indexId,\\n                _sender,\\n                _newCtx\\n            );\\n        }\\n    }\\n\\n    /// This function serves as the `afterAgreementTerminated` hook for Superfluid CFA.\\n    /// Responsible for actions to be taken after termination of the stream (transfer buffer, update shares, etc.).\\n    /// @param _dHedgePool Struct containing details regarding the pool and various tokens in it.\\n    /// @param _superToken Underlying token of the supertoken.\\n    /// @param _agreementClass Tells whether it's CFA or IDA contract call.\\n    /// @param _ctx Superfluid context object.\\n    /// @param _cbdata Callback data passed on from `beforeAgreementTerminated` hook.\\n    function afterAgreementTerminated(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        ISuperToken _superToken,\\n        address _agreementClass,\\n        bytes memory _agreementData,\\n        bytes memory _ctx,\\n        bytes memory _cbdata\\n    ) external returns (bytes memory _newCtx) {\\n        _newCtx = _ctx;\\n\\n        if (\\n            ISuperAgreement(_agreementClass).agreementType() ==\\n            keccak256(\\n                \\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"\\n            )\\n        ) {\\n            (address _sender, ) = abi.decode(\\n                _agreementData,\\n                (address, address)\\n            );\\n            address _underlyingToken = _superToken.getUnderlyingToken();\\n            dHedgeStorage.TokenData storage tokenData = _dHedgePool.tokenData[\\n                _underlyingToken\\n            ];\\n            uint32 _assignedIndex = tokenData.assignedIndex[_sender];\\n            uint256 _userUninvested = abi.decode(_cbdata, (uint256));\\n\\n            // If assigned index is currently locked then we will have to initiate index migration (detailed below).\\n            if (\\n                tokenData.distAmount != 0 &&\\n                _assignedIndex == tokenData.lockedIndexId\\n            ) {\\n                _newCtx = _migrateIndex(\\n                    tokenData,\\n                    _dHedgePool.DHPTx,\\n                    _sender,\\n                    _newCtx\\n                );\\n            } else {\\n                // console.log(\\\"Reached afterAgreementTerminated else\\\");\\n\\n                (uint128 _totalUnits, uint128 _userUnits) = _getUnits(\\n                    _dHedgePool.DHPTx,\\n                    _assignedIndex,\\n                    _sender\\n                );\\n\\n                // Deleting units of the user in their current index.\\n                _newCtx = _dHedgePool.DHPTx.deleteSubscriptionInCallback(\\n                    _assignedIndex,\\n                    _sender,\\n                    _newCtx\\n                );\\n\\n                // If the total units in the current index was equal to user's units, make the index inactive.\\n                if (_totalUnits == _userUnits) {\\n                    if (_assignedIndex == tokenData.permDistIndex1.indexId) {\\n                        tokenData.permDistIndex1.isActive = false;\\n                        delete tokenData.permDistIndex1.lastDepositAt;\\n                    } else {\\n                        tokenData.permDistIndex2.isActive = false;\\n                        delete tokenData.permDistIndex2.lastDepositAt;\\n                    }\\n                }\\n            }\\n\\n            delete tokenData.assignedIndex[_sender];\\n\\n            // @dev We can directly transfer the amount instead of using `_transferBuffer`.\\n            assert(_userUninvested <= _superToken.balanceOf(address(this)));\\n\\n            require(\\n                _superToken.transfer(_sender, _userUninvested),\\n                \\\"dHedgeHelper: Buffer transfer failed\\\"\\n            );\\n        }\\n    }\\n\\n    /// Helper function that's called before streams are updated or terminated.\\n    /// @param _superToken Underlying token of the supertoken.\\n    /// @param _agreementClass Tells whether it's CFA or IDA contract call.\\n    /// @return _cbdata Callback data that needs to be passed on to after agreement hooks.\\n    function beforeAgreement(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        ISuperToken _superToken,\\n        address _agreementClass,\\n        bytes memory _agreementData\\n    )\\n        external\\n        view\\n        returns (\\n            // bytes memory _ctx\\n            bytes memory _cbdata\\n        )\\n    {\\n        _cbdata = new bytes(0);\\n\\n        if (\\n            ISuperAgreement(_agreementClass).agreementType() ==\\n            keccak256(\\n                \\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"\\n            )\\n        ) {\\n            // address _sender = SFHelper.HOST.decodeCtx(_ctx).msgSender;\\n            (address _user, ) = abi.decode(_agreementData, (address, address));\\n\\n            // Encode the uninvested amount. We calculate it before modifying the stream rate.\\n            _cbdata = abi.encode(\\n                _dHedgePool.calcUserUninvested(_user, _superToken, 0)\\n            );\\n        }\\n    }\\n\\n    /// This function is useful for on-chain keepers. Deposit function should only be called if `_reqUpkeep` is true-\\n    /// let whatever be the address of the `_depositToken`.\\n    /// @dev Function which checks if deposit function can be called or not.\\n    /// @param _dHedgePool Struct containing details regarding the pool and various tokens in it.\\n    /// @return _depositToken Address of an underlying token.\\n    function requireUpkeep(dHedgeStorage.dHedgePool storage _dHedgePool)\\n        external\\n        view\\n        returns (address _depositToken)\\n    {\\n        // Only if the core contract is active should upkeep really be possible.\\n        if (_dHedgePool.isActive) {\\n            IPoolLogic _poolLogic = IPoolLogic(_dHedgePool.poolLogic);\\n            IPoolManagerLogic _supportLogic = IPoolManagerLogic(\\n                _poolLogic.poolManagerLogic()\\n            );\\n\\n            // Get assets currently supported by the dHEDGE pool. This is an optimised way-\\n            // of figuring out which tokens need to be deposited into the dHEDGE pool since the-\\n            // number of assets supported as deposit assets will generally be less than the variety-\\n            // of assets being streamed to the core contract of that pool.\\n            address[] memory _depositAssets = _supportLogic.getDepositAssets();\\n\\n            for (uint8 i = 0; i < _depositAssets.length; ++i) {\\n                _depositToken = _depositAssets[i];\\n                dHedgeStorage.TokenData storage tokenData = _dHedgePool\\n                    .tokenData[_depositToken];\\n\\n                if (\\n                    _checkUpkeep(\\n                        tokenData,\\n                        _depositToken,\\n                        _dHedgePool.lastDepositAt\\n                    )\\n                ) return (_depositToken);\\n            }\\n        }\\n\\n        return (address(0));\\n    }\\n\\n    /// Function which checks for all the conditions to be satisfied for an upkeep task.\\n    /// @param _tokenData Struct containing all the relevant details for a deposit token.\\n    /// @param _depositToken Address of the token to be deposited into the dHEDGE pool.\\n    /// @param _poolLastDepositAt Timestamp of the dHEDGE pool's last deposit from the core contract.\\n    /// @return Boolean stating whether token deposit is required.\\n    function _checkUpkeep(\\n        dHedgeStorage.TokenData storage _tokenData,\\n        address _depositToken,\\n        uint64 _poolLastDepositAt\\n    ) private view returns (bool) {\\n        uint256 _depositCycleDelay = block.timestamp - _poolLastDepositAt;\\n\\n        // If supertoken for an underlying token exists then proceed with the deposit and,\\n        // one of the permanent indices is active and,\\n        // if there is a delay of 15 minutes or more between two token deposits, we stop the cycle-\\n        // until 24 hours have been passed from the last deposit.\\n        // if it's been more than or equal to 24 hours since last deposit of the underlying token then,\\n        // upkeep (deposit to the dHEDGE pool) is necessary.\\n        if (\\n            (address(_tokenData.superToken) != address(0)) &&\\n            (_tokenData.permDistIndex1.isActive ||\\n                _tokenData.permDistIndex2.isActive) &&\\n            (_depositCycleDelay < 15 minutes ||\\n                _depositCycleDelay >= 24 hours) &&\\n            (block.timestamp -\\n                uint64(\\n                    (_tokenData.permDistIndex1.lastDepositAt >\\n                        _tokenData.permDistIndex2.lastDepositAt)\\n                        ? _tokenData.permDistIndex1.lastDepositAt\\n                        : _tokenData.permDistIndex2.lastDepositAt\\n                )) >=\\n            24 hours\\n        ) {\\n            // Calculate how much balance is there for the deposit. Since supertokens have 18 decimals-\\n            // and their underlying tokens can have decimals less than 18, some amount will always be left inside-\\n            // the core contract (dust amount). This amount can't be deposited into the dHEDGE pool and thus,\\n            // this function should return false in such cases.\\n            uint256 _depositBalance = _tokenData.superToken.balanceOf(\\n                address(this)\\n            ) / (10**(18 - IERC20Mod(_depositToken).decimals()));\\n\\n            if (_depositBalance > 0) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// Wrapper function to check if an asset is accepted as deposit asset in a dHedge pool.\\n    /// @param _dHedgePool Struct containing details regarding the pool and various tokens in it.\\n    /// @param _token Address of the underlying token to be deposited.\\n    /// @return Boolean representing the status of the token for deposition.\\n    function isDepositAsset(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        address _token\\n    ) public view returns (bool) {\\n        IPoolLogic _poolLogic = IPoolLogic(_dHedgePool.poolLogic);\\n        IPoolManagerLogic _supportLogic = IPoolManagerLogic(\\n            _poolLogic.poolManagerLogic()\\n        );\\n\\n        return _supportLogic.isDepositAsset(_token);\\n    }\\n\\n    /// Function containing logic for collecting upfront deposit.\\n    /// A upfront deposit needs to be collected in order to maintain the same distribution unit price for a deposit cycle-\\n    /// for all streamers. For example, a person starting a stream of $10/day soon after a deposit gets the same-\\n    /// number of units as another person starting a stream with the same rate but just before the next deposit.\\n    /// However, the second person streamed a lot less than the first person and hence shouldn't get the same-\\n    /// amount of DHPTx as the first one.\\n    /// @param _superToken Address of the supertoken that the user is streaming or wants to stream.\\n    /// @param _sender Address of the user creating/updating/terminating the stream.\\n    /// @param _lastDepositAt Timestamp corresponding to the latest deposition of the underlying token into the-\\n    /// dHEGDE pool.\\n    /// @param _userUninvested Amount of supertokens corresponding to the user which are present in the core contract.\\n    function _transferBuffer(\\n        ISuperToken _superToken,\\n        address _sender,\\n        uint64 _lastDepositAt,\\n        uint256 _userUninvested\\n    ) private {\\n        (uint256 _amount, bool _isTaken) = _superToken\\n            ._calcBufferTransferAmount(\\n                _sender,\\n                _lastDepositAt,\\n                0,\\n                _userUninvested\\n            );\\n\\n        bool _success;\\n\\n        if (_amount > 0) {\\n            // If amount to be deposited is greater than user's uninvested amount then,\\n            // transfer the difference from the user.\\n            if (_isTaken) {\\n                // console.log(\\\"Amount to be transferred from: \\\", _amount);\\n\\n                _success = _superToken.transferFrom(\\n                    _sender,\\n                    address(this),\\n                    _amount\\n                );\\n\\n                emit UpfrontFeeDeposited(_superToken, _sender, _amount);\\n            } else {\\n                // Else if the amount to be deposited is lesser than the uninvested amount, transfer-\\n                // the difference to the user.\\n\\n                // console.log(\\\"Amount to be transferred to: \\\", _amount);\\n\\n                _success = _superToken.transfer(_sender, _amount);\\n\\n                emit UpfrontFeeReturned(_superToken, _sender, _amount);\\n            }\\n\\n            require(_success, \\\"dHedgeHelper: Buffer transfer failed\\\");\\n        }\\n\\n        // // If amount to be deposited is greater than user's uninvested amount then,\\n        // // transfer the difference from the user.\\n        // if (_depositAmount > _userUninvested) {\\n        //     uint256 _amount = _depositAmount - _userUninvested;\\n\\n        //     // console.log(\\\"Amount to be transferred from: \\\", _amount);\\n\\n        //     _success = _superToken.transferFrom(\\n        //         _sender,\\n        //         address(this),\\n        //         _amount\\n        //     );\\n\\n        //     emit UpfrontFeeDeposited(_superToken, _sender, _amount);\\n        // } else if (_depositAmount < _userUninvested) {\\n        //     // Else if the amount to be deposited is lesser than the uninvested amount, transfer-\\n        //     // the difference to the user.\\n        //     uint256 _amount = _userUninvested - _depositAmount;\\n\\n        //     // console.log(\\\"Amount to be transferred to: \\\", _amount);\\n\\n        //     _success = _superToken.transfer(_sender, _amount);\\n\\n        //     emit UpfrontFeeReturned(_superToken, _sender, _amount);\\n        // } else {\\n        //     // If `_depositAmount == _userUninvested` then technically no transfer should take place.\\n        //     // This case can be reached for the very first streamer of a new supertoken.\\n        //     _success = true;\\n        // }\\n    }\\n\\n    /// Function containing the logic to make a deposit into the dHEDGE pool.\\n    /// @param _tokenData Struct containing all the relevant details for a deposit token.\\n    /// @param _depositToken Address of the underlying token (deposit token and not the supertoken).\\n    /// @param _factory Address of the core factory contract.\\n    /// @param _poolLogic Address of the dHEDGE pool into which deposition should happen.\\n    function _deposit(\\n        dHedgeStorage.TokenData storage _tokenData,\\n        address _depositToken,\\n        IdHedgeCoreFactory _factory,\\n        IPoolLogic _poolLogic\\n    ) private {\\n        uint256 _depositBalance = IERC20Mod(_depositToken).balanceOf(\\n            address(this)\\n        );\\n\\n        // Perform deposit transaction iff amount of underlying tokens is greater than 0.\\n        /// @dev It may be possible that this check is useless as we are checking for-\\n        /// `_downgradeAmount > 0` in `deposit`.\\n        if (_depositBalance > 0) {\\n            // Calculate fee to be collected.\\n            uint256 _feeCollected = (_depositBalance *\\n                _factory.defaultFeeRate()) / 1e6;\\n\\n            _depositBalance -= _feeCollected;\\n\\n            // Transfer the fees collected for the owner only if it's greater than 0.\\n            // This condition won't be satisfied in case `defaultFeeRate` is set as 0.\\n            if (_feeCollected > 0) {\\n                IERC20(_depositToken).safeTransfer(\\n                    IdHedgeCoreFactory(_factory).dao(),\\n                    _feeCollected\\n                );\\n            }\\n\\n            // Deposit the tokens into the dHedge pool.\\n            uint256 _liquidityMinted = _poolLogic.deposit(\\n                _depositToken,\\n                _depositBalance\\n            );\\n\\n            // console.log(\\n            //     \\\"Token: %s; Amount: %s, DHPT: %s\\\",\\n            //     _depositToken,\\n            //     _depositBalance,\\n            //     _liquidityMinted\\n            // );\\n\\n            // Update the amount to be distributed.\\n            _tokenData.distAmount = _liquidityMinted;\\n\\n            emit TokenDeposited(\\n                _depositToken,\\n                _depositBalance,\\n                _liquidityMinted\\n            );\\n        }\\n    }\\n\\n    /// Function to migrate user's units from one index to another.\\n    /// The reason we need to migrate user's units is that since DHPT minted in a cycle is locked for 24 hours,\\n    /// is a user updates/terminates their ongoing stream then it's not possible to distribute their share of-\\n    /// DHPT from the previous cycle. To avoid this, we create a temporary index and assign the same amount of-\\n    /// units as they had before. We also set aside the portion of DHPT they would receive in order for that-\\n    /// amount to be distributed using the temporary index. Finally, if user had updated their stream, we assign-\\n    /// new units in the active index. Index migration should only happen if one of the permanent indices is locked-\\n    /// as this is a costly process.\\n    /// @param _tokenData Struct containing all the relevant details for a deposit token.\\n    /// @param _DHPTx Address of the supertoken corresponding to the DHPT of the dHEDGE pool.\\n    /// @param _sender Address of the user for whom index migration is necessary.\\n    /// @param _ctx Superfluid context object.\\n    function _migrateIndex(\\n        dHedgeStorage.TokenData storage _tokenData,\\n        ISuperToken _DHPTx,\\n        address _sender,\\n        bytes memory _ctx\\n    ) private returns (bytes memory _newCtx) {\\n        // console.log(\\\"Index migration begun\\\");\\n\\n        _newCtx = _ctx;\\n        uint32 _lockedIndexId = _tokenData.lockedIndexId;\\n\\n        // Index migration is done by deleting a sender's subscription in the locked index\\n        // and assigning new units in the active index along with assigning new units in temporary\\n        // index.\\n        (uint128 _totalUnits, uint128 _userUnits) = _getUnits(\\n            _DHPTx,\\n            _lockedIndexId,\\n            _sender\\n        );\\n\\n        uint256 _tempDistAmount = _tokenData.tempDistAmount;\\n\\n        // Calculating a user's pending locked tokens amount by using units issued to the user,\\n        // total units issued and total amount of DHPT in this contract (this is the locked amount)\\n        _tempDistAmount += ((_userUnits *\\n            (_tokenData.distAmount - _tempDistAmount)) / _totalUnits);\\n\\n        _tokenData.tempDistAmount = _tempDistAmount;\\n\\n        // console.log(\\n        //     \\\"Temp dist amount in migration: %s\\\",\\n        //     _tokenData.tempDistAmount\\n        // );\\n\\n        // Check if the total units of the locked index is equal to only the user's units.\\n        // We will have to make this index inactive if the condition is true.\\n        if (_totalUnits == _userUnits) {\\n            if (_lockedIndexId == _tokenData.permDistIndex1.indexId) {\\n                _tokenData.permDistIndex1.isActive = false;\\n                delete _tokenData.permDistIndex1.lastDepositAt;\\n            } else {\\n                _tokenData.permDistIndex2.isActive = false;\\n                delete _tokenData.permDistIndex2.lastDepositAt;\\n            }\\n        }\\n\\n        // Deleting units of the user in locked index\\n        _newCtx = _DHPTx.deleteSubscriptionInCallback(\\n            _lockedIndexId,\\n            _sender,\\n            _newCtx\\n        );\\n\\n        // console.log(\\\"Subscription deleted from index: %s\\\", _lockedIndexId);\\n\\n        // Assigning units in temporary index\\n        _newCtx = _DHPTx.updateSharesInCallback(\\n            _tokenData.tempDistIndex,\\n            _userUnits,\\n            _sender,\\n            _newCtx\\n        );\\n\\n        // console.log(\\\"Reached after share update\\\");\\n    }\\n\\n    /// Function containing actual logic to distribute DHPTx.\\n    /// This function not only distributes DHPTx but also creates a new temporary index-\\n    /// if any units were assigned in that index. A new temporary index is necessary as-\\n    /// old units can still linger which shouldn't. As batch deletion/updation of units isn't possible-\\n    /// on chain, a new index creation is the only way to go.\\n    /// @param _dHedgePool Struct containing details regarding the pool and various tokens in it.\\n    /// @param _tokenData Struct containing all the relevant details for a deposit token.\\n    /// @param _DHPTx Address of the supertoken corresponding to the DHPT of the dHEDGE pool.\\n    /// @param _permDistIndex ID of the permanent distribution index which contains the locked DHPT-\\n    /// and need distribution.\\n    /// @param _tempDistIndex ID of the temporary distribution index which may contain locked DHPT.\\n    function _distribute(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        dHedgeStorage.TokenData storage _tokenData,\\n        ISuperToken _DHPTx,\\n        uint32 _permDistIndex,\\n        uint32 _tempDistIndex\\n    ) private {\\n        uint256 _totalDistAmount = _tokenData.distAmount;\\n        uint256 _tempDistAmount = _tokenData.tempDistAmount;\\n\\n        // console.log(\\n        //     \\\"Dist amount: %s, Temp amount: %s\\\",\\n        //     _totalDistAmount,\\n        //     _tempDistAmount\\n        // );\\n\\n        // Actual distribution amount corresponding to the permanent distribution index is-\\n        // the difference of total distribution amount and temporary index's distribution amount.\\n        uint256 _actualPermDistAmount = _totalDistAmount - _tempDistAmount;\\n\\n        delete _tokenData.distAmount;\\n\\n        // If actual permanent distribution amount is greater than 0 only then initiate a distribution-\\n        // corresponding to the permanent distribution index. This condition will not be satisfied in case-\\n        /// everyone subscribed to that index either updates or terminates their stream when that index was locked.\\n        if (_actualPermDistAmount != 0) {\\n            // console.log(\\\"Perm dist index: %s\\\", _permDistIndex);\\n            _DHPTx.distribute(_permDistIndex, _actualPermDistAmount);\\n        }\\n\\n        // Only if there are any tokens to be distributed using temporary distribution index-\\n        // should we initiate a distribution and create a new temporary index.\\n        if (_tempDistAmount != 0) {\\n            // console.log(\\\"Temporary dist index: %s\\\", _tempDistIndex);\\n\\n            delete _tokenData.tempDistAmount;\\n\\n            _DHPTx.distribute(_tempDistIndex, _tempDistAmount);\\n\\n            // Initiate new temporary index creation.\\n            _createTempIndex(_dHedgePool, _tokenData, _DHPTx);\\n        }\\n    }\\n\\n    /// Function which creates a new temporary index.\\n    /// @param _dHedgePool Struct containing details regarding the pool and various tokens in it.\\n    /// @param _tokenData Struct containing all the relevant details for a deposit token.\\n    /// @param _DHPTx Address of the supertoken corresponding to the DHPT of the dHEDGE pool.\\n    function _createTempIndex(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        dHedgeStorage.TokenData storage _tokenData,\\n        ISuperToken _DHPTx\\n    ) private {\\n        uint32 _latestDistIndex = _dHedgePool.latestDistIndex;\\n\\n        // Create new temporary index.\\n        _DHPTx.createIndex(_latestDistIndex);\\n\\n        // Store the index Id of the temporary index.\\n        _tokenData.tempDistIndex = _latestDistIndex;\\n\\n        // Increase total indices count.\\n        ++_dHedgePool.latestDistIndex;\\n\\n        // console.log(\\\"Created new temp index: %s\\\", _latestDistIndex);\\n    }\\n\\n    /// Function to upgrade DHPT to DHPTx.\\n    /// This function only upgrades DHPT to DHPTx in case there is some amount of DHPT (of course \\ud83d\\ude42),\\n    /// and if DHPT is unlocked or cooldown period is inactive. Otherwise, does nothing.\\n    /// @param _poolLogic Address of the dHEDGE pool into which deposition should happen.\\n    /// @param _DHPTx Address of the supertoken corresponding to the DHPT of the dHEDGE pool.\\n    function _upgradeDHPTx(IPoolLogic _poolLogic, ISuperToken _DHPTx) private {\\n        uint256 _underlyingTokenBalance = IERC20Mod(address(_poolLogic))\\n            .balanceOf(address(this));\\n\\n        // console.log(\\n        //     \\\"Underlying token: %s, Remaining time: %s\\\",\\n        //     _underlyingTokenBalance,\\n        //     _poolLogic.getExitRemainingCooldown(address(this))\\n        // );\\n\\n        if (\\n            _poolLogic.getExitRemainingCooldown(address(this)) == 0 &&\\n            _underlyingTokenBalance > 0\\n        ) {\\n            _DHPTx.upgrade(_underlyingTokenBalance);\\n        }\\n    }\\n\\n    /// Function to calculate total units of an index ID and a user's unit amount in that index.\\n    /// @param _DHPTx Address of the supertoken corresponding to the DHPT of the dHEDGE pool.\\n    /// @param _indexId ID of the index for which calculations need to be done.\\n    /// @param _sender Address of the user for whom amount of units in that index needs to be fetched.\\n    /// @return Total number of units in the index.\\n    /// @return User's units in the index.\\n    function _getUnits(\\n        ISuperToken _DHPTx,\\n        uint32 _indexId,\\n        address _sender\\n    ) private view returns (uint128, uint128) {\\n        (, , uint128 _userUnits, ) = _DHPTx.getSubscription(_indexId, _sender);\\n\\n        (\\n            ,\\n            ,\\n            uint128 _totalIndexApprovedUnits,\\n            uint128 _totalIndexPendingUnits\\n        ) = _DHPTx.getIndex(_indexId);\\n\\n        // Total number of units is equal to total number of approved units plus total number of pending units.\\n        return (_totalIndexApprovedUnits + _totalIndexPendingUnits, _userUnits);\\n    }\\n\\n    /// Function which fetches amount of underlying tokens to be deposited into the dHEDGE pool.\\n    /// As there are two permanent indices, it's necessary to deposit amount of tokens corresponding-\\n    /// to any one index and not both.\\n    /// @param _DHPTx Address of the supertoken corresponding to the DHPT of the dHEDGE pool.\\n    /// @param _currDistIndex Index for which the deposit amount is needed to be calculated.\\n    /// @param _permDistIndex1 Index ID of the first permanent index.\\n    /// @param _permDistIndex2 Index ID of the second permanent index.\\n    /// @param _superTokenBalance Amount of supertoken already in the core contract.\\n    function _getSuperTokenDepositBalance(\\n        ISuperToken _DHPTx,\\n        uint32 _currDistIndex,\\n        uint32 _permDistIndex1,\\n        uint32 _permDistIndex2,\\n        uint256 _superTokenBalance\\n    ) private view returns (uint256) {\\n        // Calculate and downgrade amount necessary for deposition in dHEDGE pool.\\n        (\\n            ,\\n            ,\\n            uint128 _totalIndexApprovedUnits1,\\n            uint128 _totalIndexPendingUnits1\\n        ) = _DHPTx.getIndex(_permDistIndex1);\\n\\n        (\\n            ,\\n            ,\\n            uint128 _totalIndexApprovedUnits2,\\n            uint128 _totalIndexPendingUnits2\\n        ) = _DHPTx.getIndex(_permDistIndex2);\\n\\n        uint128 _totalIndexUnits1 = _totalIndexApprovedUnits1 +\\n            _totalIndexPendingUnits1;\\n\\n        uint128 _totalIndexUnits2 = _totalIndexApprovedUnits2 +\\n            _totalIndexPendingUnits2;\\n\\n        // console.log(\\n        //     \\\"Total index units 1 and 2: %s, %s\\\",\\n        //     _totalIndexUnits1,\\n        //     _totalIndexUnits2\\n        // );\\n\\n        return\\n            ((\\n                (_currDistIndex == _permDistIndex1)\\n                    ? _totalIndexUnits1\\n                    : _totalIndexUnits2\\n            ) * _superTokenBalance) / (_totalIndexUnits1 + _totalIndexUnits2);\\n    }\\n}\\n\",\"keccak256\":\"0xf5d098682787aa0e6c36151e2fea677bec9e4f2211efdd8cd21d3cb16fcc3f1c\",\"license\":\"Unlicensed\"},\"contracts/dHedge-Factory-Version/Libraries/dHedgeMath.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.10;\\n\\nimport { IERC20Mod } from \\\"../../Common/IERC20Mod.sol\\\";\\nimport \\\"./dHedgeStorage.sol\\\";\\nimport \\\"../../Common/SFHelper.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary dHedgeMath {\\n    using SFHelper for ISuperToken;\\n\\n    /// Function to calculate buffer transfer amount before stream creation/updation.\\n    /// @param _dHedgePool Struct containing details regarding the pool and various tokens in it.\\n    /// @param _user Address of the user whose buffer transfer amount needs to be calculated.\\n    /// @param _superToken The supertoken address whose stream needs to be created/updated.\\n    /// @param _streamAction The type of stream modification (creation -> 1 and updation -> 2).\\n    /// @param _delay Useful in case transaction times are high as extra allowance can be taken.\\n    /// @param _flowRate Flow rate of the stream to be created/updated.\\n    /// @return The upfront fee to be taken or returned.\\n    /// @return Boolean representing if the upfront fee is taken or returned.\\n    function calcBufferTransferAmount(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        address _user,\\n        ISuperToken _superToken,\\n        uint8 _streamAction,\\n        uint64 _delay,\\n        int96 _flowRate\\n    ) public view returns (uint256, bool) {\\n        address _underlyingToken = _superToken.getUnderlyingToken();\\n        dHedgeStorage.TokenData storage tokenData = _dHedgePool.tokenData[\\n            _underlyingToken\\n        ];\\n        uint256 _userUninvestedAmount = calcUserUninvested(\\n            _dHedgePool,\\n            _user,\\n            _superToken,\\n            _delay\\n        );\\n\\n        // If a new stream needs to be created, calculate the buffer transfer amount required.\\n        // In this case, amount is transferred from the user.\\n        if (_streamAction == 1) {\\n            // Select the active index.\\n            dHedgeStorage.PermIndexData storage index = (tokenData\\n                .lockedIndexId == tokenData.permDistIndex1.indexId)\\n                ? tokenData.permDistIndex2\\n                : tokenData.permDistIndex1;\\n\\n            // `_isTaken` value can be both true and false.\\n            // True if the user is not the first streamer and-\\n            // false in case the user is the first streamer.\\n            if (index.lastDepositAt == 0) return (0, false);\\n\\n            return\\n                _calcBufferTransferAmount(\\n                    index.lastDepositAt,\\n                    _delay,\\n                    _flowRate,\\n                    _userUninvestedAmount\\n                );\\n        } else if (_streamAction == 2) {\\n            // If an existing stream is to be updated, the calculations are slightly different.\\n            // Upfront fee may be taken (in case new stream rate is > old stream rate) from the user or-\\n            // upfront fee may be returned (in case new stream rate < old stream rate).\\n\\n            dHedgeStorage.PermIndexData storage currActiveIndex;\\n\\n            // If distribution hasn't happened for the previous cycle then, select the unlocked index.\\n            // Else, select the assigned index of the user as the active index.\\n            // This is because the DHPT locked in the latest cycle has already been deposited and in such a-\\n            // case, index migration isn't necessary.\\n            if (tokenData.distAmount != 0) {\\n                currActiveIndex = (tokenData.lockedIndexId ==\\n                    tokenData.permDistIndex1.indexId)\\n                    ? tokenData.permDistIndex2\\n                    : tokenData.permDistIndex1;\\n\\n                // If the unlocked index has no streamers, no upfront fee should be taken.\\n                // Calculation for the same should consider `lastDepositAt` = `block.timestamp`.\\n                if (currActiveIndex.lastDepositAt == 0) {\\n                    return (_userUninvestedAmount, false);\\n                }\\n            } else {\\n                currActiveIndex = (tokenData.assignedIndex[_user] ==\\n                    tokenData.permDistIndex1.indexId)\\n                    ? tokenData.permDistIndex1\\n                    : tokenData.permDistIndex2;\\n            }\\n\\n            return\\n                _calcBufferTransferAmount(\\n                    currActiveIndex.lastDepositAt,\\n                    _delay,\\n                    _flowRate,\\n                    _userUninvestedAmount\\n                );\\n        } else {\\n            revert(\\\"dHedgeHelper: Invalid stream action\\\");\\n        }\\n    }\\n\\n    /// Function to calculate uninvested amount of a user to return that after stream updation/termination.\\n    /// @param _dHedgePool Struct containing details regarding the pool and various tokens in it.\\n    /// @param _user Address of the user whose uninvested amount has to be calculated.\\n    /// @param _superToken Address of the underlying token (deposit token and not the supertoken).\\n    /// @return Amount representing user's uninvested amount.\\n    function calcUserUninvested(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        address _user,\\n        ISuperToken _superToken,\\n        uint64 _delay\\n    ) public view returns (uint256) {\\n        /// @dev Note: when no streams are present then tokenData[_depositToken] returns null address.\\n        dHedgeStorage.TokenData storage tokenData = _dHedgePool.tokenData[\\n            _superToken.getUnderlyingToken()\\n        ];\\n\\n        if (address(tokenData.superToken) == address(0)) return 0;\\n\\n        (\\n            ,\\n            /* uint256 _userPrevUpdateTimestamp */\\n            int96 _flowRate\\n        ) = _superToken.getFlow(_user);\\n        uint256 _userFlowRate = uint256(uint96(_flowRate));\\n\\n        return\\n            _userFlowRate *\\n            (block.timestamp + _delay -\\n                (\\n                    (tokenData.assignedIndex[_user] ==\\n                        tokenData.permDistIndex1.indexId)\\n                        ? tokenData.permDistIndex1.lastDepositAt\\n                        : tokenData.permDistIndex2.lastDepositAt\\n                ));\\n    }\\n\\n    function _calcBufferTransferAmount(\\n        ISuperToken _superToken,\\n        address _sender,\\n        uint64 _lastDepositAt,\\n        uint64 _delay,\\n        uint256 _userUninvested\\n    ) internal view returns (uint256 _transferAmount, bool _isTaken) {\\n        (, int96 _flowRate) = _superToken.getFlow(_sender);\\n\\n        (_transferAmount, _isTaken) = _calcBufferTransferAmount(\\n            _lastDepositAt,\\n            _delay,\\n            _flowRate,\\n            _userUninvested\\n        );\\n    }\\n\\n    function _calcBufferTransferAmount(\\n        uint64 _lastDepositAt,\\n        uint64 _delay,\\n        int96 _flowRate,\\n        uint256 _userUninvested\\n    ) internal view returns (uint256 _transferAmount, bool _isTaken) {\\n\\n        // Calculate how much amount needs to be deposited upfront.\\n        uint256 _depositAmount = (block.timestamp + _delay - _lastDepositAt) *\\n            uint256(uint96(_flowRate));\\n\\n        // If amount to be deposited is greater than user's uninvested amount then,\\n        // transfer the difference from the user.\\n        if (_depositAmount > _userUninvested) {\\n            _transferAmount = _depositAmount - _userUninvested;\\n            _isTaken = true;\\n        } else if (_depositAmount < _userUninvested) {\\n            // Else if the amount to be deposited is lesser than the uninvested amount, transfer-\\n            // the difference to the user.\\n            _transferAmount = _userUninvested - _depositAmount;\\n            _isTaken = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x317f64cb6b6911860f77819ae29659054da68f8f3ffdc777581a7307f701dd6c\",\"license\":\"Unlicensed\"},\"contracts/dHedge-Factory-Version/Libraries/dHedgeStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.10;\\n\\nimport { ISuperfluid, ISuperToken, ISuperApp, ISuperAgreement, SuperAppDefinitions } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport { IConstantFlowAgreementV1 } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\\\";\\nimport { IInstantDistributionAgreementV1 } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\\\";\\n\\n/**\\n * @title dHedge storage library.\\n * @author rashtrakoff <rashtrakoff@pm.me>\\n * @dev Contains a struct which defines a dHedge pool for a core contract.\\n * @custom:experimental This is an experimental contract/library. Use at your own risk.\\n */\\n// solhint-disable contract-name-camelcase\\n// solhint-disable var-name-mixedcase\\nlibrary dHedgeStorage {\\n    /// Struct containing details of a permanent index.\\n    /// @param isActive Indicates whether this index is active or not.\\n    /// @param indexId ID of the distribution index.\\n    struct PermIndexData {\\n        bool isActive;\\n        uint64 lastDepositAt;\\n        uint32 indexId;\\n    }\\n\\n    /// Struct containing all the necessary data related to a underlying token market.\\n    /// @param superToken Contains supported supertoken of an underlying token.\\n    /// @param permDistIndex1 First primary/permanent IDA distribution index with respect to an underlying token.\\n    /// @param permDistIndex2 Second primary/permanent IDA distribution index with respect to an underlying token.\\n    /// @param tempDistIndex Temporary IDA distribution index with respect to an underlying token.\\n    /// @param lockedIndexId Index ID of the locked index.\\n    /// @param distAmount DHPT amount to be distributed.\\n    /// @param lastDepositAt Latest timestamp of when this underlying token was deposited into a dHEDGE pool.\\n    /// @param assignedIndex A user's assigned index id. A user can be assigned to one of the two permanent- \\n    /// indices only.\\n    struct TokenData {\\n        ISuperToken superToken;\\n        PermIndexData permDistIndex1;\\n        PermIndexData permDistIndex2;\\n        uint32 tempDistIndex;\\n        uint32 lockedIndexId;\\n        uint256 distAmount;\\n        uint256 tempDistAmount;\\n        mapping(address => uint32) assignedIndex;\\n    }\\n\\n    /// Struct containing data related to a dHEDGE pool and it's corresponding core contract.\\n    /// @param isActive Status of contract representing a dHEDGE pool.\\n    /// @param DHPTx DHP super token for a dHEDGE pool.\\n    /// @param factory Factory contract which deployed the core contract.\\n    /// @param poolLogic Address of a dHEDGE pool.\\n    /// @param latestDistIndex Latest index created for distributing DHPTx according to a deposit token stream rate-\\n    /// of a user.\\n    /// @param lastDepositAt Latest timestamp of when any underlying token was deposited into a dHEDGE pool.\\n    /// @param tokenData Contains data regarding a market/deposit token.\\n    struct dHedgePool {\\n        bool isActive;\\n        ISuperToken DHPTx;\\n        address factory;\\n        address poolLogic;\\n        uint32 latestDistIndex;\\n        uint64 lastDepositAt;\\n        mapping(address => TokenData) tokenData;\\n    }\\n}\\n\",\"keccak256\":\"0x7f1bfb4f7c43f40e178b3014e9466b711612215c438da30ed1505a5180160b23\",\"license\":\"Unlicensed\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6135de61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061009d5760003560e01c8063832a95fd11610070578063832a95fd1461012c57806395f5a68d14610157578063c165d28c14610184578063d4944c2d14610197578063d6eb06d8146101b757600080fd5b806307326a0e146100a2578063394110d1146100c4578063448c5722146100e4578063565a89d01461010c575b600080fd5b8180156100ae57600080fd5b506100c26100bd366004612c79565b6101d7565b005b8180156100d057600080fd5b506100c26100df366004612c79565b610311565b6100f76100f2366004612c79565b610655565b60405190151581526020015b60405180910390f35b81801561011857600080fd5b506100c2610127366004612c79565b610742565b61013f61013a366004612ca9565b610c88565b6040516001600160a01b039091168152602001610103565b81801561016357600080fd5b50610177610172366004612d85565b610e1e565b6040516101039190612e92565b610177610192366004612ea5565b61117f565b8180156101a357600080fd5b506101776101b2366004612d85565b6112e1565b8180156101c357600080fd5b506101776101d2366004612d85565b6116cd565b6001600160a01b038082166000908152600384016020526040902083546002850154919261010090910481169161020f911682611925565b60048201541580159061028857506040516370a0823160e01b81523060048201526001600160a01b038216906370a0823190602401602060405180830381865afa158015610261573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102859190612f10565b15155b6102e75760405162461bcd60e51b815260206004820152602560248201527f64486564676548656c7065723a204e6f20616d6f756e7420746f206469737472604482015264696275746560d81b60648201526084015b60405180910390fd5b600382015461030b9085908490849063ffffffff600160201b820481169116611a6d565b50505050565b6001600160a01b03818116600090815260038401602052604090206002840154815485549293828116939181169261010090920416906103649085908790600160c01b90046001600160401b0316611bdd565b801561037557506103758686610655565b6103cc5760405162461bcd60e51b815260206004820152602260248201527f64486564676548656c7065723a204465706f736974206e6f7420726571756972604482015261195960f21b60648201526084016102de565b60038401546001850154600286015463ffffffff600160201b909304831692600160481b92839004811692909104166104058685611925565b60048701541561042b57600387015461042b908a9089908790879063ffffffff16611a6d565b8163ffffffff168363ffffffff1614801561044a5750600287015460ff165b156104575780925061047f565b8063ffffffff168363ffffffff161480156104765750600187015460ff165b1561047f578192505b6040516370a0823160e01b81523060048201526000906104fb9086908690869086906001600160a01b038c16906370a0823190602401602060405180830381865afa1580156104d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f69190612f10565b611dc6565b90508015610649576040516308de640f60e11b8152600481018290526001600160a01b038716906311bcc81e90602401600060405180830381600087803b15801561054557600080fd5b505af1158015610559573d6000803e3d6000fd5b50505060018b0154610579915089908b906001600160a01b03168a611f5f565b600388015463ffffffff858116600160201b90920416146105b65760038801805467ffffffff000000001916600160201b63ffffffff8716021790555b8263ffffffff168463ffffffff16146105f9576002880180546001600160401b03429081166101000268ffffffffffffffff001990921691909117909155610625565b6001880180546001600160401b03429081166101000268ffffffffffffffff0019909216919091179091555b5060028a0180546001600160c01b0316600160c01b426001600160401b0316021790555b50505050505050505050565b600282015460408051630f28525360e11b815290516000926001600160a01b03169183918391631e50a4a69160048083019260209291908290030181865afa1580156106a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c99190612f29565b60405163bdbef07d60e01b81526001600160a01b0386811660048301529192509082169063bdbef07d90602401602060405180830381865afa158015610713573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107379190612f5b565b925050505b92915050565b6000816001600160a01b031663ee719bc86040518163ffffffff1660e01b8152600401602060405180830381865afa158015610782573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107a69190612f29565b6001600160a01b03808216600090815260038601602090815260409182902060028801548351630f28525360e11b815293519596509094931692631e50a4a69260048082019392918290030181865afa158015610807573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061082b9190612f29565b60405163bdbef07d60e01b81526001600160a01b038481166004830152919091169063bdbef07d90602401602060405180830381865afa158015610873573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108979190612f5b565b6108e35760405162461bcd60e51b815260206004820152601f60248201527f64486564676548656c7065723a204e6f74206465706f7369742061737365740060448201526064016102de565b80546001600160a01b0316156109475760405162461bcd60e51b815260206004820152602360248201527f64486564676548656c7065723a20546f6b656e20616c72656164792070726573604482015262195b9d60ea1b60648201526084016102de565b60028401546001828101805463ffffffff60481b1916600160a01b90930463ffffffff16600160481b8102939093179055610983908290612f8c565b6002808401805463ffffffff93909316600160481b0263ffffffff60481b19909316929092179091556109b7908290612f8c565b60038301805463ffffffff191663ffffffff929092169190911790556109de816001612f8c565b6003838101805467ffffffff000000001916600160201b63ffffffff9485160217905560028701805491929091601491610a22918591600160a01b90910416612f8c565b825463ffffffff91821661010093840a908102920219161790915583546001600160a01b038088166001600160a01b0319909216919091178555875460405163e2f519ed60e01b815260009450735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e679363e2f519ed93610a9f939190910416908690600401612fb4565b600060405180830381865af4158015610abc573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610ae49190810190612fd3565b8654909150735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e679063e2f519ed9061010090046001600160a01b0316610b1e856001612f8c565b6040518363ffffffff1660e01b8152600401610b3b929190612fb4565b600060405180830381865af4158015610b58573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610b809190810190612fd3565b8654909150735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e679063e2f519ed9061010090046001600160a01b0316610bba856002612f8c565b6040518363ffffffff1660e01b8152600401610bd7929190612fb4565b600060405180830381865af4158015610bf4573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610c1c9190810190612fd3565b6002870154909150610c3d906001600160a01b0386811691166000196121b3565b604080516001600160a01b038088168252861660208201527f34293bf68a0d76c882805a7daa8b1f91b2acfdcdf710b3891b4c0a4de9daf050910160405180910390a1505050505050565b805460009060ff1615610e1657600282015460408051630f28525360e11b815290516001600160a01b03909216916000918391631e50a4a6916004808201926020929091908290030181865afa158015610ce6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d0a9190612f29565b90506000816001600160a01b031663fc43863f6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610d4c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610d749190810190613049565b905060005b81518160ff161015610e1157818160ff1681518110610d9a57610d9a6130fa565b602002602001015194506000866003016000876001600160a01b03166001600160a01b031681526020019081526020016000209050610df181878960020160189054906101000a90046001600160401b0316611bdd565b15610e00575050505050919050565b50610e0a81613110565b9050610d79565b505050505b506000919050565b6060829050600080516020613589833981519152856001600160a01b0316637730599e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e70573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e949190612f10565b0361117557600084806020019051810190610eaf919061312f565b5090506000876001600160a01b031663ee719bc86040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ef2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f169190612f29565b6001600160a01b03818116600090815260038c81016020908152604083208e54928101548a51969750909561010090930490941693600160201b900463ffffffff169291610f6b91908a018101908a01612f10565b90506000846004015460001461104e57600185015463ffffffff848116600160481b9092041614610f9f5784600101610fa4565b846002015b805490915060ff16610fd55780546001600160401b0342166101000268ffffffffffffffffff199091161760011781555b6001600160a01b038716600090815260068601602052604090205463ffffffff8085169116036110495761100b8585898b612298565b81546001600160a01b038916600090815260068801602052604090208054600160481b90920463ffffffff1663ffffffff1990921691909117905597505b611095565b60018501546001600160a01b038816600090815260068701602052604090205463ffffffff908116600160481b909204161461108d5784600201611092565b846001015b90505b805461010090046001600160401b0316156110c85780546110c8908e90899061010090046001600160401b0316856124a0565b8c6001600160a01b0316735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e6763c833a5419091868460000160099054906101000a900463ffffffff168b8d6040518663ffffffff1660e01b815260040161112695949392919061315e565b600060405180830381865af4158015611143573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261116b9190810190612fd3565b9750505050505050505b9695505050505050565b60408051600081526020808201808452633b982ccf60e11b905291519091600080516020613589833981519152916001600160a01b03861691637730599e9160248087019291908188030181865afa1580156111df573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112039190612f10565b036112d95760008280602001905181019061121e919061312f565b506040516360727ba360e01b8152600481018890526001600160a01b038083166024830152871660448201526000606482015290915073F99faF12Efe98C6B67a4a96cBB5265af846d6319906360727ba390608401602060405180830381865af4158015611290573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112b49190612f10565b6040516020016112c691815260200190565b6040516020818303038152906040529150505b949350505050565b6060829050600080516020613589833981519152856001600160a01b0316637730599e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611333573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113579190612f10565b0361117557600084806020019051810190611372919061312f565b5090506000876001600160a01b031663ee719bc86040518163ffffffff1660e01b8152600401602060405180830381865afa1580156113b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113d99190612f29565b6001600160a01b03808216600090815260038c016020908152604080832093871683526006840182528220548851949550929363ffffffff90931692611426919089018101908901612f10565b905082600401546000141580156114505750600383015463ffffffff838116600160201b90920416145b15611479578b5461147290849061010090046001600160a01b03168789612298565b9550611599565b8b5460009081906114999061010090046001600160a01b03168589612677565b8f54604051630feead9160e01b8152929450909250735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e6791630feead91916114ec916101009091046001600160a01b03169088908c908e9060040161319e565b600060405180830381865af4158015611509573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526115319190810190612fd3565b9750806001600160801b0316826001600160801b03160361159657600185015463ffffffff600160481b9091048116908516036115815760018501805468ffffffffffffffffff19169055611596565b60028501805468ffffffffffffffffff191690555b50505b6001600160a01b03858116600090815260068501602052604090819020805463ffffffff19169055516370a0823160e01b8152306004820152908c16906370a0823190602401602060405180830381865afa1580156115fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116209190612f10565b81111561162f5761162f6131d6565b60405163a9059cbb60e01b81526001600160a01b038681166004830152602482018390528c169063a9059cbb906044016020604051808303816000875af115801561167e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116a29190612f5b565b6116be5760405162461bcd60e51b81526004016102de906131ec565b50505050509695505050505050565b6060829050600080516020613589833981519152856001600160a01b0316637730599e6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561171f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117439190612f10565b036111755760008480602001905181019061175e919061312f565b5090506000876001600160a01b031663ee719bc86040518163ffffffff1660e01b8152600401602060405180830381865afa1580156117a1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117c59190612f29565b6001600160a01b0380821660009081526003808d01602052604082208d54600182015492820154959650909461010090910490931692600160201b900463ffffffff908116600160481b90920416146118215782600101611826565b826002015b905060008780602001905181019061183e9190612f10565b825490915060ff1661186f5781546001600160401b0342166101000268ffffffffffffffffff199091161760011782555b81546001600160a01b038716600090815260068601602052604090208054600160481b90920463ffffffff1663ffffffff1990921682179055825461010090046001600160401b0316156118db5782546118db908e90899061010090046001600160401b0316856124a0565b8c6001600160a01b0316735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e6763c833a541909186848b8d6040518663ffffffff1660e01b815260040161112695949392919061315e565b6040516370a0823160e01b81523060048201526000906001600160a01b038416906370a0823190602401602060405180830381865afa15801561196c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119909190612f10565b604051635c7515b760e11b81523060048201529091506001600160a01b0384169063b8ea2b6e90602401602060405180830381865afa1580156119d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119fb9190612f10565b158015611a085750600081115b15611a68576040516345977d0360e01b8152600481018290526001600160a01b038316906345977d0390602401600060405180830381600087803b158015611a4f57600080fd5b505af1158015611a63573d6000803e3d6000fd5b505050505b505050565b600484015460058501546000611a838284613230565b6000600489015590508015611b275760405163422fb96560e01b81526001600160a01b038716600482015263ffffffff8616602482015260448101829052735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e679063422fb96590606401600060405180830381865af4158015611afd573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611b259190810190612fd3565b505b8115611bd3576000600588015560405163422fb96560e01b81526001600160a01b038716600482015263ffffffff8516602482015260448101839052735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e679063422fb96590606401600060405180830381865af4158015611b9f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611bc79190810190612fd3565b50611bd38888886127bc565b5050505050505050565b600080611bf36001600160401b03841642613230565b85549091506001600160a01b031615801590611c215750600185015460ff1680611c215750600285015460ff165b8015611c3b5750610384811080611c3b5750620151808110155b8015611cb057506002850154600186015462015180916001600160401b036101009182900481169190920490911611611c8657600286015461010090046001600160401b0316611c9a565b600186015461010090046001600160401b03165b611cad906001600160401b031642613230565b10155b15611db9576000846001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015611cf5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d199190613247565b611d2490601261326a565b611d2f90600a613371565b86546040516370a0823160e01b81523060048201526001600160a01b03909116906370a0823190602401602060405180830381865afa158015611d76573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d9a9190612f10565b611da49190613380565b90508015611db757600192505050611dbf565b505b60009150505b9392505050565b60405163941533d160e01b815260009081908190735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e679063941533d190611e0f906001600160a01b038c16908a90600401612fb4565b608060405180830381865af4158015611e2c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e5091906133b9565b60405163941533d160e01b8152919550935060009250829150735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e679063941533d190611e9e906001600160a01b038e16908b90600401612fb4565b608060405180830381865af4158015611ebb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611edf91906133b9565b93509350505060008385611ef3919061340d565b90506000611f01838561340d565b9050611f0d818361340d565b6001600160801b0316888b63ffffffff168d63ffffffff1614611f305782611f32565b835b6001600160801b0316611f45919061342f565b611f4f9190613380565b9c9b505050505050505050505050565b6040516370a0823160e01b81523060048201526000906001600160a01b038516906370a0823190602401602060405180830381865afa158015611fa6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611fca9190612f10565b905080156121ac576000620f4240846001600160a01b03166307d334556040518163ffffffff1660e01b8152600401602060405180830381865afa158015612016573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061203a919061344e565b61204a9063ffffffff168461342f565b6120549190613380565b90506120608183613230565b915080156120de576120de846001600160a01b0316634162169f6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156120a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120cd9190612f29565b6001600160a01b03871690836128b5565b6040516311f9fbc960e21b81526001600160a01b03868116600483015260248201849052600091908516906347e7ef24906044016020604051808303816000875af1158015612131573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121559190612f10565b60048801819055604080516001600160a01b0389168152602081018690529081018290529091507f1c83e520720711a18cf486e7e5a403bad3f020deb71d3326a4bbf507260e365f9060600160405180910390a150505b5050505050565b604051636eb1769f60e11b81523060048201526001600160a01b038381166024830152600091839186169063dd62ed3e90604401602060405180830381865afa158015612204573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122289190612f10565b6122329190613474565b6040516001600160a01b03851660248201526044810182905290915061030b90859063095ea7b360e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526128e5565b60038401548190600160201b900463ffffffff166000806122ba878488612677565b91509150600088600501549050826001600160801b0316818a600401546122e19190613230565b6122f4906001600160801b03851661342f565b6122fe9190613380565b6123089082613474565b60058a0181905590506001600160801b038083169084160361236e57600189015463ffffffff600160481b9091048116908516036123595760018901805468ffffffffffffffffff1916905561236e565b60028901805468ffffffffffffffffff191690555b604051630feead9160e01b8152735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e6790630feead91906123b4906001600160a01b038c169088908c908b9060040161319e565b600060405180830381865af41580156123d1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526123f99190810190612fd3565b60038a0154604051630766114b60e41b8152919650735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e679163766114b09161244e916001600160a01b038d169163ffffffff169087908d908c9060040161348c565b600060405180830381865af415801561246b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526124939190810190612fd3565b9998505050505050505050565b6000806124b96001600160a01b038716868684876129b7565b909250905060008215611a63578115612598576040516323b872dd60e01b81526001600160a01b038781166004830152306024830152604482018590528816906323b872dd906064016020604051808303816000875af1158015612521573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125459190612f5b565b604080516001600160a01b03808b168252891660208201529081018590529091507f09199028cbad9c6987f6e325ed3291b549e78f64d50df63b8cb1150346ff9b819060600160405180910390a161265a565b60405163a9059cbb60e01b81526001600160a01b0387811660048301526024820185905288169063a9059cbb906044016020604051808303816000875af11580156125e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061260b9190612f5b565b604080516001600160a01b03808b168252891660208201529081018590529091507f7466903e0f222a6c028b119e8e9c819adda5c0c0e021277120ecf22b894dccc49060600160405180910390a15b80611a635760405162461bcd60e51b81526004016102de906131ec565b60405163132ad30f60e21b81526001600160a01b03848116600483015263ffffffff841660248301528216604482015260009081908190735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e6790634cab4c3c90606401608060405180830381865af41580156126ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061270e91906134d3565b5060405163941533d160e01b815290935060009250829150735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e679063941533d19061275b906001600160a01b038c16908b90600401612fb4565b608060405180830381865af4158015612778573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061279c91906133b9565b93509350505080826127ae919061340d565b989297509195505050505050565b600283015460405163e2f519ed60e01b8152600160a01b90910463ffffffff1690735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e679063e2f519ed90612812906001600160a01b038616908590600401612fb4565b600060405180830381865af415801561282f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526128579190810190612fd3565b5060038301805463ffffffff191663ffffffff83811691909117909155600285018054909160149161289191600160a01b9091041661351e565b91906101000a81548163ffffffff021916908363ffffffff16021790555050505050565b6040516001600160a01b038316602482015260448101829052611a6890849063a9059cbb60e01b90606401612261565b600061293a826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316612a5f9092919063ffffffff16565b805190915015611a6857808060200190518101906129589190612f5b565b611a685760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016102de565b604051638cca42b560e01b81526001600160a01b0386811660048301528516602482015260009081908190735cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e6790638cca42b5906044016040805180830381865af4158015612a1d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a419190613541565b915050612a5086868387612a6e565b90999098509650505050505050565b60606112d98484600085612af7565b6000806000846bffffffffffffffffffffffff16876001600160401b0316876001600160401b031642612aa19190613474565b612aab9190613230565b612ab5919061342f565b905083811115612ad457612ac98482613230565b925060019150612aed565b83811015612aed57612ae68185613230565b9250600091505b5094509492505050565b606082471015612b585760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084016102de565b6001600160a01b0385163b612baf5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016102de565b600080866001600160a01b03168587604051612bcb919061356c565b60006040518083038185875af1925050503d8060008114612c08576040519150601f19603f3d011682016040523d82523d6000602084013e612c0d565b606091505b5091509150612c1d828286612c28565b979650505050505050565b60608315612c37575081611dbf565b825115612c475782518084602001fd5b8160405162461bcd60e51b81526004016102de9190612e92565b6001600160a01b0381168114612c7657600080fd5b50565b60008060408385031215612c8c57600080fd5b823591506020830135612c9e81612c61565b809150509250929050565b600060208284031215612cbb57600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715612d0057612d00612cc2565b604052919050565b60006001600160401b03821115612d2157612d21612cc2565b50601f01601f191660200190565b600082601f830112612d4057600080fd5b8135612d53612d4e82612d08565b612cd8565b818152846020838601011115612d6857600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060008060c08789031215612d9e57600080fd5b863595506020870135612db081612c61565b94506040870135612dc081612c61565b935060608701356001600160401b0380821115612ddc57600080fd5b612de88a838b01612d2f565b94506080890135915080821115612dfe57600080fd5b612e0a8a838b01612d2f565b935060a0890135915080821115612e2057600080fd5b50612e2d89828a01612d2f565b9150509295509295509295565b60005b83811015612e55578181015183820152602001612e3d565b8381111561030b5750506000910152565b60008151808452612e7e816020860160208601612e3a565b601f01601f19169290920160200192915050565b602081526000611dbf6020830184612e66565b60008060008060808587031215612ebb57600080fd5b843593506020850135612ecd81612c61565b92506040850135612edd81612c61565b915060608501356001600160401b03811115612ef857600080fd5b612f0487828801612d2f565b91505092959194509250565b600060208284031215612f2257600080fd5b5051919050565b600060208284031215612f3b57600080fd5b8151611dbf81612c61565b80518015158114612f5657600080fd5b919050565b600060208284031215612f6d57600080fd5b611dbf82612f46565b634e487b7160e01b600052601160045260246000fd5b600063ffffffff808316818516808303821115612fab57612fab612f76565b01949350505050565b6001600160a01b0392909216825263ffffffff16602082015260400190565b600060208284031215612fe557600080fd5b81516001600160401b03811115612ffb57600080fd5b8201601f8101841361300c57600080fd5b805161301a612d4e82612d08565b81815285602083850101111561302f57600080fd5b613040826020830160208601612e3a565b95945050505050565b6000602080838503121561305c57600080fd5b82516001600160401b038082111561307357600080fd5b818501915085601f83011261308757600080fd5b81518181111561309957613099612cc2565b8060051b91506130aa848301612cd8565b81815291830184019184810190888411156130c457600080fd5b938501935b838510156130ee57845192506130de83612c61565b82825293850193908501906130c9565b98975050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060ff821660ff810361312657613126612f76565b60010192915050565b6000806040838503121561314257600080fd5b825161314d81612c61565b6020840151909250612c9e81612c61565b6001600160a01b038681168252858116602083015263ffffffff851660408301528316606082015260a060808201819052600090612c1d90830184612e66565b6001600160a01b03858116825263ffffffff851660208301528316604082015260806060820181905260009061117590830184612e66565b634e487b7160e01b600052600160045260246000fd5b60208082526024908201527f64486564676548656c7065723a20427566666572207472616e736665722066616040820152631a5b195960e21b606082015260800190565b60008282101561324257613242612f76565b500390565b60006020828403121561325957600080fd5b815160ff81168114611dbf57600080fd5b600060ff821660ff84168082101561328457613284612f76565b90039392505050565b600181815b808511156132c85781600019048211156132ae576132ae612f76565b808516156132bb57918102915b93841c9390800290613292565b509250929050565b6000826132df5750600161073c565b816132ec5750600061073c565b8160018114613302576002811461330c57613328565b600191505061073c565b60ff84111561331d5761331d612f76565b50506001821b61073c565b5060208310610133831016604e8410600b841016171561334b575081810a61073c565b613355838361328d565b806000190482111561336957613369612f76565b029392505050565b6000611dbf60ff8416836132d0565b60008261339d57634e487b7160e01b600052601260045260246000fd5b500490565b80516001600160801b0381168114612f5657600080fd5b600080600080608085870312156133cf57600080fd5b6133d885612f46565b93506133e6602086016133a2565b92506133f4604086016133a2565b9150613402606086016133a2565b905092959194509250565b60006001600160801b03808316818516808303821115612fab57612fab612f76565b600081600019048311821515161561344957613449612f76565b500290565b60006020828403121561346057600080fd5b815163ffffffff81168114611dbf57600080fd5b6000821982111561348757613487612f76565b500190565b6001600160a01b03868116825263ffffffff861660208301526001600160801b03851660408301528316606082015260a060808201819052600090612c1d90830184612e66565b600080600080608085870312156134e957600080fd5b6134f285612f46565b935061350060208601612f46565b925061350e604086016133a2565b6060959095015193969295505050565b600063ffffffff80831681810361353757613537612f76565b6001019392505050565b6000806040838503121561355457600080fd5b82519150602083015180600b0b8114612c9e57600080fd5b6000825161357e818460208701612e3a565b919091019291505056fea9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd3a26469706673582212203e85a0c371c24a9d1f1bcb8ef8ea263054ba30c4eda19bd4e6cbefc6e78897eb64736f6c634300080d0033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061009d5760003560e01c8063832a95fd11610070578063832a95fd1461012c57806395f5a68d14610157578063c165d28c14610184578063d4944c2d14610197578063d6eb06d8146101b757600080fd5b806307326a0e146100a2578063394110d1146100c4578063448c5722146100e4578063565a89d01461010c575b600080fd5b8180156100ae57600080fd5b506100c26100bd366004612c79565b6101d7565b005b8180156100d057600080fd5b506100c26100df366004612c79565b610311565b6100f76100f2366004612c79565b610655565b60405190151581526020015b60405180910390f35b81801561011857600080fd5b506100c2610127366004612c79565b610742565b61013f61013a366004612ca9565b610c88565b6040516001600160a01b039091168152602001610103565b81801561016357600080fd5b50610177610172366004612d85565b610e1e565b6040516101039190612e92565b610177610192366004612ea5565b61117f565b8180156101a357600080fd5b506101776101b2366004612d85565b6112e1565b8180156101c357600080fd5b506101776101d2366004612d85565b6116cd565b6001600160a01b038082166000908152600384016020526040902083546002850154919261010090910481169161020f911682611925565b60048201541580159061028857506040516370a0823160e01b81523060048201526001600160a01b038216906370a0823190602401602060405180830381865afa158015610261573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102859190612f10565b15155b6102e75760405162461bcd60e51b815260206004820152602560248201527f64486564676548656c7065723a204e6f20616d6f756e7420746f206469737472604482015264696275746560d81b60648201526084015b60405180910390fd5b600382015461030b9085908490849063ffffffff600160201b820481169116611a6d565b50505050565b6001600160a01b03818116600090815260038401602052604090206002840154815485549293828116939181169261010090920416906103649085908790600160c01b90046001600160401b0316611bdd565b801561037557506103758686610655565b6103cc5760405162461bcd60e51b815260206004820152602260248201527f64486564676548656c7065723a204465706f736974206e6f7420726571756972604482015261195960f21b60648201526084016102de565b60038401546001850154600286015463ffffffff600160201b909304831692600160481b92839004811692909104166104058685611925565b60048701541561042b57600387015461042b908a9089908790879063ffffffff16611a6d565b8163ffffffff168363ffffffff1614801561044a5750600287015460ff165b156104575780925061047f565b8063ffffffff168363ffffffff161480156104765750600187015460ff165b1561047f578192505b6040516370a0823160e01b81523060048201526000906104fb9086908690869086906001600160a01b038c16906370a0823190602401602060405180830381865afa1580156104d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f69190612f10565b611dc6565b90508015610649576040516308de640f60e11b8152600481018290526001600160a01b038716906311bcc81e90602401600060405180830381600087803b15801561054557600080fd5b505af1158015610559573d6000803e3d6000fd5b50505060018b0154610579915089908b906001600160a01b03168a611f5f565b600388015463ffffffff858116600160201b90920416146105b65760038801805467ffffffff000000001916600160201b63ffffffff8716021790555b8263ffffffff168463ffffffff16146105f9576002880180546001600160401b03429081166101000268ffffffffffffffff001990921691909117909155610625565b6001880180546001600160401b03429081166101000268ffffffffffffffff0019909216919091179091555b5060028a0180546001600160c01b0316600160c01b426001600160401b0316021790555b50505050505050505050565b600282015460408051630f28525360e11b815290516000926001600160a01b03169183918391631e50a4a69160048083019260209291908290030181865afa1580156106a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c99190612f29565b60405163bdbef07d60e01b81526001600160a01b0386811660048301529192509082169063bdbef07d90602401602060405180830381865afa158015610713573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107379190612f5b565b925050505b92915050565b6000816001600160a01b031663ee719bc86040518163ffffffff1660e01b8152600401602060405180830381865afa158015610782573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107a69190612f29565b6001600160a01b03808216600090815260038601602090815260409182902060028801548351630f28525360e11b815293519596509094931692631e50a4a69260048082019392918290030181865afa158015610807573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061082b9190612f29565b60405163bdbef07d60e01b81526001600160a01b038481166004830152919091169063bdbef07d90602401602060405180830381865afa158015610873573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108979190612f5b565b6108e35760405162461bcd60e51b815260206004820152601f60248201527f64486564676548656c7065723a204e6f74206465706f7369742061737365740060448201526064016102de565b80546001600160a01b0316156109475760405162461bcd60e51b815260206004820152602360248201527f64486564676548656c7065723a20546f6b656e20616c72656164792070726573604482015262195b9d60ea1b60648201526084016102de565b60028401546001828101805463ffffffff60481b1916600160a01b90930463ffffffff16600160481b8102939093179055610983908290612f8c565b6002808401805463ffffffff93909316600160481b0263ffffffff60481b19909316929092179091556109b7908290612f8c565b60038301805463ffffffff191663ffffffff929092169190911790556109de816001612f8c565b6003838101805467ffffffff000000001916600160201b63ffffffff9485160217905560028701805491929091601491610a22918591600160a01b90910416612f8c565b825463ffffffff91821661010093840a908102920219161790915583546001600160a01b038088166001600160a01b0319909216919091178555875460405163e2f519ed60e01b81526000945073__$d8f4c298c40046574ed00784bf1ab2bf98$__9363e2f519ed93610a9f939190910416908690600401612fb4565b600060405180830381865af4158015610abc573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610ae49190810190612fd3565b865490915073__$d8f4c298c40046574ed00784bf1ab2bf98$__9063e2f519ed9061010090046001600160a01b0316610b1e856001612f8c565b6040518363ffffffff1660e01b8152600401610b3b929190612fb4565b600060405180830381865af4158015610b58573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610b809190810190612fd3565b865490915073__$d8f4c298c40046574ed00784bf1ab2bf98$__9063e2f519ed9061010090046001600160a01b0316610bba856002612f8c565b6040518363ffffffff1660e01b8152600401610bd7929190612fb4565b600060405180830381865af4158015610bf4573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610c1c9190810190612fd3565b6002870154909150610c3d906001600160a01b0386811691166000196121b3565b604080516001600160a01b038088168252861660208201527f34293bf68a0d76c882805a7daa8b1f91b2acfdcdf710b3891b4c0a4de9daf050910160405180910390a1505050505050565b805460009060ff1615610e1657600282015460408051630f28525360e11b815290516001600160a01b03909216916000918391631e50a4a6916004808201926020929091908290030181865afa158015610ce6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d0a9190612f29565b90506000816001600160a01b031663fc43863f6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610d4c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610d749190810190613049565b905060005b81518160ff161015610e1157818160ff1681518110610d9a57610d9a6130fa565b602002602001015194506000866003016000876001600160a01b03166001600160a01b031681526020019081526020016000209050610df181878960020160189054906101000a90046001600160401b0316611bdd565b15610e00575050505050919050565b50610e0a81613110565b9050610d79565b505050505b506000919050565b6060829050600080516020613589833981519152856001600160a01b0316637730599e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e70573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e949190612f10565b0361117557600084806020019051810190610eaf919061312f565b5090506000876001600160a01b031663ee719bc86040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ef2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f169190612f29565b6001600160a01b03818116600090815260038c81016020908152604083208e54928101548a51969750909561010090930490941693600160201b900463ffffffff169291610f6b91908a018101908a01612f10565b90506000846004015460001461104e57600185015463ffffffff848116600160481b9092041614610f9f5784600101610fa4565b846002015b805490915060ff16610fd55780546001600160401b0342166101000268ffffffffffffffffff199091161760011781555b6001600160a01b038716600090815260068601602052604090205463ffffffff8085169116036110495761100b8585898b612298565b81546001600160a01b038916600090815260068801602052604090208054600160481b90920463ffffffff1663ffffffff1990921691909117905597505b611095565b60018501546001600160a01b038816600090815260068701602052604090205463ffffffff908116600160481b909204161461108d5784600201611092565b846001015b90505b805461010090046001600160401b0316156110c85780546110c8908e90899061010090046001600160401b0316856124a0565b8c6001600160a01b031673__$d8f4c298c40046574ed00784bf1ab2bf98$__63c833a5419091868460000160099054906101000a900463ffffffff168b8d6040518663ffffffff1660e01b815260040161112695949392919061315e565b600060405180830381865af4158015611143573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261116b9190810190612fd3565b9750505050505050505b9695505050505050565b60408051600081526020808201808452633b982ccf60e11b905291519091600080516020613589833981519152916001600160a01b03861691637730599e9160248087019291908188030181865afa1580156111df573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112039190612f10565b036112d95760008280602001905181019061121e919061312f565b506040516360727ba360e01b8152600481018890526001600160a01b038083166024830152871660448201526000606482015290915073__$14d7c2abfbf3780d055c6425076fcfd1dd$__906360727ba390608401602060405180830381865af4158015611290573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112b49190612f10565b6040516020016112c691815260200190565b6040516020818303038152906040529150505b949350505050565b6060829050600080516020613589833981519152856001600160a01b0316637730599e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611333573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113579190612f10565b0361117557600084806020019051810190611372919061312f565b5090506000876001600160a01b031663ee719bc86040518163ffffffff1660e01b8152600401602060405180830381865afa1580156113b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113d99190612f29565b6001600160a01b03808216600090815260038c016020908152604080832093871683526006840182528220548851949550929363ffffffff90931692611426919089018101908901612f10565b905082600401546000141580156114505750600383015463ffffffff838116600160201b90920416145b15611479578b5461147290849061010090046001600160a01b03168789612298565b9550611599565b8b5460009081906114999061010090046001600160a01b03168589612677565b8f54604051630feead9160e01b815292945090925073__$d8f4c298c40046574ed00784bf1ab2bf98$__91630feead91916114ec916101009091046001600160a01b03169088908c908e9060040161319e565b600060405180830381865af4158015611509573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526115319190810190612fd3565b9750806001600160801b0316826001600160801b03160361159657600185015463ffffffff600160481b9091048116908516036115815760018501805468ffffffffffffffffff19169055611596565b60028501805468ffffffffffffffffff191690555b50505b6001600160a01b03858116600090815260068501602052604090819020805463ffffffff19169055516370a0823160e01b8152306004820152908c16906370a0823190602401602060405180830381865afa1580156115fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116209190612f10565b81111561162f5761162f6131d6565b60405163a9059cbb60e01b81526001600160a01b038681166004830152602482018390528c169063a9059cbb906044016020604051808303816000875af115801561167e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116a29190612f5b565b6116be5760405162461bcd60e51b81526004016102de906131ec565b50505050509695505050505050565b6060829050600080516020613589833981519152856001600160a01b0316637730599e6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561171f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117439190612f10565b036111755760008480602001905181019061175e919061312f565b5090506000876001600160a01b031663ee719bc86040518163ffffffff1660e01b8152600401602060405180830381865afa1580156117a1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117c59190612f29565b6001600160a01b0380821660009081526003808d01602052604082208d54600182015492820154959650909461010090910490931692600160201b900463ffffffff908116600160481b90920416146118215782600101611826565b826002015b905060008780602001905181019061183e9190612f10565b825490915060ff1661186f5781546001600160401b0342166101000268ffffffffffffffffff199091161760011782555b81546001600160a01b038716600090815260068601602052604090208054600160481b90920463ffffffff1663ffffffff1990921682179055825461010090046001600160401b0316156118db5782546118db908e90899061010090046001600160401b0316856124a0565b8c6001600160a01b031673__$d8f4c298c40046574ed00784bf1ab2bf98$__63c833a541909186848b8d6040518663ffffffff1660e01b815260040161112695949392919061315e565b6040516370a0823160e01b81523060048201526000906001600160a01b038416906370a0823190602401602060405180830381865afa15801561196c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119909190612f10565b604051635c7515b760e11b81523060048201529091506001600160a01b0384169063b8ea2b6e90602401602060405180830381865afa1580156119d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119fb9190612f10565b158015611a085750600081115b15611a68576040516345977d0360e01b8152600481018290526001600160a01b038316906345977d0390602401600060405180830381600087803b158015611a4f57600080fd5b505af1158015611a63573d6000803e3d6000fd5b505050505b505050565b600484015460058501546000611a838284613230565b6000600489015590508015611b275760405163422fb96560e01b81526001600160a01b038716600482015263ffffffff861660248201526044810182905273__$d8f4c298c40046574ed00784bf1ab2bf98$__9063422fb96590606401600060405180830381865af4158015611afd573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611b259190810190612fd3565b505b8115611bd3576000600588015560405163422fb96560e01b81526001600160a01b038716600482015263ffffffff851660248201526044810183905273__$d8f4c298c40046574ed00784bf1ab2bf98$__9063422fb96590606401600060405180830381865af4158015611b9f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611bc79190810190612fd3565b50611bd38888886127bc565b5050505050505050565b600080611bf36001600160401b03841642613230565b85549091506001600160a01b031615801590611c215750600185015460ff1680611c215750600285015460ff165b8015611c3b5750610384811080611c3b5750620151808110155b8015611cb057506002850154600186015462015180916001600160401b036101009182900481169190920490911611611c8657600286015461010090046001600160401b0316611c9a565b600186015461010090046001600160401b03165b611cad906001600160401b031642613230565b10155b15611db9576000846001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015611cf5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d199190613247565b611d2490601261326a565b611d2f90600a613371565b86546040516370a0823160e01b81523060048201526001600160a01b03909116906370a0823190602401602060405180830381865afa158015611d76573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d9a9190612f10565b611da49190613380565b90508015611db757600192505050611dbf565b505b60009150505b9392505050565b60405163941533d160e01b81526000908190819073__$d8f4c298c40046574ed00784bf1ab2bf98$__9063941533d190611e0f906001600160a01b038c16908a90600401612fb4565b608060405180830381865af4158015611e2c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e5091906133b9565b60405163941533d160e01b815291955093506000925082915073__$d8f4c298c40046574ed00784bf1ab2bf98$__9063941533d190611e9e906001600160a01b038e16908b90600401612fb4565b608060405180830381865af4158015611ebb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611edf91906133b9565b93509350505060008385611ef3919061340d565b90506000611f01838561340d565b9050611f0d818361340d565b6001600160801b0316888b63ffffffff168d63ffffffff1614611f305782611f32565b835b6001600160801b0316611f45919061342f565b611f4f9190613380565b9c9b505050505050505050505050565b6040516370a0823160e01b81523060048201526000906001600160a01b038516906370a0823190602401602060405180830381865afa158015611fa6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611fca9190612f10565b905080156121ac576000620f4240846001600160a01b03166307d334556040518163ffffffff1660e01b8152600401602060405180830381865afa158015612016573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061203a919061344e565b61204a9063ffffffff168461342f565b6120549190613380565b90506120608183613230565b915080156120de576120de846001600160a01b0316634162169f6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156120a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120cd9190612f29565b6001600160a01b03871690836128b5565b6040516311f9fbc960e21b81526001600160a01b03868116600483015260248201849052600091908516906347e7ef24906044016020604051808303816000875af1158015612131573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121559190612f10565b60048801819055604080516001600160a01b0389168152602081018690529081018290529091507f1c83e520720711a18cf486e7e5a403bad3f020deb71d3326a4bbf507260e365f9060600160405180910390a150505b5050505050565b604051636eb1769f60e11b81523060048201526001600160a01b038381166024830152600091839186169063dd62ed3e90604401602060405180830381865afa158015612204573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122289190612f10565b6122329190613474565b6040516001600160a01b03851660248201526044810182905290915061030b90859063095ea7b360e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526128e5565b60038401548190600160201b900463ffffffff166000806122ba878488612677565b91509150600088600501549050826001600160801b0316818a600401546122e19190613230565b6122f4906001600160801b03851661342f565b6122fe9190613380565b6123089082613474565b60058a0181905590506001600160801b038083169084160361236e57600189015463ffffffff600160481b9091048116908516036123595760018901805468ffffffffffffffffff1916905561236e565b60028901805468ffffffffffffffffff191690555b604051630feead9160e01b815273__$d8f4c298c40046574ed00784bf1ab2bf98$__90630feead91906123b4906001600160a01b038c169088908c908b9060040161319e565b600060405180830381865af41580156123d1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526123f99190810190612fd3565b60038a0154604051630766114b60e41b815291965073__$d8f4c298c40046574ed00784bf1ab2bf98$__9163766114b09161244e916001600160a01b038d169163ffffffff169087908d908c9060040161348c565b600060405180830381865af415801561246b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526124939190810190612fd3565b9998505050505050505050565b6000806124b96001600160a01b038716868684876129b7565b909250905060008215611a63578115612598576040516323b872dd60e01b81526001600160a01b038781166004830152306024830152604482018590528816906323b872dd906064016020604051808303816000875af1158015612521573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125459190612f5b565b604080516001600160a01b03808b168252891660208201529081018590529091507f09199028cbad9c6987f6e325ed3291b549e78f64d50df63b8cb1150346ff9b819060600160405180910390a161265a565b60405163a9059cbb60e01b81526001600160a01b0387811660048301526024820185905288169063a9059cbb906044016020604051808303816000875af11580156125e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061260b9190612f5b565b604080516001600160a01b03808b168252891660208201529081018590529091507f7466903e0f222a6c028b119e8e9c819adda5c0c0e021277120ecf22b894dccc49060600160405180910390a15b80611a635760405162461bcd60e51b81526004016102de906131ec565b60405163132ad30f60e21b81526001600160a01b03848116600483015263ffffffff84166024830152821660448201526000908190819073__$d8f4c298c40046574ed00784bf1ab2bf98$__90634cab4c3c90606401608060405180830381865af41580156126ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061270e91906134d3565b5060405163941533d160e01b81529093506000925082915073__$d8f4c298c40046574ed00784bf1ab2bf98$__9063941533d19061275b906001600160a01b038c16908b90600401612fb4565b608060405180830381865af4158015612778573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061279c91906133b9565b93509350505080826127ae919061340d565b989297509195505050505050565b600283015460405163e2f519ed60e01b8152600160a01b90910463ffffffff169073__$d8f4c298c40046574ed00784bf1ab2bf98$__9063e2f519ed90612812906001600160a01b038616908590600401612fb4565b600060405180830381865af415801561282f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526128579190810190612fd3565b5060038301805463ffffffff191663ffffffff83811691909117909155600285018054909160149161289191600160a01b9091041661351e565b91906101000a81548163ffffffff021916908363ffffffff16021790555050505050565b6040516001600160a01b038316602482015260448101829052611a6890849063a9059cbb60e01b90606401612261565b600061293a826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316612a5f9092919063ffffffff16565b805190915015611a6857808060200190518101906129589190612f5b565b611a685760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016102de565b604051638cca42b560e01b81526001600160a01b038681166004830152851660248201526000908190819073__$d8f4c298c40046574ed00784bf1ab2bf98$__90638cca42b5906044016040805180830381865af4158015612a1d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a419190613541565b915050612a5086868387612a6e565b90999098509650505050505050565b60606112d98484600085612af7565b6000806000846bffffffffffffffffffffffff16876001600160401b0316876001600160401b031642612aa19190613474565b612aab9190613230565b612ab5919061342f565b905083811115612ad457612ac98482613230565b925060019150612aed565b83811015612aed57612ae68185613230565b9250600091505b5094509492505050565b606082471015612b585760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084016102de565b6001600160a01b0385163b612baf5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016102de565b600080866001600160a01b03168587604051612bcb919061356c565b60006040518083038185875af1925050503d8060008114612c08576040519150601f19603f3d011682016040523d82523d6000602084013e612c0d565b606091505b5091509150612c1d828286612c28565b979650505050505050565b60608315612c37575081611dbf565b825115612c475782518084602001fd5b8160405162461bcd60e51b81526004016102de9190612e92565b6001600160a01b0381168114612c7657600080fd5b50565b60008060408385031215612c8c57600080fd5b823591506020830135612c9e81612c61565b809150509250929050565b600060208284031215612cbb57600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715612d0057612d00612cc2565b604052919050565b60006001600160401b03821115612d2157612d21612cc2565b50601f01601f191660200190565b600082601f830112612d4057600080fd5b8135612d53612d4e82612d08565b612cd8565b818152846020838601011115612d6857600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060008060c08789031215612d9e57600080fd5b863595506020870135612db081612c61565b94506040870135612dc081612c61565b935060608701356001600160401b0380821115612ddc57600080fd5b612de88a838b01612d2f565b94506080890135915080821115612dfe57600080fd5b612e0a8a838b01612d2f565b935060a0890135915080821115612e2057600080fd5b50612e2d89828a01612d2f565b9150509295509295509295565b60005b83811015612e55578181015183820152602001612e3d565b8381111561030b5750506000910152565b60008151808452612e7e816020860160208601612e3a565b601f01601f19169290920160200192915050565b602081526000611dbf6020830184612e66565b60008060008060808587031215612ebb57600080fd5b843593506020850135612ecd81612c61565b92506040850135612edd81612c61565b915060608501356001600160401b03811115612ef857600080fd5b612f0487828801612d2f565b91505092959194509250565b600060208284031215612f2257600080fd5b5051919050565b600060208284031215612f3b57600080fd5b8151611dbf81612c61565b80518015158114612f5657600080fd5b919050565b600060208284031215612f6d57600080fd5b611dbf82612f46565b634e487b7160e01b600052601160045260246000fd5b600063ffffffff808316818516808303821115612fab57612fab612f76565b01949350505050565b6001600160a01b0392909216825263ffffffff16602082015260400190565b600060208284031215612fe557600080fd5b81516001600160401b03811115612ffb57600080fd5b8201601f8101841361300c57600080fd5b805161301a612d4e82612d08565b81815285602083850101111561302f57600080fd5b613040826020830160208601612e3a565b95945050505050565b6000602080838503121561305c57600080fd5b82516001600160401b038082111561307357600080fd5b818501915085601f83011261308757600080fd5b81518181111561309957613099612cc2565b8060051b91506130aa848301612cd8565b81815291830184019184810190888411156130c457600080fd5b938501935b838510156130ee57845192506130de83612c61565b82825293850193908501906130c9565b98975050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060ff821660ff810361312657613126612f76565b60010192915050565b6000806040838503121561314257600080fd5b825161314d81612c61565b6020840151909250612c9e81612c61565b6001600160a01b038681168252858116602083015263ffffffff851660408301528316606082015260a060808201819052600090612c1d90830184612e66565b6001600160a01b03858116825263ffffffff851660208301528316604082015260806060820181905260009061117590830184612e66565b634e487b7160e01b600052600160045260246000fd5b60208082526024908201527f64486564676548656c7065723a20427566666572207472616e736665722066616040820152631a5b195960e21b606082015260800190565b60008282101561324257613242612f76565b500390565b60006020828403121561325957600080fd5b815160ff81168114611dbf57600080fd5b600060ff821660ff84168082101561328457613284612f76565b90039392505050565b600181815b808511156132c85781600019048211156132ae576132ae612f76565b808516156132bb57918102915b93841c9390800290613292565b509250929050565b6000826132df5750600161073c565b816132ec5750600061073c565b8160018114613302576002811461330c57613328565b600191505061073c565b60ff84111561331d5761331d612f76565b50506001821b61073c565b5060208310610133831016604e8410600b841016171561334b575081810a61073c565b613355838361328d565b806000190482111561336957613369612f76565b029392505050565b6000611dbf60ff8416836132d0565b60008261339d57634e487b7160e01b600052601260045260246000fd5b500490565b80516001600160801b0381168114612f5657600080fd5b600080600080608085870312156133cf57600080fd5b6133d885612f46565b93506133e6602086016133a2565b92506133f4604086016133a2565b9150613402606086016133a2565b905092959194509250565b60006001600160801b03808316818516808303821115612fab57612fab612f76565b600081600019048311821515161561344957613449612f76565b500290565b60006020828403121561346057600080fd5b815163ffffffff81168114611dbf57600080fd5b6000821982111561348757613487612f76565b500190565b6001600160a01b03868116825263ffffffff861660208301526001600160801b03851660408301528316606082015260a060808201819052600090612c1d90830184612e66565b600080600080608085870312156134e957600080fd5b6134f285612f46565b935061350060208601612f46565b925061350e604086016133a2565b6060959095015193969295505050565b600063ffffffff80831681810361353757613537612f76565b6001019392505050565b6000806040838503121561355457600080fd5b82519150602083015180600b0b8114612c9e57600080fd5b6000825161357e818460208701612e3a565b919091019291505056fea9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd3a26469706673582212203e85a0c371c24a9d1f1bcb8ef8ea263054ba30c4eda19bd4e6cbefc6e78897eb64736f6c634300080d0033",
  "libraries": {
    "SFHelper": "0x5cFb89F68ac9e2decF9E9Def5AB3c6e1cEC99e67",
    "dHedgeMath": "0xF99faF12Efe98C6B67a4a96cBB5265af846d6319"
  },
  "devdoc": {
    "author": "rashtrakoff <rashtrakoff@pm.me>.",
    "custom:experimental": "This is an experimental contract/library. Use at your own risk.",
    "details": "Contains functions for interacting with dHEDGE protocol pools.",
    "kind": "dev",
    "methods": {
      "afterAgreementCreated(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes,bytes,bytes)": {
        "params": {
          "_agreementClass": "Tells whether it's CFA or IDA contract call.",
          "_cbdata": "Callback data passed on from `beforeAgreementCreated` hook.",
          "_ctx": "Superfluid context object.",
          "_dHedgePool": "Struct containing details regarding the pool and various tokens in it.",
          "_superToken": "The supertoken whose stream needs to be created."
        }
      },
      "afterAgreementTerminated(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes,bytes,bytes)": {
        "params": {
          "_agreementClass": "Tells whether it's CFA or IDA contract call.",
          "_cbdata": "Callback data passed on from `beforeAgreementTerminated` hook.",
          "_ctx": "Superfluid context object.",
          "_dHedgePool": "Struct containing details regarding the pool and various tokens in it.",
          "_superToken": "Underlying token of the supertoken."
        }
      },
      "afterAgreementUpdated(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes,bytes,bytes)": {
        "params": {
          "_agreementClass": "Tells whether it's CFA or IDA contract call.",
          "_cbdata": "Callback data passed on from `beforeAgreementUpdated` hook.",
          "_ctx": "Superfluid context object.",
          "_dHedgePool": "Struct containing details regarding the pool and various tokens in it.",
          "_superToken": "Underlying token of the supertoken."
        }
      },
      "beforeAgreement(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes)": {
        "params": {
          "_agreementClass": "Tells whether it's CFA or IDA contract call.",
          "_superToken": "Underlying token of the supertoken."
        },
        "returns": {
          "_cbdata": "Callback data that needs to be passed on to after agreement hooks."
        }
      },
      "deposit(dHedgeStorage.dHedgePool storage,address)": {
        "params": {
          "_dHedgePool": "Struct containing details regarding the pool and various tokens in it.",
          "_depositToken": "Address of the underlying token (deposit token and not the supertoken)."
        }
      },
      "distribute(dHedgeStorage.dHedgePool storage,address)": {
        "params": {
          "_dHedgePool": "Struct containing details regarding the pool and various tokens in it.",
          "_depositToken": "Address of the underlying token (deposit token and not the supertoken)."
        }
      },
      "initStreamToken(dHedgeStorage.dHedgePool storage,ISuperToken)": {
        "params": {
          "_dHedgePool": "Struct containing details regarding the pool and various tokens in it.",
          "_superToken": "The supertoken which needs to be initialised."
        }
      },
      "isDepositAsset(dHedgeStorage.dHedgePool storage,address)": {
        "params": {
          "_dHedgePool": "Struct containing details regarding the pool and various tokens in it.",
          "_token": "Address of the underlying token to be deposited."
        },
        "returns": {
          "_0": "Boolean representing the status of the token for deposition."
        }
      },
      "requireUpkeep(dHedgeStorage.dHedgePool storage)": {
        "details": "Function which checks if deposit function can be called or not.",
        "params": {
          "_dHedgePool": "Struct containing details regarding the pool and various tokens in it."
        },
        "returns": {
          "_depositToken": "Address of an underlying token."
        }
      }
    },
    "title": "dHEDGE core helper library.",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "afterAgreementCreated(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes,bytes,bytes)": {
        "notice": "This function serves as the `afterAgreementCreated` hook for Superfluid CFA. Responsible for actions to be taken after creation of a stream (transfer buffer, update shares, etc.)."
      },
      "afterAgreementTerminated(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes,bytes,bytes)": {
        "notice": "This function serves as the `afterAgreementTerminated` hook for Superfluid CFA. Responsible for actions to be taken after termination of the stream (transfer buffer, update shares, etc.)."
      },
      "afterAgreementUpdated(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes,bytes,bytes)": {
        "notice": "This function serves as the `afterAgreementUpdated` hook for Superfluid CFA. Responsible for actions to be taken after updation of stream rate (transfer buffer, update shares, etc.)."
      },
      "beforeAgreement(dHedgeStorage.dHedgePool storage,ISuperToken,address,bytes)": {
        "notice": "Helper function that's called before streams are updated or terminated."
      },
      "deposit(dHedgeStorage.dHedgePool storage,address)": {
        "notice": "Function to deposit tokens into a dHedge pool."
      },
      "distribute(dHedgeStorage.dHedgePool storage,address)": {
        "notice": "Function to distribute DHPTx."
      },
      "initStreamToken(dHedgeStorage.dHedgePool storage,ISuperToken)": {
        "notice": "Initialise a market for a new token. This means, create 3 indices (2 permanent and 1 temporary) along with unlimited approval- for the underlying token to the dHEDGE pool."
      },
      "isDepositAsset(dHedgeStorage.dHedgePool storage,address)": {
        "notice": "Wrapper function to check if an asset is accepted as deposit asset in a dHedge pool."
      },
      "requireUpkeep(dHedgeStorage.dHedgePool storage)": {
        "notice": "This function is useful for on-chain keepers. Deposit function should only be called if `_reqUpkeep` is true- let whatever be the address of the `_depositToken`."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}