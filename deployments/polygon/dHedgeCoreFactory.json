{
  "address": "0xfbd406097DbfA3dC3560D5a6ca1a0D73465e3699",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_dao",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "_defaultFeeRate",
          "type": "uint32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_newCore",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_poolSuperToken",
          "type": "address"
        }
      ],
      "name": "CoreCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_newDAO",
          "type": "address"
        }
      ],
      "name": "DAOAddressChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "_newFeeRate",
          "type": "uint32"
        }
      ],
      "name": "FeeRateChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "cores",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_dHedgePool",
          "type": "address"
        },
        {
          "internalType": "contract ISuperToken",
          "name": "_DHPTx",
          "type": "address"
        }
      ],
      "name": "createdHedgeCore",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "dao",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "defaultFeeRate",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "implementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_dao",
          "type": "address"
        }
      ],
      "name": "setDAOAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_defaultFeeRate",
          "type": "uint32"
        }
      ],
      "name": "setDefaultFeeRate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xa93bafa25c217ef7bc7185b99735694415e3bc24d1717d3cda0ba4e0e106c2f4",
  "receipt": {
    "to": null,
    "from": "0x452181dAe31Cf9f42189df71eC64298993BEe6d3",
    "contractAddress": "0xfbd406097DbfA3dC3560D5a6ca1a0D73465e3699",
    "transactionIndex": 12,
    "gasUsed": "2514503",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000080000000000000000008000000000000000000000000000000000000000004000000000000000800001000000000000000100000000000000000200020000000000000000000800020000000000200080000000000000400800004000000000000000000000000000000000000000000000000000000000200000000000000000000000000040000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000000020000000000000000000000000000000000000000000002000000000000000100000",
    "blockHash": "0x910be589d9ecbf6ba48ba654821e95ed13db50bfb7164331681ad238e4b16340",
    "transactionHash": "0xa93bafa25c217ef7bc7185b99735694415e3bc24d1717d3cda0ba4e0e106c2f4",
    "logs": [
      {
        "transactionIndex": 12,
        "blockNumber": 25163427,
        "transactionHash": "0xa93bafa25c217ef7bc7185b99735694415e3bc24d1717d3cda0ba4e0e106c2f4",
        "address": "0xfbd406097DbfA3dC3560D5a6ca1a0D73465e3699",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000452181dae31cf9f42189df71ec64298993bee6d3"
        ],
        "data": "0x",
        "logIndex": 27,
        "blockHash": "0x910be589d9ecbf6ba48ba654821e95ed13db50bfb7164331681ad238e4b16340"
      },
      {
        "transactionIndex": 12,
        "blockNumber": 25163427,
        "transactionHash": "0xa93bafa25c217ef7bc7185b99735694415e3bc24d1717d3cda0ba4e0e106c2f4",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000452181dae31cf9f42189df71ec64298993bee6d3",
          "0x00000000000000000000000088c5e96c1459d224383dcb1fe0cedd1fcee25ffb"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000138aa73500f233a00000000000000000000000000000000000000000000000042edd615ebf8ba480000000000000000000000000000000000000000000005c9ac1566edd34955cf00000000000000000000000000000000000000000000000041b52ba29be9970e0000000000000000000000000000000000000000000005c9ad4e116123587909",
        "logIndex": 28,
        "blockHash": "0x910be589d9ecbf6ba48ba654821e95ed13db50bfb7164331681ad238e4b16340"
      }
    ],
    "blockNumber": 25163427,
    "cumulativeGasUsed": "3996672",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x452181dAe31Cf9f42189df71eC64298993BEe6d3",
    "15000"
  ],
  "solcInputHash": "86d86d91740d38c7ba30914dcf583cd4",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dao\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_defaultFeeRate\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newCore\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_poolSuperToken\",\"type\":\"address\"}],\"name\":\"CoreCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newDAO\",\"type\":\"address\"}],\"name\":\"DAOAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_newFeeRate\",\"type\":\"uint32\"}],\"name\":\"FeeRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cores\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dHedgePool\",\"type\":\"address\"},{\"internalType\":\"contract ISuperToken\",\"name\":\"_DHPTx\",\"type\":\"address\"}],\"name\":\"createdHedgeCore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dao\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultFeeRate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dao\",\"type\":\"address\"}],\"name\":\"setDAOAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_defaultFeeRate\",\"type\":\"uint32\"}],\"name\":\"setDefaultFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"createdHedgeCore(address,address)\":{\"params\":{\"_DHPTx\":\"Supertoken of the corresponding DHPT of `_dHedgePool`\",\"_dHedgePool\":\"Address of the dHEDGE pool for which a core needs to be created\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setDefaultFeeRate(uint32)\":{\"details\":\"Sets fee rate for all cores\",\"params\":{\"_defaultFeeRate\":\"The new fee rate scaled to 1e6\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"stateVariables\":{\"CONFIG_WORD\":{\"custom:note\":\"CONFIG_WORD is used to omit the specific agreement hooks of superapps (NOOP - Not Operate)\"},\"implementation\":{\"details\":\"The implementation contract for dHedgeCore can never be changed\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"cores(address)\":{\"notice\":\"Mapping containing core address for every dHEDGE pool if deployed/created\"},\"createdHedgeCore(address,address)\":{\"notice\":\"Creates a new core for a given dHEDGE pool\"},\"dao()\":{\"notice\":\"The DAO which receives fees\"},\"defaultFeeRate()\":{\"notice\":\"Fee rate for collecting streaming fees scaled to 1e6\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/dHedge-Factory-Version/dHedgeCoreFactory.sol\":\"dHedgeCoreFactory\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x6bb804a310218875e89d12c053e94a13a4607cdf7cc2052f3e52bd32a0dc50a1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xa3bbab77849522b73d8c6cd3d2ac54bef7580e4354484f35f4cabf55d3d2b3f9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8b2abd85d0ece7e866e100e9d47ca9cbec93c87cf71a8d267b2b93eb81f7d5e9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x02348b2e4b9f3200c7e3907c5c2661643a6d8520e9f79939fbb9b4005a54894d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC777/IERC777.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n}\\n\",\"keccak256\":\"0xc1e11e6758e8c83fc43e71e63dc1a211cace8a5912bbf06e697bc2148069800f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3336baae5cf23e94274d75336e2d412193be508504aee185e61dc7d58cd05c8a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x90565a39ae45c80f0468dc96c7b20d0afc3055f344c8203a0c9258239f350b9f\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperAppBase.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.7.0;\\n\\nimport {\\n    ISuperfluid,\\n    ISuperToken,\\n    ISuperApp,\\n    SuperAppDefinitions\\n} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\nabstract contract SuperAppBase is ISuperApp {\\n\\n    function beforeAgreementCreated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes memory /*cbdata*/)\\n    {\\n        revert(\\\"Unsupported callback - Before Agreement Created\\\");\\n    }\\n\\n    function afterAgreementCreated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*cbdata*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        virtual\\n        override\\n        returns (bytes memory /*newCtx*/)\\n    {\\n        revert(\\\"Unsupported callback - After Agreement Created\\\");\\n    }\\n\\n    function beforeAgreementUpdated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes memory /*cbdata*/)\\n    {\\n        revert(\\\"Unsupported callback - Before Agreement updated\\\");\\n    }\\n\\n    function afterAgreementUpdated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*cbdata*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        virtual\\n        override\\n        returns (bytes memory /*newCtx*/)\\n    {\\n        revert(\\\"Unsupported callback - After Agreement Updated\\\");\\n    }\\n\\n    function beforeAgreementTerminated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes memory /*cbdata*/)\\n    {\\n        revert(\\\"Unsupported callback -  Before Agreement Terminated\\\");\\n    }\\n\\n    function afterAgreementTerminated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*cbdata*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        virtual\\n        override\\n        returns (bytes memory /*newCtx*/)\\n    {\\n        revert(\\\"Unsupported callback - After Agreement Terminated\\\");\\n    }\\n\\n}\\n\",\"keccak256\":\"0x76db1497b95aa8af5c6b6d64222c5894c6f5e5662844b7287f0134cbbd0bb5c5\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.7.0;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n\\n/**\\n * @dev Superfluid's constant flow agreement interface\\n *\\n * @author Superfluid\\n */\\nabstract contract IConstantFlowAgreementV1 is ISuperAgreement {\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\");\\n    }\\n\\n    /**\\n     * @dev Get the maximum flow rate allowed with the deposit\\n     * @param deposit Deposit amount used for creating the flow\\n     */\\n    function getMaximumFlowRateFromDeposit(\\n        ISuperfluidToken token,\\n        uint256 deposit)\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @dev Get the deposit required for creating the flow\\n     * @param flowRate Flow rate to be tested\\n     */\\n    function getDepositRequiredForFlowRate(\\n        ISuperfluidToken token,\\n        int96 flowRate)\\n        external view virtual\\n        returns (uint256 deposit);\\n\\n    /**\\n     * @dev Create a flow betwen sender and receiver.\\n     * @param token Super token address.\\n     * @param receiver Flow receiver address.\\n     * @param flowRate New flow rate in amount per second.\\n     *\\n     * # App callbacks\\n     *\\n     * - AgreementCreated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * NOTE:\\n     * - A deposit is taken as safety margin for the solvency agents.\\n     * - A extra gas fee may be taken to pay for solvency agent liquidations.\\n     */\\n    function createFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev Update the flow rate between sender and receiver.\\n     * @param token Super token address.\\n     * @param receiver Flow receiver address.\\n     * @param flowRate New flow rate in amount per second.\\n     *\\n     * # App callbacks\\n     *\\n     * - AgreementUpdated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * NOTE:\\n     * - Only the flow sender may update the flow rate.\\n     * - Even if the flow rate is zero, the flow is not deleted\\n     * from the system.\\n     * - Deposit amount will be adjusted accordingly.\\n     * - No new gas fee is charged.\\n     */\\n    function updateFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n\\n    /**\\n     * @dev Get the flow data between `sender` and `receiver`.\\n     * @param token Super token address.\\n     * @param sender Flow receiver.\\n     * @param receiver Flow sender.\\n     * @return timestamp Timestamp of when the flow is updated.\\n     * @return flowRate The flow rate.\\n     * @return deposit The amount of deposit the flow.\\n     * @return owedDeposit The amount of owed deposit of the flow.\\n     */\\n    function getFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @dev Get flow data using agreement ID\\n     * @param token Super token address.\\n     * @param agreementId The agreement ID.\\n     * @return timestamp Timestamp of when the flow is updated.\\n     * @return flowRate The flow rate.\\n     * @return deposit The amount of deposit the flow.\\n     * @return owedDeposit The amount of owed deposit of the flow.\\n     */\\n    function getFlowByID(\\n       ISuperfluidToken token,\\n       bytes32 agreementId\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @dev Get the aggregated flow info of the account\\n     * @param token Super token address.\\n    * @param account Account for the query.\\n    */\\n    function getAccountFlowInfo(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @dev Get the net flow rate of the account\\n     * @param token Super token address.\\n     * @param account Account for the query.\\n     * @return flowRate Flow rate.\\n     */\\n    function getNetFlow(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @dev Delete the flow between sender and receiver\\n     * @param token Super token address.\\n     * @param ctx Context bytes.\\n     * @param receiver Flow receiver address.\\n     *\\n     * # App callbacks\\n     *\\n     * - AgreementTerminated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * NOTE:\\n     * - Both flow sender and receiver may delete the flow.\\n     * - If Sender account is insolvent or in critical state, a solvency agent may\\n     *   also terminate the agreement.\\n     * - Gas fee may be returned to the sender.\\n     */\\n    function deleteFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n     /**\\n      * @dev Flow updated event.\\n      * @param token Super token address.\\n      * @param sender Flow sender address.\\n      * @param receiver Flow recipient address.\\n      * @param flowRate Flow rate in amount per second for this flow.\\n      * @param flowRate Total flow rate in amount per second for the sender.\\n      * @param flowRate Total flow rate in amount per second for the receiver.\\n      * @param userData The user provided data.\\n      */\\n     event FlowUpdated(\\n         ISuperfluidToken indexed token,\\n         address indexed sender,\\n         address indexed receiver,\\n         int96 flowRate,\\n         int256 totalSenderFlowRate,\\n         int256 totalReceiverFlowRate,\\n         bytes userData\\n     );\\n\\n}\\n\",\"keccak256\":\"0xc47783262893c4600d412987ea47558b3b79336407462e6dff2117c04304177f\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.7.0;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n\\n/**\\n * @title Superfluid's instant distribution agreement interface.\\n *\\n * @author Superfluid\\n *\\n * Notes:\\n *   - A publisher can create as many as indeces as possibily identifiable with `indexId`.\\n *     - `indexId` is deliberately limited to 32 bits, to avoid the chance for sha-3 collision.\\n *       Despite knowing sha-3 collision is only theoratical.\\n *   - A publisher can create subscription to an index for any subscriber.\\n *   - A subscription consists of:\\n *     - The index it subscribes to.\\n *     - Number of units subscribed.\\n *   - An index consists of:\\n *     - Current value as `uint128 indexValue`.\\n *     - Total units of the approved subscriptions as `uint128 totalUnitsApproved`.\\n *     - Total units of the non approved subscription as `uint128 totalUnitsPending`.\\n *   - A publisher can update index with new value that doesn't decrease.\\n *   - A publisher can update subscription with any number of units.\\n *   - A publisher or a subscriber can delete subscription and reset units to zero.\\n *   - A subscriber must approve the index in order to receive distributions from the publisher\\n *     each time the index is updated.\\n *     - The amount distributed is $$\\\\Delta{index} * units$$\\n *   - Distributions to a non approved subscription stays in the publisher's deposit until:\\n *     - the subscriber approve the subscription (side effect),\\n *     - the publisher update the subscription (side effect),\\n *     - the subscriber delete the subscription even if it is never approved (side effect),\\n *     - or the subscriber can explicitly claim them.\\n */\\nabstract contract IInstantDistributionAgreementV1 is ISuperAgreement {\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\");\\n    }\\n\\n    /**************************************************************************\\n     * Index operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Create a new index for the publisher.\\n     * @param token Super token address.\\n     * @param indexId Id of the index.\\n     *\\n     * # App callbacks\\n     *\\n     * None\\n     */\\n    function createIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    event IndexCreated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Query the data of a index.\\n     * @param token Super token address.\\n     * @param publisher The publisher of the index.\\n     * @param indexId Id of the index.\\n     * @return exist Does the index exist.\\n     * @return indexValue Value of the current index.\\n     * @return totalUnitsApproved Total units approved for the index.\\n     * @return totalUnitsPending Total units pending approval for the index.\\n     */\\n    function getIndex(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                uint128 indexValue,\\n                uint128 totalUnitsApproved,\\n                uint128 totalUnitsPending);\\n\\n    /**\\n     * @dev Calculate actual distribution amount\\n     * @param token Super token address.\\n     * @param publisher The publisher of the index.\\n     * @param indexId Id of the index.\\n     * @param amount The amount of tokens desired to be distributed.\\n     */\\n    function calculateDistribution(\\n       ISuperfluidToken token,\\n       address publisher,\\n       uint32 indexId,\\n       uint256 amount)\\n           external view\\n           virtual\\n           returns(\\n               uint256 actualAmount,\\n               uint128 newIndexValue);\\n\\n    /**\\n     * @dev Update index value of an index.\\n     * @param token Super token address.\\n     * @param indexId Id of the index.\\n     * @param indexValue Value of the index.\\n     *\\n     * # App callbacks\\n     *\\n     * None\\n     */\\n    function updateIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    event IndexUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        uint128 oldIndexValue,\\n        uint128 newIndexValue,\\n        uint128 totalUnitsPending,\\n        uint128 totalUnitsApproved,\\n        bytes userData);\\n\\n    /**\\n     * @dev Distribute tokens through the index.\\n     * @param token Super token address.\\n     * @param indexId Id of the index.\\n     * @param amount The amount of tokens desired to be distributed.\\n     *\\n     * NOTE:\\n     * - This is a convenient version of updateIndex. It adds to the index\\n     *   a delta that equals to `amount / totalUnits`.\\n     * - The actual amount distributed could be obtained via\\n     *   `calculateDistribution`. This is due to precision error with index\\n     *   value and units data range.\\n     *\\n     * # App callbacks\\n     *\\n     * None\\n     */\\n    function distribute(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n\\n    /**************************************************************************\\n     * Subscription operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Approve the subscription of an index.\\n     * @param token Super token address.\\n     * @param publisher The publisher of the index.\\n     * @param indexId Id of the index.\\n     *\\n     * # App callbacks\\n     *\\n     * - if subscription exist\\n     *   - AgreementCreated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     */\\n    function approveSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    event IndexSubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n\\n    event SubscriptionApproved(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n    * @dev Revoke the subscription of an index.\\n    * @param token Super token address.\\n    * @param publisher The publisher of the index.\\n    * @param indexId Id of the index.\\n    *\\n    * # App callbacks\\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function revokeSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n         external\\n         virtual\\n         returns(bytes memory newCtx);\\n\\n    event IndexUnsubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n\\n    event SubscriptionRevoked(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Update the nuber of units of a subscription.\\n     * @param token Super token address.\\n     * @param indexId Id of the index.\\n     * @param subscriber The subscriber of the index.\\n     * @param units Number of units of the subscription.\\n     *\\n     * # App callbacks\\n     *\\n     * - if subscription exist\\n     *   - AgreementCreated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function updateSubscription(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    event IndexUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes userData);\\n\\n    event SubscriptionUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint128 units,\\n        bytes userData);\\n\\n    /**\\n     * @dev Get data of a subscription\\n     * @param token Super token address.\\n     * @param publisher The publisher of the index.\\n     * @param indexId Id of the index.\\n     * @param subscriber The subscriber of the index.\\n     * @return exist Does the subscription exist?\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription.\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription.\\n     */\\n    function getSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @dev Get data of a subscription by agreement ID\\n     * @param token Super token address.\\n     * @param agreementId The agreement ID.\\n     * @return publisher The publisher of the index.\\n     * @return indexId Id of the index.\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription.\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription.\\n     */\\n    function getSubscriptionByID(\\n        ISuperfluidToken token,\\n        bytes32 agreementId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address publisher,\\n                uint32 indexId,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @dev List subscriptions of an user.\\n     * @param token Super token address.\\n     * @param subscriber The user, a subscriber.\\n     * @return publishers Publishers of the subcriptions.\\n     * @return indexIds Indexes of the subscriptions.\\n     * @return unitsList Units of the subscriptions.\\n     */\\n    function listSubscriptions(\\n        ISuperfluidToken token,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address[] memory publishers,\\n                uint32[] memory indexIds,\\n                uint128[] memory unitsList);\\n\\n    /**\\n     * @dev Delete the subscription of an user.\\n     * @param token Super token address.\\n     * @param publisher The publisher of the index.\\n     * @param indexId Id of the index.\\n     * @param subscriber The user, a subscriber.\\n     *\\n     * # App callbacks\\n     *\\n     * - if the subscriber called it\\n     *   - AgreementTerminated callback to the publsiher:\\n     *      - agreementId is for the subscription\\n     * - if the publisher called it\\n     *   - AgreementTerminated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function deleteSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n    * @dev Claim pending distributions.\\n    * @param token Super token address.\\n    * @param publisher The publisher of the index.\\n    * @param indexId Id of the index.\\n    * @param subscriber The user, a subscriber.\\n    *\\n    * The subscription should not exist yet.\\n    *\\n    * # App callbacks\\n    *\\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function claim(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n        external\\n        virtual\\n        returns(bytes memory newCtx);\\n\\n    event IndexDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint256 amount);\\n\\n    event SubscriptionDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint256 amount);\\n\\n}\\n\",\"keccak256\":\"0x7a03c59f7f7f228cfaa9e3e19b9766cfa87f05f8702501bd7fa6a6bd39454608\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/Definitions.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.7.0;\\n\\n/**\\n * @dev Super app definitions library\\n */\\nlibrary SuperAppDefinitions {\\n\\n    /**************************************************************************\\n    / App manifest config word\\n    /**************************************************************************/\\n\\n    /*\\n     * App level is a way to allow the app to whitelist what other app it can\\n     * interact with (aka. composite app feature).\\n     *\\n     * For more details, refer to the technical paper of superfluid protocol.\\n     */\\n    uint256 constant internal APP_LEVEL_MASK = 0xFF;\\n\\n    // The app is at the final level, hence it doesn't want to interact with any other app\\n    uint256 constant internal APP_LEVEL_FINAL = 1 << 0;\\n\\n    // The app is at the second level, it may interact with other final level apps if whitelisted\\n    uint256 constant internal APP_LEVEL_SECOND = 1 << 1;\\n\\n    function getAppLevel(uint256 configWord) internal pure returns (uint8) {\\n        return uint8(configWord & APP_LEVEL_MASK);\\n    }\\n\\n    uint256 constant internal APP_JAIL_BIT = 1 << 15;\\n    function isAppJailed(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & SuperAppDefinitions.APP_JAIL_BIT) > 0;\\n    }\\n\\n    /**************************************************************************\\n    / Callback implementation bit masks\\n    /**************************************************************************/\\n    uint256 constant internal AGREEMENT_CALLBACK_NOOP_BITMASKS = 0xFF << 32;\\n    uint256 constant internal BEFORE_AGREEMENT_CREATED_NOOP = 1 << (32 + 0);\\n    uint256 constant internal AFTER_AGREEMENT_CREATED_NOOP = 1 << (32 + 1);\\n    uint256 constant internal BEFORE_AGREEMENT_UPDATED_NOOP = 1 << (32 + 2);\\n    uint256 constant internal AFTER_AGREEMENT_UPDATED_NOOP = 1 << (32 + 3);\\n    uint256 constant internal BEFORE_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 4);\\n    uint256 constant internal AFTER_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 5);\\n\\n    /**************************************************************************\\n    / App Jail Reasons\\n    /**************************************************************************/\\n\\n    uint256 constant internal APP_RULE_REGISTRATION_ONLY_IN_CONSTRUCTOR = 1;\\n    uint256 constant internal APP_RULE_NO_REGISTRATION_FOR_EOA = 2;\\n    uint256 constant internal APP_RULE_NO_REVERT_ON_TERMINATION_CALLBACK = 10;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_SENDER_ACCOUNT = 11;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_RECEIVER_ACCOUNT = 12;\\n    uint256 constant internal APP_RULE_CTX_IS_READONLY = 20;\\n    uint256 constant internal APP_RULE_CTX_IS_NOT_CLEAN = 21;\\n    uint256 constant internal APP_RULE_CTX_IS_MALFORMATED = 22;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_NOT_WHITELISTED = 30;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_JAILED = 31;\\n    uint256 constant internal APP_RULE_MAX_APP_LEVEL_REACHED = 40;\\n}\\n\\n/**\\n * @dev Context definitions library\\n */\\nlibrary ContextDefinitions {\\n\\n    /**************************************************************************\\n    / Call info\\n    /**************************************************************************/\\n\\n    // app level\\n    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;\\n\\n    // call type\\n    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;\\n    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;\\n\\n    function decodeCallInfo(uint256 callInfo)\\n        internal pure\\n        returns (uint8 appLevel, uint8 callType)\\n    {\\n        appLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);\\n        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n    function encodeCallInfo(uint8 appLevel, uint8 callType)\\n        internal pure\\n        returns (uint256 callInfo)\\n    {\\n        return uint256(appLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n}\\n\\n/**\\n * @dev Batch operation library\\n */\\nlibrary BatchOperation {\\n    /**\\n     * @dev ERC20.approve batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationApprove(\\n     *     abi.decode(data, (address spender, uint256 amount))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_APPROVE = 1;\\n    /**\\n     * @dev ERC20.transferFrom batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationTransferFrom(\\n     *     abi.decode(data, (address sender, address recipient, uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_TRANSFER_FROM = 2;\\n    /**\\n     * @dev SuperToken.upgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationUpgrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_UPGRADE = 1 + 100;\\n    /**\\n     * @dev SuperToken.downgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDowngrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_DOWNGRADE = 2 + 100;\\n    /**\\n     * @dev Superfluid.callAgreement batch operation type\\n     *\\n     * Call spec:\\n     * callAgreement(\\n     *     ISuperAgreement(target)),\\n     *     abi.decode(data, (bytes calldata, bytes userdata)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_AGREEMENT = 1 + 200;\\n    /**\\n     * @dev Superfluid.callAppAction batch operation type\\n     *\\n     * Call spec:\\n     * callAppAction(\\n     *     ISuperApp(target)),\\n     *     data\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_APP_ACTION = 2 + 200;\\n}\\n\\nlibrary SuperfluidGovernanceConfigs {\\n\\n    bytes32 constant internal SUPERFLUID_REWARD_ADDRESS_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.rewardAddress\\\");\\n\\n    bytes32 constant internal CFAv1_LIQUIDATION_PERIOD_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1.liquidationPeriod\\\");\\n\\n    function getTrustedForwarderConfigKey(address forwarder) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.trustedForwarder\\\",\\n            forwarder));\\n    }\\n\\n    function getAppRegistrationConfigKey(address deployer, string memory registrationKey) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.registrationKey\\\",\\n            deployer,\\n            registrationKey));\\n    }\\n\\n    function getAppFactoryConfigKey(address factory) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.factory\\\",\\n            factory));\\n    }\\n}\\n\",\"keccak256\":\"0x430cf617b2acfd3b5ee9b245b708faf9ded9a2b3168d61098db1016af14533ec\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperAgreement.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.7.0;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Superfluid's agreement interface.\\n *\\n * @author Superfluid\\n */\\ninterface ISuperAgreement {\\n\\n    /**\\n     * @dev Initialize the agreement contract\\n     */\\n    function initialize() external;\\n\\n    /**\\n     * @dev Get the type of the agreement class.\\n     */\\n    function agreementType() external view returns (bytes32);\\n\\n    /**\\n     * @dev Calculate the real-time balance for the account of this agreement class.\\n     * @param account Account the state belongs to\\n     * @param time Future time used for the calculation.\\n     * @return dynamicBalance Dynamic balance portion of real-time balance of this agreement.\\n     * @return deposit Account deposit amount of this agreement.\\n     * @return owedDeposit Account owed deposit amount of this agreement.\\n     */\\n    function realtimeBalanceOf(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 time\\n    )\\n        external\\n        view\\n        returns (\\n            int256 dynamicBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n}\\n\",\"keccak256\":\"0xcf8a33fadd5db47562156a11098623246efd1b46a2c3d28269767bcbb324fd66\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.7.0;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\n\\n/**\\n * @title Superfluid's app interface.\\n *\\n * NOTE:\\n * - Be fearful of the app jail, when the word permitted is used.\\n *\\n * @author Superfluid\\n */\\ninterface ISuperApp {\\n\\n    /**\\n     * @dev Callback before a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * NOTE:\\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n     * @dev Callback after a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param cbdata The data returned from the before-hook callback.\\n     * @param ctx The context data.\\n     * @return newCtx The current context of the transaction.\\n     *\\n     * NOTE:\\n     * - State changes is permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function afterAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Callback before a new agreement is updated.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * NOTE:\\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n\\n    /**\\n    * @dev Callback after a new agreement is updated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * NOTE:\\n    * - State changes is permitted.\\n    * - Only revert with a \\\"reason\\\" is permitted.\\n    */\\n    function afterAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n    * @dev Callback before a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param ctx The context data.\\n    * @return cbdata A free format in memory data the app can use to pass\\n    *          arbitary information to the after-hook callback.\\n    *\\n    * NOTE:\\n    * - It will be invoked with `staticcall`, no state changes are permitted.\\n    * - Revert is not permitted.\\n    */\\n    function beforeAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n    * @dev Callback after a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * NOTE:\\n    * - State changes is permitted.\\n    * - Revert is not permitted.\\n    */\\n    function afterAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n}\\n\",\"keccak256\":\"0xca93702505ec3c8244227e372687d9bdbc9d368fa07723d310ab9550501abb2a\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.7.0;\\n\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Superfluid's super token (Superfluid Token + ERC20 + ERC777) interface\\n *\\n * @author Superfluid\\n */\\ninterface ISuperToken is ISuperfluidToken, TokenInfo, IERC20, IERC777 {\\n\\n    /// @dev Initialize the contract\\n    function initialize(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        string calldata n,\\n        string calldata s\\n    ) external;\\n\\n    /**************************************************************************\\n    * TokenInfo & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: SuperToken always uses 18 decimals.\\n     *\\n     * Note: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view override(TokenInfo) returns (uint8);\\n\\n    /**************************************************************************\\n    * ERC20 & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address account) external view override(IERC777, IERC20) returns(uint256 balance);\\n\\n    /**************************************************************************\\n    * ERC20\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external override(IERC20) view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**************************************************************************\\n    * ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For super token contracts, this value is 1 always\\n     */\\n    function granularity() external view override(IERC777) returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external override(IERC777) view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external override(IERC777) view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**************************************************************************\\n     * SuperToken custom token functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Mint new tokens for the account\\n     *\\n     * Modifiers:\\n     *  - onlySelf\\n     */\\n    function selfMint(\\n        address account,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n   /**\\n    * @dev Burn existing tokens for the account\\n    *\\n    * Modifiers:\\n    *  - onlySelf\\n    */\\n   function selfBurn(\\n       address account,\\n       uint256 amount,\\n       bytes memory userData\\n   ) external;\\n\\n    /**************************************************************************\\n     * SuperToken extra functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Transfer all available balance from `msg.sender` to `recipient`\\n     */\\n    function transferAll(address recipient) external;\\n\\n    /**************************************************************************\\n     * ERC20 wrapping\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Return the underlying token contract\\n     * @return tokenAddr Underlying token address\\n     */\\n    function getUnderlyingToken() external view returns(address tokenAddr);\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken.\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     *\\n     * NOTE: It will use \\u00b4transferFrom\\u00b4 to get tokens. Before calling this\\n     * function you should \\u00b4approve\\u00b4 this contract\\n     */\\n    function upgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken and transfer immediately\\n     * @param to The account to received upgraded tokens\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     * @param data User data for the TokensRecipient callback\\n     *\\n     * NOTE: It will use \\u00b4transferFrom\\u00b4 to get tokens. Before calling this\\n     * function you should \\u00b4approve\\u00b4 this contract\\n     */\\n    function upgradeTo(address to, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Token upgrade event\\n     * @param account Account where tokens are upgraded to\\n     * @param amount Amount of tokens upgraded (in 18 decimals)\\n     */\\n    event TokenUpgraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20.\\n     * @dev It will call transfer to send tokens\\n     * @param amount Number of tokens to be downgraded\\n     */\\n    function downgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Token downgrade event\\n     * @param account Account whose tokens are upgraded\\n     * @param amount Amount of tokens downgraded\\n     */\\n    event TokenDowngraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**************************************************************************\\n    * Batch Operations\\n    *************************************************************************/\\n\\n    /**\\n    * @dev Perform ERC20 approve by host contract.\\n    * @param account The account owner to be approved.\\n    * @param spender The spender of account owner's funds.\\n    * @param amount Number of tokens to be approved.\\n    *\\n    * Modifiers:\\n    *  - onlyHost\\n    */\\n    function operationApprove(\\n        address account,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC20 transfer from by host contract.\\n    * @param account The account to spend sender's funds.\\n    * @param spender  The account where the funds is sent from.\\n    * @param recipient The recipient of thefunds.\\n    * @param amount Number of tokens to be transferred.\\n    *\\n    * Modifiers:\\n    *  - onlyHost\\n    */\\n    function operationTransferFrom(\\n        address account,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Upgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be upgraded (in 18 decimals)\\n    *\\n    * Modifiers:\\n    *  - onlyHost\\n    */\\n    function operationUpgrade(address account, uint256 amount) external;\\n\\n    /**\\n    * @dev Downgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be downgraded (in 18 decimals)\\n    *\\n    * Modifiers:\\n    *  - onlyHost\\n    */\\n    function operationDowngrade(address account, uint256 amount) external;\\n\\n\\n    /**************************************************************************\\n    * Function modifiers for access control and parameter validations\\n    *\\n    * While they cannot be explicitly stated in function definitions, they are\\n    * listed in function definition comments instead for clarity.\\n    *\\n    * NOTE: solidity-coverage not supporting it\\n    *************************************************************************/\\n\\n    /// @dev The msg.sender must be the contract itself\\n    //modifier onlySelf() virtual\\n\\n}\\n\",\"keccak256\":\"0xba355f7d7d5d32ca345bcdb355759ba598a911ff07227ff80012a5e0bf660fb1\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperTokenFactory.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.7.0;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\nimport {\\n    IERC20,\\n    ERC20WithTokenInfo\\n} from \\\"../tokens/ERC20WithTokenInfo.sol\\\";\\n\\n\\ninterface ISuperTokenFactory {\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /// @dev Initialize the contract\\n    function initialize() external;\\n\\n    /**\\n     * @dev Get the current super token logic used by the factory\\n     */\\n    function getSuperTokenLogic() external view returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Upgradability modes\\n     */\\n    enum Upgradability {\\n        /// Non upgradable super token, `host.updateSuperTokenLogic` will revert\\n        NON_UPGRADABLE,\\n        /// Upgradable through `host.updateSuperTokenLogic` operation\\n        SEMI_UPGRADABLE,\\n        /// Always using the latest super token logic\\n        FULL_UPGRADABE\\n    }\\n\\n    /**\\n     * @dev Create new super token wrapper for the underlying ERC20 token\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param underlyingDecimals Underlying token decimals\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     */\\n    function createERC20Wrapper(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Create new super token wrapper for the underlying ERC20 token with extra token info\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     *\\n     * NOTE:\\n     * - It assumes token provide the .decimals() function\\n     */\\n    function createERC20Wrapper(\\n        ERC20WithTokenInfo underlyingToken,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    function initializeCustomSuperToken(\\n        address customSuperTokenProxy\\n    )\\n        external;\\n\\n    event SuperTokenLogicCreated(ISuperToken indexed tokenLogic);\\n\\n    event SuperTokenCreated(ISuperToken indexed token);\\n\\n    event CustomSuperTokenCreated(ISuperToken indexed token);\\n\\n}\\n\",\"keccak256\":\"0x7dc514c6c9eda681ed8ad66ccfb68dc22764b6c429ab55fddbba28b6b148621b\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.7.0;\\n// This is required by the batchCall and decodeCtx\\npragma experimental ABIEncoderV2;\\n\\nimport { ISuperfluidGovernance } from \\\"./ISuperfluidGovernance.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperTokenFactory } from \\\"./ISuperTokenFactory.sol\\\";\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { ISuperApp } from \\\"./ISuperApp.sol\\\";\\nimport {\\n    SuperAppDefinitions,\\n    ContextDefinitions,\\n    BatchOperation,\\n    SuperfluidGovernanceConfigs\\n} from \\\"./Definitions.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\n\\n\\n/**\\n * @dev Superfluid host interface.\\n\\n * It is the central contract of the system where super agreement, super app\\n * and super token features are connected together.\\n *\\n * The superfluid host contract is also the entry point for the protocol users,\\n * where batch call and meta transaction are provided for UX improvements.\\n *\\n * @author Superfluid\\n */\\ninterface ISuperfluid {\\n\\n    /**************************************************************************\\n     * Governance\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get the current governace of the Superfluid host\\n     */\\n    function getGovernance() external view returns(ISuperfluidGovernance governance);\\n\\n    event GovernanceReplaced(ISuperfluidGovernance oldGov, ISuperfluidGovernance newGov);\\n    /**\\n     * @dev Replace the current governance with a new one\\n     */\\n    function replaceGovernance(ISuperfluidGovernance newGov) external;\\n\\n    /**************************************************************************\\n     * Agreement Whitelisting\\n     *************************************************************************/\\n\\n    event AgreementClassRegistered(bytes32 agreementType, address code);\\n    /**\\n     * @dev Register a new agreement class to the system\\n     * @param agreementClassLogic INitial agreement class code\\n     *\\n     * Modifiers:\\n     *  - onlyGovernance\\n     */\\n    function registerAgreementClass(ISuperAgreement agreementClassLogic) external;\\n\\n    event AgreementClassUpdated(bytes32 agreementType, address code);\\n    /**\\n    * @dev Update code of an agreement class\\n    * @param agreementClassLogic New code for the agreement class\\n    *\\n    * Modifiers:\\n    *  - onlyGovernance\\n    */\\n    function updateAgreementClass(ISuperAgreement agreementClassLogic) external;\\n\\n    /**\\n    * @dev Check if the agreement class is whitelisted\\n    */\\n    function isAgreementTypeListed(bytes32 agreementType) external view returns(bool yes);\\n\\n    /**\\n    * @dev Check if the agreement class is whitelisted\\n    */\\n    function isAgreementClassListed(ISuperAgreement agreementClass) external view returns(bool yes);\\n\\n    /**\\n    * @dev Get agreement class\\n    */\\n    function getAgreementClass(bytes32 agreementType) external view returns(ISuperAgreement agreementClass);\\n\\n    /**\\n    * @dev Map list of the agreement classes using a bitmap\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function mapAgreementClasses(uint256 bitmap)\\n        external view\\n        returns (ISuperAgreement[] memory agreementClasses);\\n\\n    /**\\n    * @dev Create a new bitmask by adding a agreement class to it.\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function addToAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**\\n    * @dev Create a new bitmask by removing a agreement class from it.\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function removeFromAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**************************************************************************\\n    * Super Token Factory\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get the super token factory\\n     * @return factory The factory\\n     */\\n    function getSuperTokenFactory() external view returns (ISuperTokenFactory factory);\\n\\n    /**\\n     * @dev Get the super token factory logic (applicable to upgradable deployment)\\n     * @return logic The factory logic\\n     */\\n    function getSuperTokenFactoryLogic() external view returns (address logic);\\n\\n    event SuperTokenFactoryUpdated(ISuperTokenFactory newFactory);\\n    /**\\n     * @dev Update super token factory\\n     * @param newFactory New factory logic\\n     */\\n    function updateSuperTokenFactory(ISuperTokenFactory newFactory) external;\\n\\n    event SuperTokenLogicUpdated(ISuperToken indexed token, address code);\\n    /**\\n     * @dev Update the super token logic to the latest\\n     *\\n     * NOTE:\\n     * - Refer toISuperTokenFactory.Upgradability for expected behaviours.\\n     */\\n    function updateSuperTokenLogic(ISuperToken token) external;\\n\\n    /**************************************************************************\\n     * App Registry\\n     *************************************************************************/\\n\\n    /**\\n     * @dev App registered event\\n     */\\n    event AppRegistered(ISuperApp indexed app);\\n\\n    /**\\n     * @dev Jail event for the app\\n     */\\n    event Jail(ISuperApp indexed app, uint256 reason);\\n\\n    /**\\n     * @dev Message sender declares it as a super app\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     *                   `SuperAppDefinitions`\\n     */\\n    function registerApp(uint256 configWord) external;\\n\\n    /**\\n     * @dev Message sender declares it as a super app, using a registration key\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     *                   `SuperAppDefinitions`\\n     * @param registrationKey The registration key issued by the governance\\n     */\\n    function registerAppWithKey(uint256 configWord, string calldata registrationKey) external;\\n\\n    /**\\n     * @dev Message sender declares app as a super app\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     *                   `SuperAppDefinitions`\\n     * NOTE: only factory contracts authorized by governance can register super apps\\n     */\\n    function registerAppByFactory(ISuperApp app, uint256 configWord) external;\\n\\n    /**\\n     * @dev Query if the app is registered\\n     * @param app Super app address\\n     */\\n    function isApp(ISuperApp app) external view returns(bool);\\n\\n    /**\\n     * @dev Query app level\\n     * @param app Super app address\\n     */\\n    function getAppLevel(ISuperApp app) external view returns(uint8 appLevel);\\n\\n    /**\\n     * @dev Get the manifest of the super app\\n     * @param app Super app address\\n     */\\n    function getAppManifest(\\n        ISuperApp app\\n    )\\n        external view\\n        returns (\\n            bool isSuperApp,\\n            bool isJailed,\\n            uint256 noopMask\\n        );\\n\\n    /**\\n     * @dev Query if the app has been jailed\\n     * @param app Super app address\\n     */\\n    function isAppJailed(ISuperApp app) external view returns (bool isJail);\\n\\n    /**\\n     * @dev White-list the target app for app composition for the source app (msg.sender)\\n     * @param targetApp The taget super app address\\n     */\\n    function allowCompositeApp(ISuperApp targetApp) external;\\n\\n    /**\\n     * @dev Query if source app  is allowed to call the target app as downstream app.\\n     * @param app Super app address\\n     * @param targetApp The taget super app address\\n     */\\n    function isCompositeAppAllowed(\\n        ISuperApp app,\\n        ISuperApp targetApp\\n    )\\n        external view\\n        returns (bool isAppAllowed);\\n\\n    /**************************************************************************\\n     * Agreement Framework\\n     *\\n     * Agreements use these function to trigger super app callbacks, updates\\n     * app allowance and charge gas fees.\\n     *\\n     * These functions can only be called by registered agreements.\\n     *************************************************************************/\\n\\n    function callAppBeforeCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // isAppActive(app)\\n        returns(bytes memory cbdata);\\n\\n    function callAppAfterCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // isAppActive(app)\\n        returns(bytes memory appCtx);\\n\\n    function appCallbackPush(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 appAllowanceGranted,\\n        int256 appAllowanceUsed,\\n        ISuperfluidToken appAllowanceToken\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory appCtx);\\n\\n    function appCallbackPop(\\n        bytes calldata ctx,\\n        int256 appAllowanceUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    function ctxUseAllowance(\\n        bytes calldata ctx,\\n        uint256 appAllowanceWantedMore,\\n        int256 appAllowanceUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    function jailApp(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 reason\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    /**************************************************************************\\n     * Contextless Call Proxies\\n     *\\n     * NOTE: For EOAs or non-app contracts, they are the entry points for interacting\\n     * with agreements or apps.\\n     *\\n     * NOTE: The contextual call data should be generated using\\n     * abi.encodeWithSelector. The context parameter should be set to \\\"0x\\\",\\n     * an empty bytes array as a placeholder to be replaced by the host\\n     * contract.\\n     *************************************************************************/\\n\\n     /**\\n      * @dev Call agreement function\\n      * @param callData The contextual call data with placeholder ctx\\n      * @param userData Extra user data being sent to the super app callbacks\\n      */\\n     function callAgreement(\\n         ISuperAgreement agreementClass,\\n         bytes calldata callData,\\n         bytes calldata userData\\n     )\\n        external\\n        //cleanCtx\\n        returns(bytes memory returnedData);\\n\\n    /**\\n     * @dev Call app action\\n     * @param callData The contextual call data.\\n     *\\n     * NOTE: See callAgreement about contextual call data.\\n     */\\n    function callAppAction(\\n        ISuperApp app,\\n        bytes calldata callData\\n    )\\n        external\\n        //cleanCtx\\n        //isAppActive(app)\\n        returns(bytes memory returnedData);\\n\\n    /**************************************************************************\\n     * Contextual Call Proxies and Context Utilities\\n     *\\n     * For apps, they must use context they receive to interact with\\n     * agreements or apps.\\n     *\\n     * The context changes must be saved and returned by the apps in their\\n     * callbacks always, any modification to the context will be detected and\\n     * the violating app will be jailed.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev ABIv2 Encoded memory data of context\\n     *\\n     * NOTE on backward compatibility:\\n     * - Non-dynamic fields are padded to 32bytes and packed\\n     * - Dynamic fields are referenced through a 32bytes offset to their \\\"parents\\\" field (or root)\\n     * - The order of the fields hence should not be rearranged in order to be backward compatible:\\n     *    - non-dynamic fields will be parsed at the same memory location,\\n     *    - and dynamic fields will simply have a greater offset than it was.\\n     */\\n    struct Context {\\n        //\\n        // Call context\\n        //\\n        // callback level\\n        uint8 appLevel;\\n        // type of call\\n        uint8 callType;\\n        // the system timestsamp\\n        uint256 timestamp;\\n        // The intended message sender for the call\\n        address msgSender;\\n\\n        //\\n        // Callback context\\n        //\\n        // For callbacks it is used to know which agreement function selector is called\\n        bytes4 agreementSelector;\\n        // User provided data for app callbacks\\n        bytes userData;\\n\\n        //\\n        // App context\\n        //\\n        // app allowance granted\\n        uint256 appAllowanceGranted;\\n        // app allowance wanted by the app callback\\n        uint256 appAllowanceWanted;\\n        // app allowance used, allowing negative values over a callback session\\n        int256 appAllowanceUsed;\\n        // app address\\n        address appAddress;\\n        // app allowance in super token\\n        ISuperfluidToken appAllowanceToken;\\n    }\\n\\n    function callAgreementWithContext(\\n        ISuperAgreement agreementClass,\\n        bytes calldata callData,\\n        bytes calldata userData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // validCtx(ctx)\\n        // onlyAgreement(agreementClass)\\n        returns (bytes memory newCtx, bytes memory returnedData);\\n\\n    function callAppActionWithContext(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // validCtx(ctx)\\n        // isAppActive(app)\\n        returns (bytes memory newCtx);\\n\\n    function decodeCtx(bytes calldata ctx)\\n        external pure\\n        returns (Context memory context);\\n\\n    function isCtxValid(bytes calldata ctx) external view returns (bool);\\n\\n    /**************************************************************************\\n    * Batch call\\n    **************************************************************************/\\n    /**\\n     * @dev Batch operation data\\n     */\\n    struct Operation {\\n        // Operation. Defined in BatchOperation (Definitions.sol)\\n        uint32 operationType;\\n        // Operation target\\n        address target;\\n        // Data specific to the operation\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Batch call function\\n     * @param operations Array of batch operations.\\n     */\\n    function batchCall(Operation[] memory operations) external;\\n\\n    /**\\n     * @dev Batch call function for trusted forwarders (EIP-2771)\\n     * @param operations Array of batch operations.\\n     */\\n    function forwardBatchCall(Operation[] memory operations) external;\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * TODO: turning these off because solidity-coverage don't like it\\n     *************************************************************************/\\n\\n     /* /// @dev The current superfluid context is clean.\\n     modifier cleanCtx() virtual;\\n\\n     /// @dev The superfluid context is valid.\\n     modifier validCtx(bytes memory ctx) virtual;\\n\\n     /// @dev The agreement is a listed agreement.\\n     modifier isAgreement(ISuperAgreement agreementClass) virtual;\\n\\n     // onlyGovernance\\n\\n     /// @dev The msg.sender must be a listed agreement.\\n     modifier onlyAgreement() virtual;\\n\\n     /// @dev The app is registered and not jailed.\\n     modifier isAppActive(ISuperApp app) virtual; */\\n}\\n\",\"keccak256\":\"0x987a883e8acd87e07eb00ebb1c882d294c7a0af2e5a8cb234270f83f4168438f\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidGovernance.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.7.0;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperfluidToken  } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\n\\n\\n/**\\n * @dev Superfluid's Governance interface\\n *\\n * @author Superfluid\\n */\\ninterface ISuperfluidGovernance {\\n\\n    /**\\n     * @dev Replace the current governance with a new governance\\n     */\\n    function replaceGovernance(\\n        ISuperfluid host,\\n        address newGov) external;\\n\\n    /**\\n     * @dev Register a new agreement class\\n     */\\n    function registerAgreementClass(\\n        ISuperfluid host,\\n        address agreementClass) external;\\n\\n    /**\\n     * @dev Update logics of the contracts\\n     *\\n     * NOTE:\\n     * - Because they might have inter-dependencies, it is good to have one single function to update them all\\n     */\\n    function updateContracts(\\n        ISuperfluid host,\\n        address hostNewLogic,\\n        address[] calldata agreementClassNewLogics,\\n        address superTokenFactoryNewLogic\\n    ) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the latest that is managed by the super token factory\\n     */\\n    function batchUpdateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken[] calldata tokens) external;\\n\\n    /// @dev Get configuration as address value\\n    function getConfigAsAddress(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (address value);\\n\\n    /// @dev Get configuration as uint256 value\\n    function getConfigAsUint256(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (uint256 value);\\n\\n}\\n\",\"keccak256\":\"0x2ac401c7fb012ef43d8becad0196bcd41ac9ad33778a7a5e4809a1740a646e63\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.7.0;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\n\\n\\n/**\\n * @title Superfluid's token interface.\\n *\\n * @author Superfluid\\n */\\ninterface ISuperfluidToken {\\n\\n    /**************************************************************************\\n     * Basic information\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /**************************************************************************\\n     * Real-time balance functions\\n     *************************************************************************/\\n\\n    /**\\n    * @dev Calculate the real balance of a user, taking in consideration all agreements of the account\\n    * @param account for the query\\n    * @param timestamp Time of balance\\n    * @return availableBalance Real-time balance\\n    * @return deposit Account deposit\\n    * @return owedDeposit Account owed Deposit\\n    */\\n    function realtimeBalanceOf(\\n       address account,\\n       uint256 timestamp\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /// @dev realtimeBalanceOf with timestamp equals to block timestamp\\n    function realtimeBalanceOfNow(\\n       address account\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit,\\n            uint256 timestamp);\\n\\n    /**\\n    * @dev Check if one account is critical\\n    * @param account Account check if is critical by a future time\\n    * @param timestamp Time of balance\\n    * @return isCritical\\n    */\\n    function isAccountCritical(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n    * @dev Check if one account is critical now\\n    * @param account Account check if is critical by a future time\\n    * @return isCritical\\n    */\\n    function isAccountCriticalNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n     * @dev Check if one account is solvent\\n     * @param account Account check if is solvent by a future time\\n     * @param timestamp Time of balance\\n     * @return isSolvent\\n     */\\n    function isAccountSolvent(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n     * @dev Check if one account is solvent now\\n     * @param account Account check if is solvent now\\n     * @return isSolvent\\n     */\\n    function isAccountSolventNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n    * @dev Get a list of agreements that is active for the account\\n    * @dev An active agreement is one that has state for the account\\n    * @param account Account to query\\n    * @return activeAgreements List of accounts that have non-zero states for the account\\n    */\\n    function getAccountActiveAgreements(address account)\\n       external view\\n       returns(ISuperAgreement[] memory activeAgreements);\\n\\n\\n   /**************************************************************************\\n    * Super Agreement hosting functions\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function createAgreement(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n\\n    /**\\n     * @dev Agreement creation event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementCreated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Get data of the agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @return data Data of the agreement\\n     */\\n    function getAgreementData(\\n        address agreementClass,\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external view\\n        returns(bytes32[] memory data);\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function updateAgreementData(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n\\n    /**\\n     * @dev Agreement creation event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementUpdated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Close the agreement\\n     * @param id Agreement ID\\n     */\\n    function terminateAgreement(\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external;\\n\\n    /**\\n     * @dev Agreement termination event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     */\\n    event AgreementTerminated(\\n        address indexed agreementClass,\\n        bytes32 id\\n    );\\n\\n    /**\\n     * @dev Update agreement state slot\\n     * @param account Account to be updated\\n     *\\n     * NOTE\\n     * - To clear the storage out, provide zero-ed array of intended length\\n     */\\n    function updateAgreementStateSlot(\\n        address account,\\n        uint256 slotId,\\n        bytes32[] calldata slotData\\n    )\\n        external;\\n\\n    /**\\n     * @dev Agreement account state updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account updated\\n     * @param slotId slot id of the agreement state\\n     */\\n    event AgreementStateUpdated(\\n        address indexed agreementClass,\\n        address indexed account,\\n        uint256 slotId\\n    );\\n\\n    /**\\n     * @dev Get data of the slot of the state of a agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account to query\\n     * @param slotId slot id of the state\\n     * @param dataLength length of the state data\\n     */\\n    function getAgreementStateSlot(\\n        address agreementClass,\\n        address account,\\n        uint256 slotId,\\n        uint dataLength\\n    )\\n        external view\\n        returns (bytes32[] memory slotData);\\n\\n    /**\\n     * @dev Agreement account state updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account of the agrement\\n     * @param state Agreement state of the account\\n     */\\n    event AgreementAccountStateUpdated(\\n        address indexed agreementClass,\\n        address indexed account,\\n        bytes state\\n    );\\n\\n    /**\\n     * @dev Settle balance from an account by the agreement.\\n     *      The agreement needs to make sure that the balance delta is balanced afterwards\\n     * @param account Account to query.\\n     * @param delta Amount of balance delta to be settled\\n     *\\n     * Modifiers:\\n     *  - onlyAgreement\\n     */\\n    function settleBalance(\\n        address account,\\n        int256 delta\\n    )\\n        external;\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param rewardAccount Account that collect the reward\\n     * @param rewardAmount Amount of liquidation reward\\n     */\\n    event AgreementLiquidated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed rewardAccount,\\n        uint256 rewardAmount\\n    );\\n\\n    /**\\n     * @dev System bailout occurred (DEPRECATIED BY AgreementLiquidatedBy)\\n     * @param bailoutAccount Account that bailout the penalty account\\n     * @param bailoutAmount Amount of account bailout\\n     */\\n    event Bailout(\\n        address indexed bailoutAccount,\\n        uint256 bailoutAmount\\n    );\\n\\n    /**\\n     * @dev Agreement liquidation event (including agent account)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param liquidatorAccount Account of the agent that performed the liquidation.\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param bondAccount Account that collect the reward or bailout accounts\\n     * @param rewardAmount Amount of liquidation reward\\n     * @param bailoutAmount Amount of liquidation bailouot\\n     *\\n     * NOTE:\\n     * Reward account rule:\\n     * - if bailout is equal to 0, then\\n     *   - the bondAccount will get the rewardAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount.\\n     * - if bailout is larger than 0, then\\n     *   - the liquidatorAccount will get the rewardAmouont,\\n     *   - the bondAccount will pay for both the rewardAmount and bailoutAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount while get the bailoutAmount.\\n     */\\n    event AgreementLiquidatedBy(\\n        address liquidatorAccount,\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed bondAccount,\\n        uint256 rewardAmount,\\n        uint256 bailoutAmount\\n    );\\n\\n    /**\\n     * @dev Make liquidation payouts\\n     * @param id Agreement ID\\n     * @param liquidator Address of the executer of liquidation\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param rewardAmount Amount of liquidation reward\\n     * @param bailoutAmount Amount of account bailout needed\\n     *\\n     * NOTE:\\n     * Liquidation rules:\\n     *  - If a bailout is required (bailoutAmount > 0)\\n     *     - the actual reward goes to the liquidator,\\n     *     - while the reward account becomes the bailout account\\n     *     - total bailout include: bailout amount + reward amount\\n     *\\n     * Modifiers:\\n     *  - onlyAgreement\\n     */\\n    function makeLiquidationPayouts\\n    (\\n        bytes32 id,\\n        address liquidator,\\n        address penaltyAccount,\\n        uint256 rewardAmount,\\n        uint256 bailoutAmount\\n    )\\n        external;\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * NOTE: solidity-coverage not supporting it\\n     *************************************************************************/\\n\\n     /// @dev The msg.sender must be host contract\\n     //modifier onlyHost() virtual;\\n\\n    /// @dev The msg.sender must be a listed agreement.\\n    //modifier onlyAgreement() virtual;\\n\\n}\\n\",\"keccak256\":\"0xc658bc41894eecb8f64de68b92011c66b9ae2ec4d0373321c3f558a527f8ecc4\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ERC20WithTokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.5.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenInfo } from \\\"./TokenInfo.sol\\\";\\n\\n\\n/**\\n *\\n * @dev Interface for ERC20 token with token info\\n *\\n * NOTE: Using abstract contract instead of interfaces because old solidity\\n * does not support interface inheriting other interfaces\\n * solhint-disable-next-line no-empty-blocks\\n *\\n */\\n// solhint-disable-next-line no-empty-blocks\\nabstract contract ERC20WithTokenInfo is IERC20, TokenInfo {}\\n\",\"keccak256\":\"0x808d3a486826e7f119671174a77896c6e23578e691625350dbb3e9f74a0d5137\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/TokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.5.0;\\n\\n/**\\n * @dev ERC20 token info interface\\n *\\n * NOTE: ERC20 standard interface does not specify these functions, but\\n * often the token implementations have them.\\n *\\n */\\ninterface TokenInfo {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x4dee21b8f64edbfe811a300d31f529b5367d1186d69b8b2b8dc3373be7a108b0\",\"license\":\"AGPLv3\"},\"contracts/Common/SFHelper.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.4;\\n\\nimport { ISuperfluid, ISuperToken, ISuperApp } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport { IConstantFlowAgreementV1 } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\\\";\\nimport { IInstantDistributionAgreementV1 } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @title Superfluid helper library\\n * @author rashtrakoff\\n * @dev Contains functions which help in interacting with Superfluid contracts\\n * @custom:experimental This is an experimental contract/library. Use at your own risk.\\n */\\n// solhint-disable not-rely-on-time\\nlibrary SFHelper {\\n    event NewSupertokenAdded(\\n        address _superToken,\\n        address _underlyingToken,\\n        uint32 _index\\n    );\\n\\n    ISuperfluid public constant HOST =\\n        ISuperfluid(0x3E14dC1b13c488a8d5D310918780c983bD5982E7);\\n    IConstantFlowAgreementV1 public constant CFA_V1 =\\n        IConstantFlowAgreementV1(0x6EeE6060f715257b970700bc2656De21dEdF074C);\\n    IInstantDistributionAgreementV1 public constant IDA_V1 =\\n        IInstantDistributionAgreementV1(\\n            0xB0aABBA4B2783A72C52956CDEF62d438ecA2d7a1\\n        );\\n\\n    /**\\n     * @dev Function to distribute a supertoken amount according to an index\\n     * @param _superToken The supertoken to be distributed\\n     * @param _index Index containing share details\\n     * @param _amount Amount of `_supertoken` to be distributed\\n     */\\n    function distribute(\\n        ISuperToken _superToken,\\n        uint32 _index,\\n        uint256 _amount\\n    ) external returns (bytes memory _newCtx) {\\n        (uint256 _actualAmount, ) = IDA_V1.calculateDistribution(\\n            _superToken,\\n            address(this),\\n            _index,\\n            _amount\\n        );\\n\\n        require(_amount >= _actualAmount, \\\"SFHelper: !enough tokens\\\");\\n\\n        _newCtx = HOST.callAgreement(\\n            IDA_V1,\\n            abi.encodeWithSelector(\\n                IDA_V1.distribute.selector,\\n                _superToken,\\n                _index,\\n                _actualAmount,\\n                new bytes(0)\\n            ),\\n            new bytes(0)\\n        );\\n\\n        // console.log(\\\"Actual amount distributed: %s\\\", _actualAmount);\\n    }\\n\\n    /**\\n     * @dev Function to create a distribution index\\n     * @param _superToken The supertoken to be distributed\\n     * @param _index New index value containing share details\\n     * @param _ctx Superfluid context object\\n     * This function should only be called from a superapp callback\\n     */\\n    function createIndexInCallback(\\n        ISuperToken _superToken,\\n        uint32 _index,\\n        bytes calldata _ctx\\n    ) external returns (bytes memory _newCtx) {\\n        (_newCtx, ) = HOST.callAgreementWithContext(\\n            IDA_V1,\\n            abi.encodeWithSelector(\\n                IDA_V1.createIndex.selector,\\n                _superToken,\\n                _index,\\n                new bytes(0) // placeholder ctx\\n            ),\\n            new bytes(0), // userData\\n            _ctx\\n        );\\n\\n        emit NewSupertokenAdded(\\n            _superToken.getUnderlyingToken(),\\n            address(_superToken),\\n            _index\\n        );\\n    }\\n\\n    /**\\n     * @dev Function to update shares of a user\\n     * @param _superStreamToken The supertoken that the user is streaming\\n     * @param _superDistToken The supertoken that's distributed in index with value `_index`\\n     * @param _index Index containing share details\\n     * @param _ctx Superfluid context object\\n     */\\n    function updateSharesInCallback(\\n        ISuperToken _superStreamToken,\\n        ISuperToken _superDistToken,\\n        uint32 _index,\\n        bytes calldata _ctx\\n    ) external returns (bytes memory _newCtx) {\\n        address _msgSender = HOST.decodeCtx(_ctx).msgSender;\\n        (, int96 _flowRate) = getFlow(_superStreamToken, _msgSender);\\n        uint256 _userFlowRate = uint256(uint96(_flowRate));\\n\\n        (_newCtx, ) = HOST.callAgreementWithContext(\\n            IDA_V1,\\n            abi.encodeWithSelector(\\n                IDA_V1.updateSubscription.selector,\\n                _superDistToken,\\n                _index,\\n                _msgSender,\\n                uint128(_userFlowRate / 1e9),\\n                new bytes(0)\\n            ),\\n            new bytes(0),\\n            _ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Function to close a stream\\n     * @dev This function should be called provided the app is jailed or user is running low on supertokens\\n     * @param _superToken The supertoken that the user is streaming\\n     * @param _user Address of the user\\n     */\\n    function emergencyCloseStream(ISuperToken _superToken, address _user)\\n        external\\n    {\\n        bool _close;\\n\\n        // Check whether the app is jailed and if so, proceed with stream termination\\n        if (HOST.isAppJailed(ISuperApp(address(this)))) _close = true;\\n        else {\\n            int96 _flowRate = CFA_V1.getNetFlow(_superToken, _user);\\n\\n            if (_flowRate < 0) {\\n                uint256 _balance = _superToken.balanceOf(_user);\\n                uint256 _positiveFlowRate = uint256(uint96(-1 * _flowRate));\\n\\n                // console.log(\\\"Balance: %s, +flowRate: %s\\\", _balance, _positiveFlowRate);\\n\\n                // if user has less liquidity ( <= 12 hours worth) close the stream\\n                if (_balance <= _positiveFlowRate * 12 hours) _close = true;\\n            }\\n        }\\n\\n        if (_close) {\\n            HOST.callAgreement(\\n                CFA_V1,\\n                abi.encodeWithSelector(\\n                    CFA_V1.deleteFlow.selector,\\n                    _superToken,\\n                    _user,\\n                    address(this),\\n                    new bytes(0) // placeholder\\n                ),\\n                \\\"0x\\\"\\n            );\\n        } else revert(\\\"SFHelper: No emergency close\\\");\\n    }\\n\\n    /**\\n     * @dev Calculates uninvested amount of a user\\n     * @param _superToken Token being streamed\\n     * @param _user Address of the user\\n     * @param _lastDepositAt Last time a token was deposited to a dHEDGE pool\\n     * @return _userUninvested User's uninvested amount\\n     */\\n    function calcUserUninvested(\\n        ISuperToken _superToken,\\n        address _user,\\n        uint256 _lastDepositAt\\n    ) external view returns (uint256) {\\n        (/* uint256 _userPrevUpdateTimestamp */, int96 _flowRate) = getFlow(\\n            _superToken,\\n            _user\\n        );\\n        uint256 _userFlowRate = uint256(uint96(_flowRate));\\n\\n        // return\\n        //     _userFlowRate *\\n        //     (block.timestamp -\\n        //         (\\n        //             (_userPrevUpdateTimestamp > _lastDepositAt)\\n        //                 ? _userPrevUpdateTimestamp\\n        //                 : _lastDepositAt\\n        //         ));\\n        return _userFlowRate * (block.timestamp - _lastDepositAt);\\n    }\\n\\n    /**\\n     *@notice Function to get the flow rate of a user\\n     * @param _superToken Address of the supertoken\\n     * @param _sender Address of the user\\n     * @return _timestamp Timestamp corresponding to previous stream rate update time\\n     * @return _flowRate Flow rate of a user\\n     */\\n    function getFlow(ISuperToken _superToken, address _sender)\\n        public\\n        view\\n        returns (uint256 _timestamp, int96 _flowRate)\\n    {\\n        (_timestamp, _flowRate, , ) = CFA_V1.getFlow(\\n            _superToken,\\n            _sender,\\n            address(this)\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x719f4a2d2ce4a59a116c9e7612bdfee602584a9e3ad2382d294ab64f3d2fe4ef\",\"license\":\"Unlicensed\"},\"contracts/dHedge-Factory-Version/Interfaces/IdHedge.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.4;\\n\\ninterface IPoolLogic {\\n    /// @notice Deposit funds into the pool\\n    /// @param _asset Address of the token\\n    /// @param _amount Amount of tokens to deposit\\n    /// @return liquidityMinted Amount of liquidity minted\\n    function deposit(address _asset, uint256 _amount)\\n        external\\n        returns (uint256 liquidityMinted);\\n\\n    /// @notice Withdraw assets based on the fund token amount\\n    /// @param _fundTokenAmount the fund token amount\\n    function withdraw(uint256 _fundTokenAmount) external;\\n\\n    /// @notice Pool manager logic address for a pool\\n    function poolManagerLogic() external view returns (address);\\n\\n    /// @notice Get exit remaining time of the pool\\n    /// @return remaining The remaining exit time of the pool\\n    function getExitRemainingCooldown(address sender)\\n        external\\n        view\\n        returns (uint256 remaining);\\n}\\n\\ninterface IPoolManagerLogic {\\n    struct Asset {\\n        address asset;\\n        bool isDeposit;\\n    }\\n\\n    /// @notice Get all the supported assets\\n    /// @return Return array of supported assets\\n    function getSupportedAssets() external view returns (Asset[] memory);\\n\\n    /// @notice Get all the deposit assets\\n    /// @return Return array of deposit assets' addresses\\n    function getDepositAssets() external view returns (address[] memory);\\n\\n    /// @notice Return true if it's supported asset, false otherwise\\n    /// @param asset address of the asset\\n    function isSupportedAsset(address asset) external view returns (bool);\\n\\n    /// @notice Return true if it's deposit asset, false otherwise\\n    /// @param asset address of the asset\\n    function isDepositAsset(address asset) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x9dce09a82a2736d0547b019b9d4961c9b536b90e5d6da6ebbfc4acbe25d9aba5\",\"license\":\"Unlicensed\"},\"contracts/dHedge-Factory-Version/Interfaces/IdHedgeCoreFactory.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.4;\\n\\ninterface IdHedgeCoreFactory {\\n    event CoreCreated(address _newCore, address _pool, address _poolSuperToken);\\n    event FeeRateChanged(uint32 _newFeeRate);\\n    event DAOAddressChanged(address _newDAO);\\n\\n    function dao() external view returns (address);\\n\\n    function defaultFeeRate() external view returns (uint32);\\n}\\n\",\"keccak256\":\"0x6ce5816e3a5831850d9d32ed864dffd99de683dd2ec6ac83a2fe5d5e6ee43d8c\",\"license\":\"Unlicensed\"},\"contracts/dHedge-Factory-Version/Libraries/dHedgeHelper.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.4;\\n\\nimport { IPoolLogic, IPoolManagerLogic } from \\\"../Interfaces/IdHedge.sol\\\";\\nimport { IdHedgeCoreFactory } from \\\"../Interfaces/IdHedgeCoreFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./dHedgeStorage.sol\\\";\\nimport \\\"../../Common/SFHelper.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @title Modified IERC20 interface\\n * @dev This interface is used to access decimals of an ERC20 token\\n */\\ninterface IERC20Mod {\\n    function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @title dHedge helper library\\n * @author rashtrakoff\\n * @dev Contains functions for interacting with dHedge protocol pools\\n * @custom:experimental This is an experimental contract/library. Use at your own risk.\\n */\\n// solhint-disable reason-string\\n// solhint-disable not-rely-on-time\\n// solhint-disable contract-name-camelcase\\nlibrary dHedgeHelper {\\n    using SafeERC20 for IERC20;\\n    using SFHelper for ISuperToken;\\n\\n    event TokenDeposited(\\n        address _token,\\n        uint256 _amount,\\n        uint256 _liquidityMinted\\n    );\\n\\n    /**\\n     * @dev Function to deposit tokens into a dHedge pool\\n     * @param _dHedgePool Struct containing details regarding the pool and various tokens in it\\n     * @param _depositToken Address of the underlying token (deposit token and not the supertoken)\\n     */\\n    function deposit(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        address _depositToken\\n    ) external {\\n        require(\\n            (block.timestamp -\\n                _dHedgePool.tokenData[_depositToken].lastDepositAt) >= 24 hours,\\n            \\\"dHedgeHelper: Time difference exceeds limit\\\"\\n        );\\n\\n        IPoolLogic _poolLogic = IPoolLogic(_dHedgePool.poolLogic);\\n        IPoolManagerLogic _supportLogic = IPoolManagerLogic(\\n            _poolLogic.poolManagerLogic()\\n        );\\n\\n        // If the asset is currently accepted as deposit then perform deposit transaction\\n        if (_supportLogic.isDepositAsset(_depositToken)) {\\n            dHedgeStorage.TokenData storage tokenData = _dHedgePool.tokenData[\\n                _depositToken\\n            ];\\n\\n            // Downgrade all supertokens to their underlying tokens\\n            tokenData.superToken.downgrade(\\n                tokenData.superToken.balanceOf(address(this))\\n            );\\n\\n            uint256 _depositBalance = IERC20(_depositToken).balanceOf(\\n                address(this)\\n            );\\n\\n            // Calculate fee to be collected\\n            uint256 _feeCollected = (_depositBalance *\\n                IdHedgeCoreFactory(_dHedgePool.factory).defaultFeeRate()) / 1e6;\\n\\n            _depositBalance -= _feeCollected;\\n\\n            // Perform deposit transaction iff amount of underlying tokens is greater than 0\\n            if (_depositBalance > 0) {\\n                // Store the timestamp of last time a deposit & distribution was made\\n                tokenData.lastDepositAt = block.timestamp;\\n\\n                // Transfer the fees collected to the owner\\n                IERC20(_depositToken).safeTransfer(\\n                    IdHedgeCoreFactory(_dHedgePool.factory).dao(),\\n                    _feeCollected\\n                );\\n\\n                // Deposit the tokens into the dHedge pool\\n                uint256 _liquidityMinted = _poolLogic.deposit(\\n                    _depositToken,\\n                    _depositBalance\\n                );\\n\\n                // Upgrade recently minted DHPT to DHPTx\\n                _dHedgePool.DHPTx.upgrade(_liquidityMinted);\\n\\n                // Distribute the DHPTx to streamers\\n                _dHedgePool.DHPTx.distribute(\\n                    tokenData.distIndex,\\n                    _dHedgePool.DHPTx.balanceOf(address(this))\\n                );\\n\\n                // Following console logs are required for manual verification of some tests\\n                // console.log(\\n                //     \\\"Liquidity minted for token %s: %s\\\",\\n                //     _depositToken,\\n                //     _liquidityMinted\\n                // );\\n\\n                // console.log(\\n                //     \\\"Fee collected for token %s: %s\\\",\\n                //     _depositToken,\\n                //     _feeCollected\\n                // );\\n\\n                emit TokenDeposited(\\n                    _depositToken,\\n                    _depositBalance,\\n                    _liquidityMinted\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper function that's called after agreements are created, updated or terminated\\n     * @param _agreementClass Address of the agreement calling this function\\n     * @param _underlyingToken Address of the underlying token on which operations need to be performed\\n     * @param _ctx Superfluid context object\\n     * @param _cbdata Callback data we passed before agreement was created, updated or terminated\\n     * @param _newCtx New Superfluid context object\\n     */\\n    function afterAgreement(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        address _agreementClass,\\n        address _underlyingToken,\\n        bytes memory _ctx,\\n        bytes memory _cbdata\\n    ) external returns (bytes memory _newCtx) {\\n        _newCtx = _ctx;\\n\\n        if (\\n            ISuperAgreement(_agreementClass).agreementType() ==\\n            keccak256(\\n                \\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"\\n            )\\n        ) {\\n            address _sender = SFHelper.HOST.decodeCtx(_newCtx).msgSender;\\n            uint256 _userUninvested = abi.decode(_cbdata, (uint256));\\n\\n            dHedgeStorage.TokenData storage tokenData = _dHedgePool.tokenData[\\n                _underlyingToken\\n            ];\\n            (, int96 _flowRate) = tokenData.superToken.getFlow(_sender);\\n            uint256 _currFlowRate = uint256(uint96(_flowRate));\\n            \\n            // Not really necessary ?\\n            assert(\\n                _userUninvested <= tokenData.superToken.balanceOf(address(this))\\n            );\\n\\n            // Return some amount if previous flow rate was higher than the current one after update\\n            uint256 _depositAmount = (block.timestamp -\\n                tokenData.lastDepositAt) * _currFlowRate;\\n\\n            bool success;\\n            if (_depositAmount > _userUninvested) {\\n                // console.log(\\\"Reached here 1\\\");\\n\\n                success = tokenData.superToken.transferFrom(\\n                    _sender,\\n                    address(this),\\n                    _depositAmount - _userUninvested\\n                );\\n            } else if (_depositAmount < _userUninvested) {\\n                // console.log(\\\"Reached here 2\\\");\\n\\n                success = tokenData.superToken.transfer(\\n                    _sender,\\n                    _userUninvested - _depositAmount\\n                );\\n            }\\n\\n            require(success, \\\"dHedgeHelper: Buffer transfer failed\\\");\\n\\n            _newCtx = tokenData.superToken.updateSharesInCallback(\\n                _dHedgePool.DHPTx,\\n                tokenData.distIndex,\\n                _newCtx\\n            );\\n\\n\\n            // require(\\n            //     tokenData.superToken.transfer(_sender, _userUninvested),\\n            //     \\\"dHedgeHelper: Uninvested amount transfer failed\\\"\\n            // );\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper function that's called before agreements are created, updated or terminated\\n     * @param _agreementClass Address of the agreement calling this function\\n     * @param _underlyingToken Address of the underlying token on which operations need to be performed\\n     * @param _ctx Context data of a user provided by SF contract\\n     * @return _cbdata Callback data that needs to be passed on to _afterAgreementCFA function\\n     */\\n    function beforeAgreement(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        address _agreementClass,\\n        address _underlyingToken,\\n        bytes memory _ctx\\n    ) external view returns (bytes memory _cbdata) {\\n        _cbdata = new bytes(0);\\n\\n        if (\\n            ISuperAgreement(_agreementClass).agreementType() ==\\n            keccak256(\\n                \\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"\\n            )\\n        ) {\\n            address _sender = SFHelper.HOST.decodeCtx(_ctx).msgSender;\\n\\n            _cbdata = abi.encode(\\n                calcUserUninvested(_dHedgePool, _sender, _underlyingToken)\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Function which checks if deposit function can be called or not\\n     * @param _dHedgePool Struct containing details regarding the pool and various tokens in it\\n     * @return _reqUpkeep Boolean depicting need for upkeep\\n     * @return _depositToken Address of the underlying token (deposit token and not the supertoken)\\n     * This function is useful for on-chain keepers. Deposit function should only be called if `_reqUpkeep` is true\\n     * let whatever be the address of the `_depositToken`\\n     */\\n    function requireUpkeep(dHedgeStorage.dHedgePool storage _dHedgePool)\\n        external\\n        view\\n        returns (bool _reqUpkeep, address _depositToken)\\n    {\\n        if (_dHedgePool.isActive) {\\n            IPoolLogic _poolLogic = IPoolLogic(_dHedgePool.poolLogic);\\n            IPoolManagerLogic _supportLogic = IPoolManagerLogic(\\n                _poolLogic.poolManagerLogic()\\n            );\\n\\n            // Get assets currently supported by the dHedge pool\\n            address[] memory _depositAssets = _supportLogic.getDepositAssets();\\n\\n            for (uint8 i = 0; i < _depositAssets.length; ++i) {\\n                _depositToken = _depositAssets[i];\\n                dHedgeStorage.TokenData storage tokenData = _dHedgePool\\n                    .tokenData[_depositToken];\\n\\n                // If supertoken for an underlying token exists then proceed with the deposit\\n                if (\\n                    address(tokenData.superToken) != address(0) &&\\n                    (block.timestamp - tokenData.lastDepositAt) >= 24 hours\\n                ) {\\n                    uint256 _depositBalance = tokenData.superToken.balanceOf(\\n                        address(this)\\n                    ) / (10**(18 - IERC20Mod(_depositToken).decimals()));\\n\\n                    if (_depositBalance > 0) return (true, _depositToken);\\n                }\\n            }\\n        }\\n\\n        return (false, address(0));\\n    }\\n\\n    /**\\n     * @dev Function to calculate uninvested amount of a user to return that after stream updation/termination\\n     * @param _dHedgePool Struct containing details regarding the pool and various tokens in it\\n     * @param _user Address of the user whose uninvested amount has to be calculated\\n     * @param _depositToken Address of the underlying token (deposit token and not the supertoken)\\n     * @return Amount representing user's uninvested amount\\n     */\\n    function calcUserUninvested(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        address _user,\\n        address _depositToken\\n    ) public view returns (uint256) {\\n        dHedgeStorage.TokenData storage tokenData = _dHedgePool.tokenData[\\n            _depositToken\\n        ];\\n\\n        return\\n            tokenData.superToken.calcUserUninvested(\\n                _user,\\n                tokenData.lastDepositAt\\n            );\\n    }\\n\\n    /**\\n     * @dev Wrapper function to check if an asset is accepted as deposit asset in a dHedge pool\\n     * @param _dHedgePool Struct containing details regarding the pool and various tokens in it\\n     * @param _token Address of the token to be deposited\\n     * @return Boolean representing the status of the token for deposition\\n     */\\n    function isDepositAsset(\\n        dHedgeStorage.dHedgePool storage _dHedgePool,\\n        address _token\\n    ) public view returns (bool) {\\n        IPoolLogic _poolLogic = IPoolLogic(_dHedgePool.poolLogic);\\n        IPoolManagerLogic _supportLogic = IPoolManagerLogic(\\n            _poolLogic.poolManagerLogic()\\n        );\\n\\n        return _supportLogic.isDepositAsset(_token);\\n    }\\n}\\n\",\"keccak256\":\"0xe720f6b7b96dce41739ab2a2bc41c25fab579502f495e4a73fa92b5d88acb681\",\"license\":\"Unlicensed\"},\"contracts/dHedge-Factory-Version/Libraries/dHedgeStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.4;\\n\\nimport {ISuperfluid, ISuperToken, ISuperApp, ISuperAgreement, SuperAppDefinitions} from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport {IConstantFlowAgreementV1} from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\\\";\\nimport {IInstantDistributionAgreementV1} from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\\\";\\n\\n/**\\n * @title dHedge storage library\\n * @author rashtrakoff\\n * @dev Contains a struct which defines a dHedge pool for a core contract\\n * @custom:experimental This is an experimental contract/library. Use at your own risk.\\n */\\n// solhint-disable contract-name-camelcase\\n// solhint-disable var-name-mixedcase\\nlibrary dHedgeStorage {\\n    /**\\n     * @param superToken Contains supported supertoken of an underlying token.\\n     * @param distIndex IDA distribution index with respect to an underlying token.\\n     * @param lastDepositAt Latest timestamp of when an underlying token was deposited to a dHEDGE pool.\\n     */\\n    struct TokenData {\\n        ISuperToken superToken;\\n        uint32 distIndex;\\n        uint256 lastDepositAt;\\n    }\\n\\n    /**\\n     * @notice Struct containing data related to a dHEDGE pool and it's corresponding core contract.\\n     * @param isActive Status of contract representing a dHEDGE pool.\\n     * @param DHPTx DHP super token for a dHEDGE pool.\\n     * @param factory Factory contract which deployed the core contract\\n     * @param poolLogic Address of a dHEDGE pool.\\n     * @param latestDistIndex Latest index created for distributing DHPTx according to a deposit token stream rate\\n     * of a user\\n     * between deposits in order to guard against perpetual cooldown issues\\n     * @param tokenData Contains data regarding a market/deposit token\\n     */\\n    struct dHedgePool {\\n        bool isActive;\\n        ISuperToken DHPTx; \\n        address factory;\\n        address poolLogic;\\n        uint32 latestDistIndex;\\n        mapping(address => TokenData) tokenData;\\n    }\\n}\\n\",\"keccak256\":\"0xb75a276b7f9f2fc8d8c6f67f23ca1f4bc3bc5b3a835f6085786f2581c1036884\",\"license\":\"Unlicensed\"},\"contracts/dHedge-Factory-Version/dHedgeCore.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.4;\\n\\nimport { ISuperfluid, ISuperToken, ISuperAgreement, SuperAppDefinitions } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport { IConstantFlowAgreementV1 } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\\\";\\nimport { IInstantDistributionAgreementV1 } from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\\\";\\nimport { SuperAppBase } from \\\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperAppBase.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./Libraries/dHedgeHelper.sol\\\";\\nimport \\\"./Libraries/dHedgeStorage.sol\\\";\\nimport \\\"./Interfaces/IdHedgeCoreFactory.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @title Core contract for streaming into a dHedge pool\\n * @author rashtrakoff\\n * @notice Contains user facing functions\\n * @custom:experimental This is an experimental contract/library. Use at your own risk.\\n */\\n// solhint-disable not-rely-on-time\\n// solhint-disable reason-string\\n// solhint-disable var-name-mixedcase\\n// solhint-disable-next-line contract-name-camelcase\\ncontract dHedgeCore is Initializable, SuperAppBase {\\n    using SafeERC20 for IERC20;\\n    using dHedgeHelper for dHedgeStorage.dHedgePool;\\n    using SFHelper for ISuperToken;\\n\\n    event EmergencyWithdraw(address _token);\\n\\n    // Struct containing all the relevant data regarding the dHedgePool this dHedgeCore serves\\n    dHedgeStorage.dHedgePool private poolData;\\n\\n    /// @dev Initialize the factory\\n    /// @param _dHedgePool dHEDGE pool contract address\\n    /// @param _DHPTx Supertoken corresponding to the DHPT of the pool\\n    function initialize(address _dHedgePool, ISuperToken _DHPTx)\\n        external\\n        initializer\\n    {\\n        poolData.isActive = true;\\n        poolData.factory = msg.sender;\\n        poolData.DHPTx = _DHPTx;\\n        poolData.poolLogic = _dHedgePool;\\n\\n        IERC20(_dHedgePool).safeIncreaseAllowance(\\n            address(_DHPTx),\\n            type(uint256).max\\n        );\\n    }\\n\\n    /**************************************************************************\\n     * Core functions\\n     *************************************************************************/\\n\\n    /// @notice Converts supertokens to underlying tokens and deposits them into dHedge pool\\n    /// @param _token Address of the underlying token to be deposited into dHedge pool\\n    function dHedgeDeposit(address _token) external {\\n        _onlyActive();\\n        poolData.deposit(_token);\\n    }\\n\\n    /// @dev Function to withdraw a token in case of emergency\\n    /// @param _token Address of the pool token\\n    /// @custom:note Remove/Modify this function after testing\\n    function emergencyWithdraw(address _token) external {\\n        _onlyOwner(msg.sender);\\n        IERC20(_token).safeTransfer(\\n            IdHedgeCoreFactory(poolData.factory).dao(),\\n            IERC20(_token).balanceOf(address(this))\\n        );\\n\\n        emit EmergencyWithdraw(_token);\\n    }\\n\\n    /// @dev Deactivates a dHedgeCore contract\\n    function deactivateCore() external {\\n        _onlyOwner(msg.sender);\\n        _onlyActive();\\n\\n        poolData.isActive = false;\\n    }\\n\\n    /// @dev Reactivates a dHedgeCore contract\\n    function reactivateCore() external {\\n        _onlyOwner(msg.sender);\\n        require(!poolData.isActive, \\\"dHedgeCore: Pool already active\\\");\\n\\n        poolData.isActive = true;\\n    }\\n\\n    /// @notice Closes a supertoken stream if core is jailed or user is running low on balance\\n    /// @param _superToken Supertoken being streamed\\n    /// @param _user Address of the user whose stream needs to be closed\\n    /// @dev Any user's stream can be closed by anyone provided the app is jailed\\n    /// or user doesn't have enough amount to stream for more than 12 hours\\n    function emergencyCloseStream(ISuperToken _superToken, address _user)\\n        external\\n    {\\n        _superToken.emergencyCloseStream(_user);\\n    }\\n\\n    /// @notice Checks if the core is active or not\\n    /// @return Boolean indicating working status of core\\n    function checkCoreActive() external view returns (bool) {\\n        return poolData.isActive;\\n    }\\n\\n    // /// @notice Gets pool address\\n    // /// @return Returns address of the dHedge pool this core contract serves\\n    // function getPoolLogic() external view returns (address) {\\n    //     return poolData.poolLogic;\\n    // }\\n\\n    /// @dev Gets the latest distribution index created\\n    /// @return Number corresponding to the latest created index\\n    /// This function can also be used to get number of tokens supported by this dHedgeCore\\n    function getLatestDistIndex() external view returns (uint32) {\\n        return poolData.latestDistIndex;\\n    }\\n\\n    /// @dev Gets the distribution index corresponding to an underlying token\\n    /// @param _token Address of a deposit token\\n    /// @return Boolean depicting if a distribution index exists for `_token`\\n    /// @return Number representing the index value corresponding to `_token` if it exists\\n    function getTokenDistIndex(address _token)\\n        external\\n        view\\n        returns (bool, uint32)\\n    {\\n        if (address(poolData.tokenData[_token].superToken) != address(0))\\n            return (true, poolData.tokenData[_token].distIndex);\\n\\n        return (false, 0);\\n    }\\n\\n    /// @notice Calculates uninvested token amount of a particular user\\n    /// @param _user Address of the user whose uninvested amount needs to be calculated\\n    /// @param _token Address of the underlying token\\n    /// @return Amount of uninvested tokens\\n    function calcUserUninvested(address _user, address _token)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return poolData.calcUserUninvested(_user, _token);\\n    }\\n\\n    /// @dev Checks if deposit action can be performed\\n    /// @return Boolean indicating if upkeep/deposit can be performed\\n    /// @return Address of the underlying/deposit token which needs to be deposited to the dHedge pool\\n    function requireUpkeep() public view returns (bool, address) {\\n        return poolData.requireUpkeep();\\n    }\\n\\n    // function _transferBuffer(\\n    //     ISuperToken _superToken,\\n    //     uint256 _lastDepositAt,\\n    //     bytes memory _ctx\\n    // ) internal {\\n    //     address _user = SFHelper.HOST.decodeCtx(_ctx).msgSender;\\n\\n    //     (, int96 _flowRate) = _superToken.getFlow(_user);\\n\\n    //     require(\\n    //         _superToken.transferFrom(\\n    //             _user,\\n    //             address(this),\\n    //             (block.timestamp - _lastDepositAt) * uint256(uint96(_flowRate))\\n    //         ),\\n    //         \\\"dHedgeCore: Buffer transfer failed\\\"\\n    //     );\\n    // }\\n\\n    /// @dev Checks status of the core and reverts if inactive\\n    function _onlyActive() internal view {\\n        require(poolData.isActive, \\\"dHedgeCore: Pool inactive\\\");\\n    }\\n\\n    /// @dev Equivalent to onlyOwner modifier\\n    function _onlyOwner(address _user) internal view {\\n        require(\\n            _user == Ownable(poolData.factory).owner(),\\n            \\\"dHedgeCore: Not the owner\\\"\\n        );\\n    }\\n\\n    /// @dev Checks if the caller is the SF host contract\\n    function _onlyHost() internal view {\\n        require(\\n            msg.sender == address(SFHelper.HOST),\\n            \\\"dHedgeCore: Supports only one host\\\"\\n        );\\n    }\\n\\n    /// @dev Checks if the agreement is of type CFA or IDA\\n    function _onlyExpected(address _agreementClass) internal view {\\n        require(\\n            ISuperAgreement(_agreementClass).agreementType() ==\\n                keccak256(\\n                    \\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"\\n                ) ||\\n                ISuperAgreement(_agreementClass).agreementType() ==\\n                keccak256(\\n                    \\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\"\\n                ),\\n            \\\"dHedgeCore: Callback called illegaly\\\"\\n        );\\n    }\\n\\n    /**************************************************************************\\n     * SuperApp callbacks\\n     *************************************************************************/\\n\\n    function beforeAgreementCreated(\\n        ISuperToken _superToken,\\n        address _agreementClass,\\n        bytes32, /*agreementId*/\\n        bytes calldata, /*agreementData*/\\n        bytes calldata // _ctx\\n    ) external view override returns (bytes memory _cbdata) {\\n        _onlyHost();\\n        _onlyExpected(_agreementClass);\\n        _onlyActive();\\n\\n        address _underlyingToken = _superToken.getUnderlyingToken();\\n        ISuperToken _superStreamToken = poolData\\n            .tokenData[_underlyingToken]\\n            .superToken;\\n\\n        require(\\n            address(_superStreamToken) == address(0) ||\\n                _superStreamToken == _superToken,\\n            \\\"dHedgeCore: Supertoken not supported\\\"\\n        );\\n        require(\\n            poolData.isDepositAsset(_underlyingToken),\\n            \\\"dHedgeCore: Not deposit asset\\\"\\n        );\\n\\n        _cbdata = new bytes(0);\\n    }\\n\\n    function afterAgreementCreated(\\n        ISuperToken _superToken,\\n        address _agreementClass,\\n        bytes32, // _agreementId,\\n        bytes calldata, // _agreementData,\\n        bytes calldata, // _cbdata,\\n        bytes calldata _ctx\\n    ) external override returns (bytes memory _newCtx) {\\n        _onlyHost();\\n        _onlyExpected(_agreementClass);\\n        _newCtx = _ctx;\\n\\n        address _underlyingToken = _superToken.getUnderlyingToken();\\n        dHedgeStorage.TokenData storage tokenData = poolData.tokenData[\\n            _underlyingToken\\n        ];\\n\\n        /* \\n            Check if the underlying token is enabled as deposit asset. If not, \\n            revert the transaction as the tokens can't be deposited into the pool.\\n            If yes:\\n                Map supertoken to the underlying token.\\n                Unlimited approve underlying token to the dHedge pool.\\n        */\\n        if (address(tokenData.superToken) == address(0)) {\\n            tokenData.superToken = _superToken;\\n            tokenData.distIndex = poolData.latestDistIndex++;\\n\\n            // To calculate amount streamed after deployment but before first deposit\\n            tokenData.lastDepositAt = block.timestamp; \\n\\n            // console.log(\\n            //     \\\"Index for token %s: %s\\\",\\n            //     _underlyingToken,\\n            //     tokenData.distIndex\\n            // );\\n\\n            _newCtx = poolData.DHPTx.createIndexInCallback(\\n                tokenData.distIndex,\\n                _newCtx\\n            );\\n\\n            IERC20(_underlyingToken).safeIncreaseAllowance(\\n                poolData.poolLogic,\\n                type(uint256).max\\n            );\\n        }\\n\\n        // An upfront fee must be charged to avoid a user getting shares that might make them eligible to\\n        // receive profit even though they haven't streamed much.\\n        address _user = SFHelper.HOST.decodeCtx(_newCtx).msgSender;\\n\\n        (, int96 _flowRate) = _superToken.getFlow(_user);\\n\\n        require(\\n            _superToken.transferFrom(\\n                _user,\\n                address(this),\\n                (block.timestamp - tokenData.lastDepositAt) * uint256(uint96(_flowRate))\\n            ),\\n            \\\"dHedgeCore: Buffer transfer failed\\\"\\n        );\\n\\n        _newCtx = _superToken.updateSharesInCallback(\\n            poolData.DHPTx,\\n            tokenData.distIndex,\\n            _newCtx\\n        );\\n    }\\n\\n    function beforeAgreementUpdated(\\n        ISuperToken _superToken,\\n        address _agreementClass,\\n        bytes32, /*agreementId*/\\n        bytes calldata, /*agreementData*/\\n        bytes calldata _ctx\\n    ) external view override returns (bytes memory _cbdata) {\\n        _onlyHost();\\n        _onlyExpected(_agreementClass);\\n        _onlyActive();\\n\\n        _cbdata = poolData.beforeAgreement(\\n            _agreementClass,\\n            _superToken.getUnderlyingToken(),\\n            _ctx\\n        );\\n    }\\n\\n    function afterAgreementUpdated(\\n        ISuperToken _superToken,\\n        address _agreementClass,\\n        bytes32, //_agreementId,\\n        bytes calldata, //_agreementData,\\n        bytes calldata _cbdata, //_cbdata,\\n        bytes calldata _ctx\\n    ) external override returns (bytes memory _newCtx) {\\n        _onlyHost();\\n        _onlyExpected(_agreementClass);\\n        _newCtx = _ctx;\\n\\n        _newCtx = poolData.afterAgreement(\\n            _agreementClass,\\n            _superToken.getUnderlyingToken(),\\n            _newCtx,\\n            _cbdata\\n        );\\n\\n        // We are directly using `getUnderlyingToken` method because to update a flow, the flow first must\\n        // have been created during which this supertoken was mapped to the underlying token \\n        // i.e., this supertoken is acceptable to us\\n        // _transferBuffer(\\n        //     _superToken,\\n        //     poolData.tokenData[_superToken.getUnderlyingToken()].lastDepositAt,\\n        //     _newCtx\\n        // );\\n    }\\n\\n    /// @dev Remove internal checker functions and instead use if-else\\n    function beforeAgreementTerminated(\\n        ISuperToken _superToken,\\n        address _agreementClass,\\n        bytes32, /*agreementId*/\\n        bytes calldata, /*agreementData*/\\n        bytes calldata _ctx\\n    ) external view override returns (bytes memory _cbdata) {\\n        _onlyHost();\\n\\n        try\\n            poolData.beforeAgreement(\\n                _agreementClass,\\n                _superToken.getUnderlyingToken(),\\n                _ctx\\n            )\\n        returns (bytes memory _newCbData) {\\n            _cbdata = _newCbData;\\n        } catch (bytes memory _error) {\\n            console.logBytes(_error);\\n            _cbdata = new bytes(0);\\n        }\\n    }\\n\\n    function afterAgreementTerminated(\\n        ISuperToken _superToken,\\n        address _agreementClass,\\n        bytes32, //_agreementId,\\n        bytes calldata, // _agreementData,\\n        bytes calldata _cbdata, //_cbdata,\\n        bytes calldata _ctx\\n    ) external override returns (bytes memory _newCtx) {\\n        _onlyHost();\\n        _newCtx = _ctx;\\n\\n        try\\n            poolData.afterAgreement(\\n                _agreementClass,\\n                _superToken.getUnderlyingToken(),\\n                _newCtx,\\n                _cbdata\\n            )\\n        returns (bytes memory _modCtx) {\\n            _newCtx = _modCtx;\\n        } catch (bytes memory _error) {\\n            console.logBytes(_error);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4b2ea865bce2a5b03558fd473014ff5a553f8b0d7ca3f1b0db951d5538c325d5\",\"license\":\"Unlicensed\"},\"contracts/dHedge-Factory-Version/dHedgeCoreFactory.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.4;\\n\\nimport \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"./Interfaces/IdHedgeCoreFactory.sol\\\";\\nimport \\\"./dHedgeCore.sol\\\";\\n\\n// solhint-disable var-name-mixedcase\\n// solhint-disable-next-line contract-name-camelcase\\ncontract dHedgeCoreFactory is IdHedgeCoreFactory, Ownable {\\n    /// @dev The implementation contract for dHedgeCore can never be changed\\n    address public immutable implementation;\\n\\n    /// @notice The DAO which receives fees\\n    address public override dao;\\n\\n    /// @notice Fee rate for collecting streaming fees scaled to 1e6\\n    uint32 public override defaultFeeRate;\\n\\n    /// @custom:note CONFIG_WORD is used to omit the specific agreement hooks of superapps (NOOP - Not Operate)\\n    uint256 private immutable CONFIG_WORD = 1; // 1 << 0 == 1\\n\\n    /// @notice Mapping containing core address for every dHEDGE pool if deployed/created\\n    mapping(address => address) public cores;\\n\\n    constructor(address _dao, uint32 _defaultFeeRate) {\\n        implementation = address(new dHedgeCore());\\n        defaultFeeRate = _defaultFeeRate;\\n        dao = _dao;\\n    }\\n\\n    /// @dev Sets fee rate for all cores\\n    /// @param _defaultFeeRate The new fee rate scaled to 1e6\\n    function setDefaultFeeRate(uint32 _defaultFeeRate) external onlyOwner {\\n        defaultFeeRate = _defaultFeeRate;\\n\\n        emit FeeRateChanged(_defaultFeeRate);\\n    }\\n\\n    function setDAOAddress(address _dao) external onlyOwner {\\n        dao = _dao;\\n\\n        emit DAOAddressChanged(_dao);\\n    }\\n\\n    /// @notice Creates a new core for a given dHEDGE pool\\n    /// @param _dHedgePool Address of the dHEDGE pool for which a core needs to be created\\n    /// @param _DHPTx Supertoken of the corresponding DHPT of `_dHedgePool`\\n    function createdHedgeCore(address _dHedgePool, ISuperToken _DHPTx)\\n        external\\n    {\\n        require(cores[_dHedgePool] == address(0), \\\"Core already exists\\\");\\n\\n        address newCore = Clones.clone(implementation);\\n\\n        dHedgeCore(newCore).initialize(_dHedgePool, _DHPTx);\\n\\n        SFHelper.HOST.registerAppByFactory(ISuperApp(newCore), CONFIG_WORD);\\n\\n        cores[_dHedgePool] = newCore;\\n\\n        emit CoreCreated(newCore, _dHedgePool, address(_DHPTx));\\n    }\\n}\\n\",\"keccak256\":\"0xe29469fd18dd36d8ee72fbf650777ef3f9b6c5aa2f2547b1afef9a616298fcd8\",\"license\":\"Unlicensed\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c0604052600160a05234801561001557600080fd5b50604051612cac380380612cac83398101604081905261003491610118565b61003d336100bb565b6040516100499061010b565b604051809103906000f080158015610065573d6000803e3d6000fd5b5060601b6001600160601b031916608052600180546001600160c01b031916600160a01b63ffffffff93909316929092026001600160a01b031916919091176001600160a01b0392909216919091179055610164565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6123a68061090683390190565b6000806040838503121561012a578182fd5b82516001600160a01b0381168114610140578283fd5b602084015190925063ffffffff81168114610159578182fd5b809150509250929050565b60805160601c60a051610773610193600039600061035001526000818161012c01526102a901526107736000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c8063715018a611610066578063715018a61461014e57806385ad32c4146101565780638da5cb5b1461017f578063965afa8914610190578063f2fde38b146101a357600080fd5b806307d33455146100a35780633310e049146100d45780634162169f146100e957806353874009146101145780635c60da1b14610127575b600080fd5b6001546100ba90600160a01b900463ffffffff1681565b60405163ffffffff90911681526020015b60405180910390f35b6100e76100e23660046106cf565b6101b6565b005b6001546100fc906001600160a01b031681565b6040516001600160a01b0390911681526020016100cb565b6100e7610122366004610697565b610244565b6100fc7f000000000000000000000000000000000000000000000000000000000000000081565b6100e761043e565b6100fc610164366004610674565b6002602052600090815260409020546001600160a01b031681565b6000546001600160a01b03166100fc565b6100e761019e366004610674565b610474565b6100e76101b1366004610674565b6104ec565b6000546001600160a01b031633146101e95760405162461bcd60e51b81526004016101e0906106f3565b60405180910390fd5b6001805463ffffffff60a01b1916600160a01b63ffffffff8416908102919091179091556040519081527f50cdd878435a7740fd0e2a9f496a4b02b6be5fabe2d5cdc4621ce34b0eb622cf906020015b60405180910390a150565b6001600160a01b0382811660009081526002602052604090205416156102a25760405162461bcd60e51b8152602060048201526013602482015272436f726520616c72656164792065786973747360681b60448201526064016101e0565b60006102cd7f0000000000000000000000000000000000000000000000000000000000000000610587565b60405163485cc95560e01b81526001600160a01b03858116600483015284811660248301529192509082169063485cc95590604401600060405180830381600087803b15801561031c57600080fd5b505af1158015610330573d6000803e3d6000fd5b50506040516379b9982960e11b81526001600160a01b03841660048201527f00000000000000000000000000000000000000000000000000000000000000006024820152733e14dc1b13c488a8d5d310918780c983bd5982e7925063f37330529150604401600060405180830381600087803b1580156103af57600080fd5b505af11580156103c3573d6000803e3d6000fd5b505050506001600160a01b0383811660008181526002602090815260409182902080548686166001600160a01b031990911681179091558251908152908101929092529184168183015290517f868c3df5a35363022243f570d6994cbc4bd23970d31dfacc958e1136c1aefa1b9181900360600190a1505050565b6000546001600160a01b031633146104685760405162461bcd60e51b81526004016101e0906106f3565b6104726000610624565b565b6000546001600160a01b0316331461049e5760405162461bcd60e51b81526004016101e0906106f3565b600180546001600160a01b0319166001600160a01b0383169081179091556040519081527fecff1e63d1353a6547ccbdf184f5c70679a70ef4982fb945f9cfc59e2718d20090602001610239565b6000546001600160a01b031633146105165760405162461bcd60e51b81526004016101e0906106f3565b6001600160a01b03811661057b5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016101e0565b61058481610624565b50565b6000604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528260601b60148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f09150506001600160a01b03811661061f5760405162461bcd60e51b8152602060048201526016602482015275115490cc4c4d8dce8818dc99585d194819985a5b195960521b60448201526064016101e0565b919050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600060208284031215610685578081fd5b813561069081610728565b9392505050565b600080604083850312156106a9578081fd5b82356106b481610728565b915060208301356106c481610728565b809150509250929050565b6000602082840312156106e0578081fd5b813563ffffffff81168114610690578182fd5b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6001600160a01b038116811461058457600080fdfea2646970667358221220071369af05586b732601d9c4954ddcd453491171efecc858d3b1ac120db1356b64736f6c63430008040033608060405234801561001057600080fd5b50612386806100206000396000f3fe608060405234801561001057600080fd5b506004361061010b5760003560e01c8063587d5ff5116100a2578063884d1f4011610071578063884d1f4014610211578063911f94e114610224578063bf63e96014610245578063d86ed3e51461026a578063f1d640b01461027d57600080fd5b8063587d5ff5146101d0578063591f7ea5146101e35780635f9e7d77146101eb5780636ff1c9bc146101fe57600080fd5b8063485cc955116100de578063485cc95514610181578063525f45fb1461019457806353be974f146101a757806353c11f99146101bd57600080fd5b8063013116da14610110578063230dbd29146101445780632ea31c181461016457806330d9c9151461016e575b600080fd5b61012361011e366004611d39565b6102a4565b60408051921515835263ffffffff9091166020830152015b60405180910390f35b610157610152366004611ee7565b610301565b60405161013b919061214b565b61016c610471565b005b61015761017c366004611e4b565b61048e565b61016c61018f366004611da9565b6106b0565b61016c6101a2366004611d39565b6107bf565b60015460ff16604051901515815260200161013b565b6101576101cb366004611ee7565b61083c565b61016c6101de366004611da9565b6109e1565b61016c610a58565b6101576101f9366004611e4b565b610ac2565b61016c61020c366004611d39565b610c2c565b61015761021f366004611e4b565b610d7a565b610237610232366004611d71565b610ea7565b60405190815260200161013b565b600354600160a01b900463ffffffff1660405163ffffffff909116815260200161013b565b610157610278366004611ee7565b610f4b565b6102856114a5565b6040805192151583526001600160a01b0390911660208301520161013b565b6001600160a01b038181166000908152600460205260408120549091829116156102f65750506001600160a01b0316600090815260046020526040902054600191600160a01b90910463ffffffff1690565b506000928392509050565b606061030b611534565b610314896115a4565b82828080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050905060017334CAbB88CcEe33Feb1026CeF47E2cc37ADe49D5f63d9e9640990918b8d6001600160a01b031663ee719bc86040518163ffffffff1660e01b815260040160206040518083038186803b1580156103b357600080fd5b505afa1580156103c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103eb9190611d55565b858a8a6040518763ffffffff1660e01b815260040161040f96959493929190612202565b60006040518083038186803b15801561042757600080fd5b505af415801561043b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526104639190810190611e18565b9a9950505050505050505050565b61047a3361172c565b610482611809565b6001805460ff19169055565b6060610498611534565b6104a1876115a4565b6104a9611809565b6000886001600160a01b031663ee719bc86040518163ffffffff1660e01b815260040160206040518083038186803b1580156104e457600080fd5b505afa1580156104f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061051c9190611d55565b6001600160a01b03808216600090815260046020526040902054919250168015806105585750896001600160a01b0316816001600160a01b0316145b6105b55760405162461bcd60e51b8152602060048201526024808201527f644865646765436f72653a205375706572746f6b656e206e6f7420737570706f6044820152631c9d195960e21b60648201526084015b60405180910390fd5b6040516322462b9160e11b8152600160048201526001600160a01b03831660248201527334CAbB88CcEe33Feb1026CeF47E2cc37ADe49D5f9063448c57229060440160206040518083038186803b15801561060f57600080fd5b505af4158015610623573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106479190611dbb565b6106935760405162461bcd60e51b815260206004820152601d60248201527f644865646765436f72653a204e6f74206465706f73697420617373657400000060448201526064016105ac565b505060408051600081526020810190915298975050505050505050565b600054610100900460ff16806106c9575060005460ff16155b61072c5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084016105ac565b600054610100900460ff1615801561074e576000805461ffff19166101011790555b60018054600280546001600160a01b031990811633179091556001600160a01b03858116610100026001600160a81b0319909316929092178317909255600380549186169190921681179091556107a8908360001961185b565b80156107ba576000805461ff00191690555b505050565b6107c7611809565b60405163394110d160e01b8152600160048201526001600160a01b03821660248201527334CAbB88CcEe33Feb1026CeF47E2cc37ADe49D5f9063394110d19060440160006040518083038186803b15801561082157600080fd5b505af4158015610835573d6000803e3d6000fd5b5050505050565b6060610846611534565b82828080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050905060017334CAbB88CcEe33Feb1026CeF47E2cc37ADe49D5f63d9e9640990918b8d6001600160a01b031663ee719bc86040518163ffffffff1660e01b815260040160206040518083038186803b1580156108e557600080fd5b505afa1580156108f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061091d9190611d55565b858a8a6040518763ffffffff1660e01b815260040161094196959493929190612202565b60006040518083038186803b15801561095957600080fd5b505af492505050801561098e57506040513d6000823e601f3d908101601f1916820160405261098b9190810190611e18565b60015b6109d1573d8080156109bc576040519150601f19603f3d011682016040523d82523d6000602084013e6109c1565b606091505b506109cb81611955565b506109d4565b90505b9998505050505050505050565b6040516302e65b1d60e21b81526001600160a01b0383811660048301528216602482015273dD01FfdC9B6aFe601ABc4022bF83346Aec03867990630b996c749060440160006040518083038186803b158015610a3c57600080fd5b505af4158015610a50573d6000803e3d6000fd5b505050505050565b610a613361172c565b60015460ff1615610ab45760405162461bcd60e51b815260206004820152601f60248201527f644865646765436f72653a20506f6f6c20616c7265616479206163746976650060448201526064016105ac565b6001805460ff191681179055565b6060610acc611534565b60017334CAbB88CcEe33Feb1026CeF47E2cc37ADe49D5f635ac9370e9091898b6001600160a01b031663ee719bc86040518163ffffffff1660e01b815260040160206040518083038186803b158015610b2457600080fd5b505afa158015610b38573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b5c9190611d55565b87876040518663ffffffff1660e01b8152600401610b7e9594939291906121cf565b60006040518083038186803b158015610b9657600080fd5b505af4925050508015610bcb57506040513d6000823e601f3d908101601f19168201604052610bc89190810190611e18565b60015b610c1e573d808015610bf9576040519150601f19603f3d011682016040523d82523d6000602084013e610bfe565b606091505b50610c0881611955565b5050604080516000815260208101909152610c21565b90505b979650505050505050565b610c353361172c565b60025460408051634162169f60e01b81529051610d3b926001600160a01b031691634162169f916004808301926020929190829003018186803b158015610c7b57600080fd5b505afa158015610c8f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cb39190611d55565b6040516370a0823160e01b81523060048201526001600160a01b038416906370a082319060240160206040518083038186803b158015610cf257600080fd5b505afa158015610d06573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d2a9190611e00565b6001600160a01b0384169190611998565b6040516001600160a01b03821681527f5e7b34819cd91b239220bec92fcfd3c10da2214ba13e4e2b1f6c9cfdbd68a9a29060200160405180910390a150565b6060610d84611534565b610d8d876115a4565b610d95611809565b60017334CAbB88CcEe33Feb1026CeF47E2cc37ADe49D5f635ac9370e9091898b6001600160a01b031663ee719bc86040518163ffffffff1660e01b815260040160206040518083038186803b158015610ded57600080fd5b505afa158015610e01573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e259190611d55565b87876040518663ffffffff1660e01b8152600401610e479594939291906121cf565b60006040518083038186803b158015610e5f57600080fd5b505af4158015610e73573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610e9b9190810190611e18565b98975050505050505050565b604051631740215d60e01b8152600160048201526001600160a01b038084166024830152821660448201526000907334CAbB88CcEe33Feb1026CeF47E2cc37ADe49D5f90631740215d9060640160206040518083038186803b158015610f0c57600080fd5b505af4158015610f20573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f449190611e00565b9392505050565b6060610f55611534565b610f5e896115a4565b82828080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050905060008a6001600160a01b031663ee719bc86040518163ffffffff1660e01b815260040160206040518083038186803b158015610fe057600080fd5b505afa158015610ff4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110189190611d55565b6001600160a01b038082166000908152600460205260409020805492935091166111725780546001600160a01b0319166001600160a01b038d1617815560038054600160a01b900463ffffffff16906014611072836122eb565b825461010092830a63ffffffff818102199092169282160291909117909255835463ffffffff60a01b1916600160a01b938316840217808555426001868101919091555460405163989ebc6360e01b815273dD01FfdC9B6aFe601ABc4022bF83346Aec0386799563989ebc63956110ff959093046001600160a01b03169304909116908890600401612196565b60006040518083038186803b15801561111757600080fd5b505af415801561112b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526111539190810190611e18565b600354909350611172906001600160a01b03848116911660001961185b565b604051631fb6491d60e11b8152600090733e14dc1b13c488a8d5d310918780c983bd5982e790633f6c923a906111ac90879060040161214b565b60006040518083038186803b1580156111c457600080fd5b505afa1580156111d8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526112009190810190611fae565b60600151905060008d6001600160a01b031673dD01FfdC9B6aFe601ABc4022bF83346Aec038679638cca42b59091846040518363ffffffff1660e01b81526004016112619291906001600160a01b0392831681529116602082015260400190565b604080518083038186803b15801561127857600080fd5b505af415801561128c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112b091906120b1565b9150508d6001600160a01b03166323b872dd8330846bffffffffffffffffffffffff168760010154426112e391906122a8565b6112ed9190612289565b6040516001600160e01b031960e086901b1681526001600160a01b0393841660048201529290911660248301526044820152606401602060405180830381600087803b15801561133c57600080fd5b505af1158015611350573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113749190611dbb565b6113cb5760405162461bcd60e51b815260206004820152602260248201527f644865646765436f72653a20427566666572207472616e73666572206661696c604482015261195960f21b60648201526084016105ac565b8d6001600160a01b031673dD01FfdC9B6aFe601ABc4022bF83346Aec038679633d7013f69091600160000160019054906101000a90046001600160a01b03168660000160149054906101000a900463ffffffff16896040518563ffffffff1660e01b815260040161143f949392919061215e565b60006040518083038186803b15801561145757600080fd5b505af415801561146b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526114939190810190611e18565b9e9d5050505050505050505050505050565b60405163832a95fd60e01b81526001600482015260009081907334CAbB88CcEe33Feb1026CeF47E2cc37ADe49D5f9063832a95fd90602401604080518083038186803b1580156114f457600080fd5b505af4158015611508573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061152c9190611dd5565b915091509091565b33733e14dc1b13c488a8d5d310918780c983bd5982e7146115a25760405162461bcd60e51b815260206004820152602260248201527f644865646765436f72653a20537570706f727473206f6e6c79206f6e6520686f6044820152611cdd60f21b60648201526084016105ac565b565b7fa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd3816001600160a01b0316637730599e6040518163ffffffff1660e01b815260040160206040518083038186803b1580156115fe57600080fd5b505afa158015611612573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116369190611e00565b14806116d157507f8aedc3b5d4bf031e11a7e2940f7251c005698405d58e02e1c247fed3b1b3a674816001600160a01b0316637730599e6040518163ffffffff1660e01b815260040160206040518083038186803b15801561169757600080fd5b505afa1580156116ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116cf9190611e00565b145b6117295760405162461bcd60e51b8152602060048201526024808201527f644865646765436f72653a2043616c6c6261636b2063616c6c656420696c6c6560448201526367616c7960e01b60648201526084016105ac565b50565b60025460408051638da5cb5b60e01b815290516001600160a01b0390921691638da5cb5b91600480820192602092909190829003018186803b15801561177157600080fd5b505afa158015611785573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117a99190611d55565b6001600160a01b0316816001600160a01b0316146117295760405162461bcd60e51b815260206004820152601960248201527f644865646765436f72653a204e6f7420746865206f776e65720000000000000060448201526064016105ac565b60015460ff166115a25760405162461bcd60e51b815260206004820152601960248201527f644865646765436f72653a20506f6f6c20696e6163746976650000000000000060448201526064016105ac565b604051636eb1769f60e11b81523060048201526001600160a01b038381166024830152600091839186169063dd62ed3e9060440160206040518083038186803b1580156118a757600080fd5b505afa1580156118bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118df9190611e00565b6118e99190612271565b6040516001600160a01b03851660248201526044810182905290915061194f90859063095ea7b360e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526119c8565b50505050565b61172981604051602401611969919061214b565b60408051601f198184030181529190526020810180516001600160e01b03166305f3bfab60e11b179052611a9a565b6040516001600160a01b0383166024820152604481018290526107ba90849063a9059cbb60e01b90606401611918565b6000611a1d826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611abb9092919063ffffffff16565b8051909150156107ba5780806020019051810190611a3b9190611dbb565b6107ba5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016105ac565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b6060611aca8484600085611ad2565b949350505050565b606082471015611b335760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084016105ac565b843b611b815760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016105ac565b600080866001600160a01b03168587604051611b9d919061212f565b60006040518083038185875af1925050503d8060008114611bda576040519150601f19603f3d011682016040523d82523d6000602084013e611bdf565b606091505b5091509150610c2182828660608315611bf9575081610f44565b825115611c095782518084602001fd5b8160405162461bcd60e51b81526004016105ac919061214b565b8051611c2e8161233b565b919050565b80518015158114611c2e57600080fd5b80516001600160e01b031981168114611c2e57600080fd5b60008083601f840112611c6c578182fd5b50813567ffffffffffffffff811115611c83578182fd5b602083019150836020828501011115611c9b57600080fd5b9250929050565b600082601f830112611cb2578081fd5b815167ffffffffffffffff80821115611ccd57611ccd612325565b604051601f8301601f19908116603f01168101908282118183101715611cf557611cf5612325565b81604052838152866020858801011115611d0d578485fd5b611d1e8460208301602089016122bf565b9695505050505050565b805160ff81168114611c2e57600080fd5b600060208284031215611d4a578081fd5b8135610f448161233b565b600060208284031215611d66578081fd5b8151610f448161233b565b60008060408385031215611d83578081fd5b8235611d8e8161233b565b91506020830135611d9e8161233b565b809150509250929050565b60008060408385031215611d83578182fd5b600060208284031215611dcc578081fd5b610f4482611c33565b60008060408385031215611de7578182fd5b611df083611c33565b91506020830151611d9e8161233b565b600060208284031215611e11578081fd5b5051919050565b600060208284031215611e29578081fd5b815167ffffffffffffffff811115611e3f578182fd5b611aca84828501611ca2565b600080600080600080600060a0888a031215611e65578283fd5b8735611e708161233b565b96506020880135611e808161233b565b955060408801359450606088013567ffffffffffffffff80821115611ea3578485fd5b611eaf8b838c01611c5b565b909650945060808a0135915080821115611ec7578384fd5b50611ed48a828b01611c5b565b989b979a50959850939692959293505050565b600080600080600080600080600060c08a8c031215611f04578283fd5b8935611f0f8161233b565b985060208a0135611f1f8161233b565b975060408a0135965060608a013567ffffffffffffffff80821115611f42578485fd5b611f4e8d838e01611c5b565b909850965060808c0135915080821115611f66578485fd5b611f728d838e01611c5b565b909650945060a08c0135915080821115611f8a578384fd5b50611f978c828d01611c5b565b915080935050809150509295985092959850929598565b600060208284031215611fbf578081fd5b815167ffffffffffffffff80821115611fd6578283fd5b908301906101608286031215611fea578283fd5b611ff2612247565b611ffb83611d28565b815261200960208401611d28565b60208201526040830151604082015261202460608401611c23565b606082015261203560808401611c43565b608082015260a08301518281111561204b578485fd5b61205787828601611ca2565b60a08301525060c083015160c082015260e083015160e082015261010091508183015182820152610120915061208e828401611c23565b8282015261014091506120a2828401611c23565b91810191909152949350505050565b600080604083850312156120c3578182fd5b82519150602083015180600b0b8114611d9e578182fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6000815180845261211b8160208601602086016122bf565b601f01601f19169290920160200192915050565b600082516121418184602087016122bf565b9190910192915050565b602081526000610f446020830184612103565b6001600160a01b0385811682528416602082015263ffffffff83166040820152608060608201819052600090611d1e90830184612103565b6001600160a01b038416815263ffffffff831660208201526060604082018190526000906121c690830184612103565b95945050505050565b8581526001600160a01b03858116602083015284166040820152608060608201819052600090610c2190830184866120da565b8681526001600160a01b0386811660208301528516604082015260a06060820181905260009061223490830186612103565b82810360808401526109d48185876120da565b604051610160810167ffffffffffffffff8111828210171561226b5761226b612325565b60405290565b600082198211156122845761228461230f565b500190565b60008160001904831182151516156122a3576122a361230f565b500290565b6000828210156122ba576122ba61230f565b500390565b60005b838110156122da5781810151838201526020016122c2565b8381111561194f5750506000910152565b600063ffffffff808316818114156123055761230561230f565b6001019392505050565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b038116811461172957600080fdfea264697066735822122079b16bfa550265f818fb983e84ba9282ce7a42d3bc1d78a8f47b7603344f46f564736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061009e5760003560e01c8063715018a611610066578063715018a61461014e57806385ad32c4146101565780638da5cb5b1461017f578063965afa8914610190578063f2fde38b146101a357600080fd5b806307d33455146100a35780633310e049146100d45780634162169f146100e957806353874009146101145780635c60da1b14610127575b600080fd5b6001546100ba90600160a01b900463ffffffff1681565b60405163ffffffff90911681526020015b60405180910390f35b6100e76100e23660046106cf565b6101b6565b005b6001546100fc906001600160a01b031681565b6040516001600160a01b0390911681526020016100cb565b6100e7610122366004610697565b610244565b6100fc7f000000000000000000000000000000000000000000000000000000000000000081565b6100e761043e565b6100fc610164366004610674565b6002602052600090815260409020546001600160a01b031681565b6000546001600160a01b03166100fc565b6100e761019e366004610674565b610474565b6100e76101b1366004610674565b6104ec565b6000546001600160a01b031633146101e95760405162461bcd60e51b81526004016101e0906106f3565b60405180910390fd5b6001805463ffffffff60a01b1916600160a01b63ffffffff8416908102919091179091556040519081527f50cdd878435a7740fd0e2a9f496a4b02b6be5fabe2d5cdc4621ce34b0eb622cf906020015b60405180910390a150565b6001600160a01b0382811660009081526002602052604090205416156102a25760405162461bcd60e51b8152602060048201526013602482015272436f726520616c72656164792065786973747360681b60448201526064016101e0565b60006102cd7f0000000000000000000000000000000000000000000000000000000000000000610587565b60405163485cc95560e01b81526001600160a01b03858116600483015284811660248301529192509082169063485cc95590604401600060405180830381600087803b15801561031c57600080fd5b505af1158015610330573d6000803e3d6000fd5b50506040516379b9982960e11b81526001600160a01b03841660048201527f00000000000000000000000000000000000000000000000000000000000000006024820152733e14dc1b13c488a8d5d310918780c983bd5982e7925063f37330529150604401600060405180830381600087803b1580156103af57600080fd5b505af11580156103c3573d6000803e3d6000fd5b505050506001600160a01b0383811660008181526002602090815260409182902080548686166001600160a01b031990911681179091558251908152908101929092529184168183015290517f868c3df5a35363022243f570d6994cbc4bd23970d31dfacc958e1136c1aefa1b9181900360600190a1505050565b6000546001600160a01b031633146104685760405162461bcd60e51b81526004016101e0906106f3565b6104726000610624565b565b6000546001600160a01b0316331461049e5760405162461bcd60e51b81526004016101e0906106f3565b600180546001600160a01b0319166001600160a01b0383169081179091556040519081527fecff1e63d1353a6547ccbdf184f5c70679a70ef4982fb945f9cfc59e2718d20090602001610239565b6000546001600160a01b031633146105165760405162461bcd60e51b81526004016101e0906106f3565b6001600160a01b03811661057b5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016101e0565b61058481610624565b50565b6000604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528260601b60148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f09150506001600160a01b03811661061f5760405162461bcd60e51b8152602060048201526016602482015275115490cc4c4d8dce8818dc99585d194819985a5b195960521b60448201526064016101e0565b919050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600060208284031215610685578081fd5b813561069081610728565b9392505050565b600080604083850312156106a9578081fd5b82356106b481610728565b915060208301356106c481610728565b809150509250929050565b6000602082840312156106e0578081fd5b813563ffffffff81168114610690578182fd5b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6001600160a01b038116811461058457600080fdfea2646970667358221220071369af05586b732601d9c4954ddcd453491171efecc858d3b1ac120db1356b64736f6c63430008040033",
  "libraries": {
    "SFHelper": "0xdD01FfdC9B6aFe601ABc4022bF83346Aec038679",
    "dHedgeHelper": "0x34CAbB88CcEe33Feb1026CeF47E2cc37ADe49D5f"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "createdHedgeCore(address,address)": {
        "params": {
          "_DHPTx": "Supertoken of the corresponding DHPT of `_dHedgePool`",
          "_dHedgePool": "Address of the dHEDGE pool for which a core needs to be created"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "setDefaultFeeRate(uint32)": {
        "details": "Sets fee rate for all cores",
        "params": {
          "_defaultFeeRate": "The new fee rate scaled to 1e6"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "stateVariables": {
      "CONFIG_WORD": {
        "custom:note": "CONFIG_WORD is used to omit the specific agreement hooks of superapps (NOOP - Not Operate)"
      },
      "implementation": {
        "details": "The implementation contract for dHedgeCore can never be changed"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "cores(address)": {
        "notice": "Mapping containing core address for every dHEDGE pool if deployed/created"
      },
      "createdHedgeCore(address,address)": {
        "notice": "Creates a new core for a given dHEDGE pool"
      },
      "dao()": {
        "notice": "The DAO which receives fees"
      },
      "defaultFeeRate()": {
        "notice": "Fee rate for collecting streaming fees scaled to 1e6"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7,
        "contract": "contracts/dHedge-Factory-Version/dHedgeCoreFactory.sol:dHedgeCoreFactory",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 5394,
        "contract": "contracts/dHedge-Factory-Version/dHedgeCoreFactory.sol:dHedgeCoreFactory",
        "label": "dao",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 5398,
        "contract": "contracts/dHedge-Factory-Version/dHedgeCoreFactory.sol:dHedgeCoreFactory",
        "label": "defaultFeeRate",
        "offset": 20,
        "slot": "1",
        "type": "t_uint32"
      },
      {
        "astId": 5407,
        "contract": "contracts/dHedge-Factory-Version/dHedgeCoreFactory.sol:dHedgeCoreFactory",
        "label": "cores",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_address)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      }
    }
  }
}